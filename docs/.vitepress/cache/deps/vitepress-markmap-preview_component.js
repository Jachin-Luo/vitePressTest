import {
  Fragment,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createTextVNode,
  createVNode,
  customRef,
  defineComponent,
  getCurrentInstance,
  getCurrentScope,
  h,
  isVNode,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeUnmount,
  onMounted,
  onScopeDispose,
  onUnmounted,
  openBlock,
  reactive,
  readonly,
  ref,
  renderList,
  renderSlot,
  resolveDynamicComponent,
  shallowRef,
  toDisplayString,
  toRef,
  toValue,
  unref,
  useAttrs,
  vShow,
  watch,
  watchEffect,
  withCtx,
  withDirectives
} from "./chunk-2WSV55KD.js";
import {
  __publicField
} from "./chunk-V6TY7KAL.js";

// node_modules/.pnpm/vitepress-markmap-preview@0.2.0_markmap-common@0.18.9_typescript@5.9.3/node_modules/vitepress-markmap-preview/dist/component.js
var qm = "npm2url/dist/index.cjs";
var Rm = {
  jsdelivr: (e10) => `https://cdn.jsdelivr.net/npm/${e10}`,
  unpkg: (e10) => `https://unpkg.com/${e10}`
};
async function Pm(e10, t) {
  const n = await fetch(e10, {
    signal: t
  });
  if (!n.ok)
    throw n;
  await n.text();
}
var Hm = class {
  constructor() {
    this.providers = { ...Rm }, this.provider = "jsdelivr";
  }
  /**
   * Get the fastest provider name.
   * If none of the providers returns a valid response within `timeout`, an error will be thrown.
   */
  async getFastestProvider(t = 5e3, n = qm) {
    const r = new AbortController();
    let i = 0;
    try {
      return await new Promise((s, o) => {
        Promise.all(
          Object.entries(this.providers).map(async ([l, f]) => {
            try {
              await Pm(f(n), r.signal), s(l);
            } catch {
            }
          })
        ).then(() => o(new Error("All providers failed"))), i = setTimeout(o, t, new Error("Timed out"));
      });
    } finally {
      r.abort(), clearTimeout(i);
    }
  }
  /**
   * Set the current provider to the fastest provider found by `getFastestProvider`.
   */
  async findFastestProvider(t, n) {
    return this.provider = await this.getFastestProvider(t, n), this.provider;
  }
  setProvider(t, n) {
    n ? this.providers[t] = n : delete this.providers[t];
  }
  getFullUrl(t, n = this.provider) {
    if (t.includes("://"))
      return t;
    const r = this.providers[n];
    if (!r)
      throw new Error(`Provider ${n} not found`);
    return r(t);
  }
};
var Ei = class {
  constructor() {
    this.listeners = [];
  }
  tap(t) {
    return this.listeners.push(t), () => this.revoke(t);
  }
  revoke(t) {
    const n = this.listeners.indexOf(t);
    n >= 0 && this.listeners.splice(n, 1);
  }
  revokeAll() {
    this.listeners.splice(0);
  }
  call(...t) {
    for (const n of this.listeners)
      n(...t);
  }
};
var jm = Math.random().toString(36).slice(2, 8);
var Zc = 0;
function Um() {
  return Zc += 1, `mm-${jm}-${Zc}`;
}
function $r() {
}
function Ci(e10, t) {
  const n = (r, i) => t(
    r,
    () => {
      var s;
      return (s = r.children) == null ? void 0 : s.map((o) => n(o, r));
    },
    i
  );
  return n(e10);
}
function Vm(e10, ...t) {
  const n = (e10 || "").split(" ").filter(Boolean);
  return t.forEach((r) => {
    r && n.indexOf(r) < 0 && n.push(r);
  }), n.join(" ");
}
function Jc(e10, t) {
  return (...n) => t(e10, ...n);
}
function Gm() {
  const e10 = {};
  return e10.promise = new Promise((t, n) => {
    e10.resolve = t, e10.reject = n;
  }), e10;
}
function Wm(e10) {
  const t = {};
  return function(...r) {
    const i = `${r[0]}`;
    let s = t[i];
    return s || (s = {
      value: e10(...r)
    }, t[i] = s), s.value;
  };
}
function Km(e10, t) {
  const n = {
    timer: 0
  };
  function r() {
    n.timer && (window.clearTimeout(n.timer), n.timer = 0);
  }
  function i() {
    r(), n.args && (n.result = e10(...n.args));
  }
  return function(...o) {
    return r(), n.args = o, n.timer = window.setTimeout(i, t), n.result;
  };
}
var Yh = 1;
var Zh = 2;
var Xm = "http://www.w3.org/2000/svg";
var Vu = "http://www.w3.org/1999/xlink";
var Ym = {
  show: Vu,
  actuate: Vu,
  href: Vu
};
var Zm = (e10) => typeof e10 == "string" || typeof e10 == "number";
var Jm = (e10) => (e10 == null ? void 0 : e10.vtype) === Yh;
var Qm = (e10) => (e10 == null ? void 0 : e10.vtype) === Zh;
function e4(e10, t, ...n) {
  return t = Object.assign({}, t, {
    children: n.length === 1 ? n[0] : n
  }), t4(e10, t);
}
function t4(e10, t) {
  let n;
  if (typeof e10 == "string") n = Yh;
  else if (typeof e10 == "function") n = Zh;
  else throw new Error("Invalid VNode type");
  return {
    vtype: n,
    type: e10,
    props: t
  };
}
function n4(e10) {
  return e10.children;
}
var r4 = {
  isSvg: false
};
function Qc(e10, t) {
  Array.isArray(t) || (t = [t]), t = t.filter(Boolean), t.length && e10.append(...t);
}
function i4(e10, t, n) {
  for (const r in t)
    if (!(r === "key" || r === "children" || r === "ref"))
      if (r === "dangerouslySetInnerHTML")
        e10.innerHTML = t[r].__html;
      else if (r === "innerHTML" || r === "textContent" || r === "innerText" || r === "value" && ["textarea", "select"].includes(e10.tagName)) {
        const i = t[r];
        i != null && (e10[r] = i);
      } else r.startsWith("on") ? e10[r.toLowerCase()] = t[r] : u4(e10, r, t[r], n.isSvg);
}
var s4 = {
  className: "class",
  labelFor: "for"
};
function u4(e10, t, n, r) {
  if (t = s4[t] || t, n === true)
    e10.setAttribute(t, "");
  else if (n === false)
    e10.removeAttribute(t);
  else {
    const i = r ? Ym[t] : void 0;
    i !== void 0 ? e10.setAttributeNS(i, t, n) : e10.setAttribute(t, n);
  }
}
function o4(e10) {
  return e10.reduce((t, n) => t.concat(n), []);
}
function Fo(e10, t) {
  return Array.isArray(e10) ? o4(e10.map((n) => Fo(n, t))) : ya(e10, t);
}
function ya(e10, t = r4) {
  if (e10 == null || typeof e10 == "boolean")
    return null;
  if (e10 instanceof Node)
    return e10;
  if (Qm(e10)) {
    const {
      type: n,
      props: r
    } = e10;
    if (n === n4) {
      const s = document.createDocumentFragment();
      if (r.children) {
        const o = Fo(r.children, t);
        Qc(s, o);
      }
      return s;
    }
    const i = n(r);
    return ya(i, t);
  }
  if (Zm(e10))
    return document.createTextNode(`${e10}`);
  if (Jm(e10)) {
    let n;
    const {
      type: r,
      props: i
    } = e10;
    if (!t.isSvg && r === "svg" && (t = Object.assign({}, t, {
      isSvg: true
    })), t.isSvg ? n = document.createElementNS(Xm, r) : n = document.createElement(r), i4(n, i, t), i.children) {
      let o = t;
      t.isSvg && r === "foreignObject" && (o = Object.assign({}, o, {
        isSvg: false
      }));
      const l = Fo(i.children, o);
      l != null && Qc(n, l);
    }
    const {
      ref: s
    } = i;
    return typeof s == "function" && s(n), n;
  }
  throw new Error("mount: Invalid Vnode!");
}
function a4(e10) {
  return ya(e10);
}
function Jh(...e10) {
  return a4(e4(...e10));
}
var l4 = Wm((e10) => {
  document.head.append(
    Jh("link", {
      rel: "preload",
      as: "script",
      href: e10
    })
  );
});
var ef = {};
async function c4(e10, t) {
  var n;
  const r = e10.type === "script" && ((n = e10.data) == null ? void 0 : n.src) || "";
  if (e10.loaded || (e10.loaded = ef[r]), !e10.loaded) {
    const i = Gm();
    if (e10.loaded = i.promise, e10.type === "script" && (document.head.append(
      Jh("script", {
        ...e10.data,
        onLoad: () => i.resolve(),
        onError: i.reject
      })
    ), r ? ef[r] = e10.loaded : i.resolve()), e10.type === "iife") {
      const { fn: s, getParams: o } = e10.data;
      s(...(o == null ? void 0 : o(t)) || []), i.resolve();
    }
  }
  await e10.loaded;
}
async function Qh(e10, t) {
  e10.forEach((n) => {
    var r;
    n.type === "script" && ((r = n.data) != null && r.src) && l4(n.data.src);
  }), t = {
    getMarkmap: () => window.markmap,
    ...t
  };
  for (const n of e10)
    await c4(n, t);
}
function xa(e10) {
  return {
    type: "script",
    data: {
      src: e10
    }
  };
}
function e1(e10) {
  return {
    type: "stylesheet",
    data: {
      href: e10
    }
  };
}
var f4 = {
  _useHtmlParser2: false
};
function Bo(e10, t) {
  if (!e10)
    return t ?? f4;
  const n = {
    _useHtmlParser2: !!e10.xmlMode,
    ...t,
    ...e10
  };
  return e10.xml ? (n._useHtmlParser2 = true, n.xmlMode = true, e10.xml !== true && Object.assign(n, e10.xml)) : e10.xmlMode && (n._useHtmlParser2 = true), n;
}
var $e;
(function(e10) {
  e10.Root = "root", e10.Text = "text", e10.Directive = "directive", e10.Comment = "comment", e10.Script = "script", e10.Style = "style", e10.Tag = "tag", e10.CDATA = "cdata", e10.Doctype = "doctype";
})($e || ($e = {}));
function h4(e10) {
  return e10.type === $e.Tag || e10.type === $e.Script || e10.type === $e.Style;
}
var d4 = $e.Root;
var p4 = $e.Text;
var m4 = $e.Directive;
var g4 = $e.Comment;
var b4 = $e.Script;
var y4 = $e.Style;
var x4 = $e.Tag;
var w4 = $e.CDATA;
var v4 = $e.Doctype;
var t1 = class {
  constructor() {
    this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get parentNode() {
    return this.parent;
  }
  set parentNode(t) {
    this.parent = t;
  }
  /**
   * Same as {@link prev}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(t) {
    this.prev = t;
  }
  /**
   * Same as {@link next}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nextSibling() {
    return this.next;
  }
  set nextSibling(t) {
    this.next = t;
  }
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  cloneNode(t = false) {
    return Li(this, t);
  }
};
var wa = class extends t1 {
  /**
   * @param data The content of the data node
   */
  constructor(t) {
    super(), this.data = t;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nodeValue() {
    return this.data;
  }
  set nodeValue(t) {
    this.data = t;
  }
};
var c0 = class extends wa {
  constructor() {
    super(...arguments), this.type = $e.Text;
  }
  get nodeType() {
    return 3;
  }
};
var n1 = class extends wa {
  constructor() {
    super(...arguments), this.type = $e.Comment;
  }
  get nodeType() {
    return 8;
  }
};
var r1 = class extends wa {
  constructor(t, n) {
    super(n), this.name = t, this.type = $e.Directive;
  }
  get nodeType() {
    return 1;
  }
};
var va = class extends t1 {
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  constructor(t) {
    super(), this.children = t;
  }
  // Aliases
  /** First child of the node. */
  get firstChild() {
    var t;
    return (t = this.children[0]) !== null && t !== void 0 ? t : null;
  }
  /** Last child of the node. */
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  /**
   * Same as {@link children}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get childNodes() {
    return this.children;
  }
  set childNodes(t) {
    this.children = t;
  }
};
var i1 = class extends va {
  constructor() {
    super(...arguments), this.type = $e.CDATA;
  }
  get nodeType() {
    return 4;
  }
};
var $i = class extends va {
  constructor() {
    super(...arguments), this.type = $e.Root;
  }
  get nodeType() {
    return 9;
  }
};
var s1 = class extends va {
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  constructor(t, n, r = [], i = t === "script" ? $e.Script : t === "style" ? $e.Style : $e.Tag) {
    super(r), this.name = t, this.attribs = n, this.type = i;
  }
  get nodeType() {
    return 1;
  }
  // DOM Level 1 aliases
  /**
   * Same as {@link name}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get tagName() {
    return this.name;
  }
  set tagName(t) {
    this.name = t;
  }
  get attributes() {
    return Object.keys(this.attribs).map((t) => {
      var n, r;
      return {
        name: t,
        value: this.attribs[t],
        namespace: (n = this["x-attribsNamespace"]) === null || n === void 0 ? void 0 : n[t],
        prefix: (r = this["x-attribsPrefix"]) === null || r === void 0 ? void 0 : r[t]
      };
    });
  }
};
function ke(e10) {
  return h4(e10);
}
function F0(e10) {
  return e10.type === $e.CDATA;
}
function yr(e10) {
  return e10.type === $e.Text;
}
function ka(e10) {
  return e10.type === $e.Comment;
}
function k4(e10) {
  return e10.type === $e.Directive;
}
function _r(e10) {
  return e10.type === $e.Root;
}
function xt(e10) {
  return Object.prototype.hasOwnProperty.call(e10, "children");
}
function Li(e10, t = false) {
  let n;
  if (yr(e10))
    n = new c0(e10.data);
  else if (ka(e10))
    n = new n1(e10.data);
  else if (ke(e10)) {
    const r = t ? Gu(e10.children) : [], i = new s1(e10.name, { ...e10.attribs }, r);
    r.forEach((s) => s.parent = i), e10.namespace != null && (i.namespace = e10.namespace), e10["x-attribsNamespace"] && (i["x-attribsNamespace"] = { ...e10["x-attribsNamespace"] }), e10["x-attribsPrefix"] && (i["x-attribsPrefix"] = { ...e10["x-attribsPrefix"] }), n = i;
  } else if (F0(e10)) {
    const r = t ? Gu(e10.children) : [], i = new i1(r);
    r.forEach((s) => s.parent = i), n = i;
  } else if (_r(e10)) {
    const r = t ? Gu(e10.children) : [], i = new $i(r);
    r.forEach((s) => s.parent = i), e10["x-mode"] && (i["x-mode"] = e10["x-mode"]), n = i;
  } else if (k4(e10)) {
    const r = new r1(e10.name, e10.data);
    e10["x-name"] != null && (r["x-name"] = e10["x-name"], r["x-publicId"] = e10["x-publicId"], r["x-systemId"] = e10["x-systemId"]), n = r;
  } else
    throw new Error(`Not implemented yet: ${e10.type}`);
  return n.startIndex = e10.startIndex, n.endIndex = e10.endIndex, e10.sourceCodeLocation != null && (n.sourceCodeLocation = e10.sourceCodeLocation), n;
}
function Gu(e10) {
  const t = e10.map((n) => Li(n, true));
  for (let n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
var tf = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};
var _4 = class {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  constructor(t, n, r) {
    this.dom = [], this.root = new $i(this.dom), this.done = false, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof n == "function" && (r = n, n = tf), typeof t == "object" && (n = t, t = void 0), this.callback = t ?? null, this.options = n ?? tf, this.elementCB = r ?? null;
  }
  onparserinit(t) {
    this.parser = t;
  }
  // Resets the handler back to starting state
  onreset() {
    this.dom = [], this.root = new $i(this.dom), this.done = false, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
  }
  // Signals the handler that parsing is done
  onend() {
    this.done || (this.done = true, this.parser = null, this.handleCallback(null));
  }
  onerror(t) {
    this.handleCallback(t);
  }
  onclosetag() {
    this.lastNode = null;
    const t = this.tagStack.pop();
    this.options.withEndIndices && (t.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(t);
  }
  onopentag(t, n) {
    const r = this.options.xmlMode ? $e.Tag : void 0, i = new s1(t, n, void 0, r);
    this.addNode(i), this.tagStack.push(i);
  }
  ontext(t) {
    const { lastNode: n } = this;
    if (n && n.type === $e.Text)
      n.data += t, this.options.withEndIndices && (n.endIndex = this.parser.endIndex);
    else {
      const r = new c0(t);
      this.addNode(r), this.lastNode = r;
    }
  }
  oncomment(t) {
    if (this.lastNode && this.lastNode.type === $e.Comment) {
      this.lastNode.data += t;
      return;
    }
    const n = new n1(t);
    this.addNode(n), this.lastNode = n;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const t = new c0(""), n = new i1([t]);
    this.addNode(n), t.parent = n, this.lastNode = t;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(t, n) {
    const r = new r1(t, n);
    this.addNode(r);
  }
  handleCallback(t) {
    if (typeof this.callback == "function")
      this.callback(t, this.dom);
    else if (t)
      throw t;
  }
  addNode(t) {
    const n = this.tagStack[this.tagStack.length - 1], r = n.children[n.children.length - 1];
    this.options.withStartIndices && (t.startIndex = this.parser.startIndex), this.options.withEndIndices && (t.endIndex = this.parser.endIndex), n.children.push(t), r && (t.prev = r, r.next = t), t.parent = n, this.lastNode = null;
  }
};
var u1 = new Uint16Array(
  // prettier-ignore
  'áµ<Ã•Ä±ÊŠÒÕ»×ÙµÛŞ¢ß–à à©Šàª‘à¶¡à¹­à¼‰à¼¦áƒŠáˆ¨á‹¡á•á’á“ƒá“Ÿá”¥\0\0\0\0\0\0á•«á›á¦á°’á·á½¾â â†°âŠâ€â»â‘‚â ¤â¤’â´ˆâ¹ˆâ¿ã€–ãŠºã˜¹ã¬ã£¾ã¨¨ã©±ã« ã¬®à €EMabcfglmnoprstu\\bfmsÂ„Â‹ÂÂ•Â˜Â¦Â³Â¹ÃˆÃligè€»Ã†äƒ†Pè€»&ä€¦cuteè€»Ãäƒreve;ä„‚Ä€iyx}rcè€»Ã‚äƒ‚;är;ì€€ğ”„raveè€»Ã€äƒ€pha;ä‘acr;ä„€d;æ©“Ä€gpÂÂ¡on;ä„„f;ì€€ğ”¸plyFunction;æ¡ingè€»Ã…äƒ…Ä€csÂ¾Ãƒr;ì€€ğ’œign;æ‰”ildeè€»Ãƒäƒƒmlè€»Ã„äƒ„Ğ€aceforsuÃ¥Ã»Ã¾Ä—ÄœÄ¢Ä§ÄªÄ€crÃªÃ²kslash;æˆ–Å¶Ã¶Ã¸;æ«§ed;æŒ†y;ä‘Æ€crtÄ…Ä‹Ä”ause;æˆµnoullis;æ„¬a;ä’r;ì€€ğ”…pf;ì€€ğ”¹eve;ä‹˜cÃ²Ä“mpeq;æ‰Ü€HOacdefhilorsuÅÅ‘Å–Æ€ÆÆ¢ÆµÆ·ÆºÇœÈ•É³É¸É¾cy;ä§PYè€»Â©ä‚©Æ€cpyÅÅ¢Åºute;ä„†Ä€;iÅ§Å¨æ‹’talDifferentialD;æ……leys;æ„­È€aeioÆ‰ÆÆ”Æ˜ron;ä„Œdilè€»Ã‡äƒ‡rc;ä„ˆnint;æˆ°ot;ä„ŠÄ€dnÆ§Æ­illa;ä‚¸terDot;ä‚·Ã²Å¿i;ä§rcleÈ€DMPTÇ‡Ç‹Ç‘Ç–ot;æŠ™inus;æŠ–lus;æŠ•imes;æŠ—oÄ€csÇ¢Ç¸kwiseContourIntegral;æˆ²eCurlyÄ€DQÈƒÈoubleQuote;æ€uote;æ€™È€lnpuÈÈ¨É‡É•onÄ€;eÈ¥È¦æˆ·;æ©´Æ€gitÈ¯È¶Èºruent;æ‰¡nt;æˆ¯ourIntegral;æˆ®Ä€frÉŒÉ;æ„‚oduct;æˆnterClockwiseContourIntegral;æˆ³oss;æ¨¯cr;ì€€ğ’pÄ€;CÊ„Ê…æ‹“ap;æ‰Ö€DJSZacefiosÊ Ê¬Ê°Ê´Ê¸Ë‹Ë—Ë¡Ë¦Ì³ÒÄ€;oÅ¹Ê¥trahd;æ¤‘cy;ä‚cy;ä…cy;äÆ€grsÊ¿Ë„Ë‡ger;æ€¡r;æ†¡hv;æ«¤Ä€ayËË•ron;ä„;ä”lÄ€;tËËæˆ‡a;ä”r;ì€€ğ”‡Ä€afË«Ì§Ä€cmË°Ì¢riticalÈ€ADGTÌ€Ì†Ì–Ìœcute;ä‚´oÅ´Ì‹Ì;ä‹™bleAcute;ä‹rave;ä ilde;ä‹œond;æ‹„ferentialD;æ…†Ñ°Ì½\0\0\0Í‚Í”\0Ğ…f;ì€€ğ”»Æ€;DEÍˆÍ‰Íä‚¨ot;æƒœqual;æ‰bleÌ€CDLRUVÍ£Í²Î‚ÏÏ¢Ï¸ontourIntegraÃ¬È¹oÉ´Í¹\0\0Í»Â»Í‰nArrow;æ‡“Ä€eoÎ‡Î¤ftÆ€ARTÎÎ–Î¡rrow;æ‡ightArrow;æ‡”eÃ¥ËŠngÄ€LRÎ«Ï„eftÄ€ARÎ³Î¹rrow;æŸ¸ightArrow;æŸºightArrow;æŸ¹ightÄ€ATÏ˜Ïrrow;æ‡’ee;æŠ¨pÉÏ©\0\0Ï¯rrow;æ‡‘ownArrow;æ‡•erticalBar;æˆ¥nÌ€ABLRTaĞ’ĞªĞ°ÑÑ¿Í¼rrowÆ€;BUĞĞĞ¢æ†“ar;æ¤“pArrow;æ‡µreve;äŒ‘eftË’Ğº\0Ñ†\0ÑightVector;æ¥eeVector;æ¥ectorÄ€;BÑ™Ñšæ†½ar;æ¥–ightÇ”Ñ§\0Ñ±eeVector;æ¥ŸectorÄ€;BÑºÑ»æ‡ar;æ¥—eeÄ€;AÒ†Ò‡æŠ¤rrow;æ†§Ä€ctÒ’Ò—r;ì€€ğ’Ÿrok;ä„à €NTacdfglmopqstuxÒ½Ó€Ó„Ó‹ÓÓ¢Ó§Ó®ÓµÔ¡Ô¯Ô¶Õ’ÕÕ Õ¥G;ä…ŠHè€»Ãäƒcuteè€»Ã‰äƒ‰Æ€aiyÓ’Ó—Óœron;ä„šrcè€»ÃŠäƒŠ;ä­ot;ä„–r;ì€€ğ”ˆraveè€»Ãˆäƒˆement;æˆˆÄ€apÓºÓ¾cr;ä„’tyÉ“Ô†\0\0Ô’mallSquare;æ—»erySmallSquare;æ–«Ä€gpÔ¦Ôªon;ä„˜f;ì€€ğ”¼silon;ä•uÄ€aiÔ¼Õ‰lÄ€;TÕ‚Õƒæ©µilde;æ‰‚librium;æ‡ŒÄ€ciÕ—Õšr;æ„°m;æ©³a;ä—mlè€»Ã‹äƒ‹Ä€ipÕªÕ¯sts;æˆƒonentialE;æ…‡Ê€cfiosÖ…ÖˆÖÖ²×Œy;ä¤r;ì€€ğ”‰lledÉ“Ö—\0\0Ö£mallSquare;æ—¼erySmallSquare;æ–ªÍ°Öº\0Ö¿\0\0×„f;ì€€ğ”½All;æˆ€riertrf;æ„±cÃ²×‹Ø€JTabcdfgorst×¨×¬×¯×ºØ€Ø’Ø–Ø›ØØ£Ù¬Ù²cy;äƒè€»>ä€¾mmaÄ€;d×·×¸ä“;äœreve;ä„Æ€eiyØ‡ØŒØdil;ä„¢rc;ä„œ;ä“ot;ä„ r;ì€€ğ”Š;æ‹™pf;ì€€ğ”¾eaterÌ€EFGLSTØµÙ„ÙÙ–Ù›Ù¦qualÄ€;LØ¾Ø¿æ‰¥ess;æ‹›ullEqual;æ‰§reater;æª¢ess;æ‰·lantEqual;æ©¾ilde;æ‰³cr;ì€€ğ’¢;æ‰«Ğ€AacfiosuÚ…Ú‹Ú–Ú›ÚÚªÚ¾ÛŠRDcy;äªÄ€ctÚÚ”ek;ä‹‡;äirc;ä„¤r;æ„ŒlbertSpace;æ„‹Ç°Ú¯\0Ú²f;æ„izontalLine;æ”€Ä€ctÛƒÛ…Ã²Ú©rok;ä„¦mpÅ„ÛÛ˜ownHumÃ°Ä¯qual;æ‰Ü€EJOacdfgmnostuÛºÛ¾ÜƒÜ‡ÜÜšÜÜ¡Ü¨İ„İ¸Ş‹ŞŞ•cy;ä•lig;ä„²cy;äcuteè€»ÃäƒÄ€iyÜ“Ü˜rcè€»Ãäƒ;ä˜ot;ä„°r;æ„‘raveè€»ÃŒäƒŒÆ€;apÜ Ü¯Ü¿Ä€cgÜ´Ü·r;ä„ªinaryI;æ…ˆlieÃ³ÏÇ´İ‰\0İ¢Ä€;eİİæˆ¬Ä€grİ“İ˜ral;æˆ«section;æ‹‚isibleÄ€CTİ¬İ²omma;æ£imes;æ¢Æ€gptİ¿ŞƒŞˆon;ä„®f;ì€€ğ•€a;ä™cr;æ„ilde;ä„¨Ç«Şš\0Şcy;ä†lè€»ÃäƒÊ€cfosuŞ¬Ş·Ş¼ß‚ßÄ€iyŞ±Şµrc;ä„´;ä™r;ì€€ğ”pf;ì€€ğ•Ç£ß‡\0ßŒr;ì€€ğ’¥rcy;äˆkcy;ä„Î€HJacfosß¤ß¨ß¬ß±ß½à ‚à ˆcy;ä¥cy;äŒppa;äšÄ€eyß¶ß»dil;ä„¶;äšr;ì€€ğ”pf;ì€€ğ•‚cr;ì€€ğ’¦Ö€JTaceflmostà ¥à ©à ¬à¡à¡£à¦³à¦¸à§‡à§à¨·à©‡cy;ä‰è€»<ä€¼Ê€cmnprà ·à ¼à¡à¡„à¡ute;ä„¹bda;ä›g;æŸªlacetrf;æ„’r;æ†Æ€aeyà¡—à¡œà¡¡ron;ä„½dil;ä„»;ä›Ä€fsà¡¨à¥°tÔ€ACDFRTUVarà¡¾à¢©à¢±à£ à£¦à£¼à¤¯à¥›Îà¥ªÄ€nrà¢ƒà¢gleBracket;æŸ¨rowÆ€;BRà¢™à¢šà¢æ†ar;æ‡¤ightArrow;æ‡†eiling;æŒˆoÇµà¢·\0à£ƒbleBracket;æŸ¦nÇ”à£ˆ\0à£’eeVector;æ¥¡ectorÄ€;Bà£›à£œæ‡ƒar;æ¥™loor;æŒŠightÄ€AVà£¯à£µrrow;æ†”ector;æ¥Ä€erà¤à¤—eÆ€;AVà¤‰à¤Šà¤æŠ£rrow;æ†¤ector;æ¥šiangleÆ€;BEà¤¤à¤¥à¤©æŠ²ar;æ§qual;æŠ´pÆ€DTVà¤·à¥‚à¥ŒownVector;æ¥‘eeVector;æ¥ ectorÄ€;Bà¥–à¥—æ†¿ar;æ¥˜ectorÄ€;Bà¥¥à¥¦æ†¼ar;æ¥’ightÃ¡ÎœsÌ€EFGLSTà¥¾à¦‹à¦•à¦à¦¢à¦­qualGreater;æ‹šullEqual;æ‰¦reater;æ‰¶ess;æª¡lantEqual;æ©½ilde;æ‰²r;ì€€ğ”Ä€;eà¦½à¦¾æ‹˜ftarrow;æ‡šidot;ä„¿Æ€npwà§”à¨–à¨›gÈ€LRlrà§à§·à¨‚à¨eftÄ€ARà§¦à§¬rrow;æŸµightArrow;æŸ·ightArrow;æŸ¶eftÄ€arÎ³à¨ŠightÃ¡Î¿ightÃ¡ÏŠf;ì€€ğ•ƒerÄ€LRà¨¢à¨¬eftArrow;æ†™ightArrow;æ†˜Æ€chtà¨¾à©€à©‚Ã²à¡Œ;æ†°rok;ä…;æ‰ªĞ€acefiosuà©šà©à© à©·à©¼àª…àª‹àªp;æ¤…y;äœÄ€dlà©¥à©¯iumSpace;æŸlintrf;æ„³r;ì€€ğ”nusPlus;æˆ“pf;ì€€ğ•„cÃ²à©¶;äœÒ€Jacefostuàª£àª§àª­à«€à¬”à¬™à¶‘à¶—à¶cy;äŠcute;ä…ƒÆ€aeyàª´àª¹àª¾ron;ä…‡dil;ä……;äÆ€gswà«‡à«°à¬ativeÆ€MTVà«“à«Ÿà«¨ediumSpace;æ€‹hiÄ€cnà«¦à«˜Ã«à«™eryThiÃ®à«™tedÄ€GLà«¸à¬†reaterGreateÃ²Ù³essLesÃ³à©ˆLine;ä€Šr;ì€€ğ”‘È€Bnptà¬¢à¬¨à¬·à¬ºreak;æ BreakingSpace;ä‚ f;æ„•Ú€;CDEGHLNPRSTVà­•à­–à­ªà­¼à®¡à¯«à°„à±à²„à²¦à³˜àµ¡à¶…æ«¬Ä€ouà­›à­¤ngruent;æ‰¢pCap;æ‰­oubleVerticalBar;æˆ¦Æ€lqxà®ƒà®Šà®›ement;æˆ‰ualÄ€;Tà®’à®“æ‰ ilde;ì€€â‰‚Ì¸ists;æˆ„reaterÎ€;EFGLSTà®¶à®·à®½à¯‰à¯“à¯˜à¯¥æ‰¯qual;æ‰±ullEqual;ì€€â‰§Ì¸reater;ì€€â‰«Ì¸ess;æ‰¹lantEqual;ì€€â©¾Ì¸ilde;æ‰µumpÅ„à¯²à¯½ownHump;ì€€â‰Ì¸qual;ì€€â‰Ì¸eÄ€fsà°Šà°§tTriangleÆ€;BEà°šà°›à°¡æ‹ªar;ì€€â§Ì¸qual;æ‹¬sÌ€;EGLSTà°µà°¶à°¼à±„à±‹à±˜æ‰®qual;æ‰°reater;æ‰¸ess;ì€€â‰ªÌ¸lantEqual;ì€€â©½Ì¸ilde;æ‰´estedÄ€GLà±¨à±¹reaterGreater;ì€€âª¢Ì¸essLess;ì€€âª¡Ì¸recedesÆ€;ESà²’à²“à²›æŠ€qual;ì€€âª¯Ì¸lantEqual;æ‹ Ä€eià²«à²¹verseElement;æˆŒghtTriangleÆ€;BEà³‹à³Œà³’æ‹«ar;ì€€â§Ì¸qual;æ‹­Ä€quà³à´ŒuareSuÄ€bpà³¨à³¹setÄ€;Eà³°à³³ì€€âŠÌ¸qual;æ‹¢ersetÄ€;Eà´ƒà´†ì€€âŠÌ¸qual;æ‹£Æ€bcpà´“à´¤àµsetÄ€;Eà´›à´ì€€âŠ‚âƒ’qual;æŠˆceedsÈ€;ESTà´²à´³à´»àµ†æŠqual;ì€€âª°Ì¸lantEqual;æ‹¡ilde;ì€€â‰¿Ì¸ersetÄ€;Eàµ˜àµ›ì€€âŠƒâƒ’qual;æŠ‰ildeÈ€;EFTàµ®àµ¯àµµàµ¿æ‰qual;æ‰„ullEqual;æ‰‡ilde;æ‰‰erticalBar;æˆ¤cr;ì€€ğ’©ildeè€»Ã‘äƒ‘;äÜ€Eacdfgmoprstuvà¶½à·‚à·‰à·•à·›à· à·§à·¼à¸‚à¸ à¸¢à¸²à¸¿à¹„lig;ä…’cuteè€»Ã“äƒ“Ä€iyà·à·“rcè€»Ã”äƒ”;äblac;ä…r;ì€€ğ”’raveè€»Ã’äƒ’Æ€aeià·®à·²à·¶cr;ä…Œga;ä©cron;äŸpf;ì€€ğ•†enCurlyÄ€DQà¸à¸šoubleQuote;æ€œuote;æ€˜;æ©”Ä€clà¸§à¸¬r;ì€€ğ’ªashè€»Ã˜äƒ˜iÅ¬à¸·à¸¼deè€»Ã•äƒ•es;æ¨·mlè€»Ã–äƒ–erÄ€BPà¹‹à¹ Ä€arà¹à¹“r;æ€¾acÄ€ekà¹šà¹œ;æet;æ´arenthesis;æœÒ€acfhilorsà¹¿àº‡àºŠàºàº’àº”àºàº°à»¼rtialD;æˆ‚y;äŸr;ì€€ğ”“i;ä¦;ä usMinus;ä‚±Ä€ipàº¢àº­ncareplanÃ¥Úf;æ„™È€;eioàº¹àººà» à»¤æª»cedesÈ€;ESTà»ˆà»‰à»à»šæ‰ºqual;æª¯lantEqual;æ‰¼ilde;æ‰¾me;æ€³Ä€dpà»©à»®uct;æˆortionÄ€;aÈ¥à»¹l;æˆÄ€cià¼à¼†r;ì€€ğ’«;ä¨È€Ufosà¼‘à¼–à¼›à¼ŸOTè€»"ä€¢r;ì€€ğ””pf;æ„šcr;ì€€ğ’¬Ø€BEacefhiorsuà¼¾à½ƒà½‡à½ à½³à¾§à¾ªà¾­á‚–á‚©á‚´á‚¾arr;æ¤Gè€»Â®ä‚®Æ€cnrà½à½“à½–ute;ä…”g;æŸ«rÄ€;tà½œà½æ† l;æ¤–Æ€aeyà½§à½¬à½±ron;ä…˜dil;ä…–;ä Ä€;và½¸à½¹æ„œerseÄ€EUà¾‚à¾™Ä€lqà¾‡à¾ement;æˆ‹uilibrium;æ‡‹pEquilibrium;æ¥¯rÂ»à½¹o;ä¡ghtĞ€ACDFTUVaà¿à¿«à¿³á€¢á€¨á›á‚‡Ï˜Ä€nrà¿†à¿’gleBracket;æŸ©rowÆ€;BLà¿œà¿à¿¡æ†’ar;æ‡¥eftArrow;æ‡„eiling;æŒ‰oÇµà¿¹\0á€…bleBracket;æŸ§nÇ”á€Š\0á€”eeVector;æ¥ectorÄ€;Bá€á€æ‡‚ar;æ¥•loor;æŒ‹Ä€erá€­áƒeÆ€;AVá€µá€¶á€¼æŠ¢rrow;æ†¦ector;æ¥›iangleÆ€;BEáá‘á•æŠ³ar;æ§qual;æŠµpÆ€DTVá£á®á¸ownVector;æ¥eeVector;æ¥œectorÄ€;Bá‚‚á‚ƒæ†¾ar;æ¥”ectorÄ€;Bá‚‘á‚’æ‡€ar;æ¥“Ä€puá‚›á‚f;æ„ndImplies;æ¥°ightarrow;æ‡›Ä€chá‚¹á‚¼r;æ„›;æ†±leDelayed;æ§´Ú€HOacfhimoqstuáƒ¤áƒ±áƒ·áƒ½á„™á„á…‘á…–á…¡á…§á†µá†»á†¿Ä€Ccáƒ©áƒ®Hcy;ä©y;ä¨FTcy;ä¬cute;ä…šÊ€;aeiyá„ˆá„‰á„á„“á„—æª¼ron;ä… dil;ä…rc;ä…œ;ä¡r;ì€€ğ”–ortÈ€DLRUá„ªá„´á„¾á…‰ownArrowÂ»ĞeftArrowÂ»à¢šightArrowÂ»à¿pArrow;æ†‘gma;ä£allCircle;æˆ˜pf;ì€€ğ•ŠÉ²á…­\0\0á…°t;æˆšareÈ€;ISUá…»á…¼á†‰á†¯æ–¡ntersection;æŠ“uÄ€bpá†á†setÄ€;Eá†—á†˜æŠqual;æŠ‘ersetÄ€;Eá†¨á†©æŠqual;æŠ’nion;æŠ”cr;ì€€ğ’®ar;æ‹†È€bcmpá‡ˆá‡›áˆ‰áˆ‹Ä€;sá‡á‡æ‹etÄ€;Eá‡á‡•qual;æŠ†Ä€chá‡ áˆ…eedsÈ€;ESTá‡­á‡®á‡´á‡¿æ‰»qual;æª°lantEqual;æ‰½ilde;æ‰¿ThÃ¡à¾Œ;æˆ‘Æ€;esáˆ’áˆ“áˆ£æ‹‘rsetÄ€;EáˆœáˆæŠƒqual;æŠ‡etÂ»áˆ“Ö€HRSacfhiorsáˆ¾á‰„á‰‰á‰•á‰á‰±á‰¶áŠŸá‹‚á‹ˆá‹‘ORNè€»ÃäƒADE;æ„¢Ä€Hcá‰á‰’cy;ä‹y;ä¦Ä€buá‰šá‰œ;ä€‰;ä¤Æ€aeyá‰¥á‰ªá‰¯ron;ä…¤dil;ä…¢;ä¢r;ì€€ğ”—Ä€eiá‰»áŠ‰Ç²áŠ€\0áŠ‡efore;æˆ´a;ä˜Ä€cnáŠáŠ˜kSpace;ì€€âŸâ€ŠSpace;æ€‰ldeÈ€;EFTáŠ«áŠ¬áŠ²áŠ¼æˆ¼qual;æ‰ƒullEqual;æ‰…ilde;æ‰ˆpf;ì€€ğ•‹ipleDot;æƒ›Ä€ctá‹–á‹›r;ì€€ğ’¯rok;ä…¦à«¡á‹·áŒáŒšáŒ¦\0áŒ¬áŒ±\0\0\0\0\0áŒ¸áŒ½á·á…\0á¿á„áŠáÄ€crá‹»áŒuteè€»ÃšäƒšrÄ€;oáŒ‡áŒˆæ†Ÿcir;æ¥‰rÇ£áŒ“\0áŒ–y;äve;ä…¬Ä€iyáŒáŒ£rcè€»Ã›äƒ›;ä£blac;ä…°r;ì€€ğ”˜raveè€»Ã™äƒ™acr;ä…ªÄ€diáá©erÄ€BPáˆáÄ€aráár;äŸacÄ€eká—á™;æŸet;æµarenthesis;æonÄ€;Pá°á±æ‹ƒlus;æŠÄ€gpá»á¿on;ä…²f;ì€€ğ•ŒĞ€ADETadpsá•á®á¸á„Ï¨á’á—á³rrowÆ€;BDá…á á¤ar;æ¤’ownArrow;æ‡…ownArrow;æ†•quilibrium;æ¥®eeÄ€;Aá‹áŒæŠ¥rrow;æ†¥ownÃ¡Ï³erÄ€LRáá¨eftArrow;æ†–ightArrow;æ†—iÄ€;lá¹áºä’on;ä¥ing;ä…®cr;ì€€ğ’°ilde;ä…¨mlè€»ÃœäƒœÒ€Dbcdefosvá§á¬á°á³á¾á’…á’Šá’á’–ash;æŠ«ar;æ««y;ä’ashÄ€;lá»á¼æŠ©;æ«¦Ä€erá‘ƒá‘…;æ‹Æ€btyá‘Œá‘á‘ºar;æ€–Ä€;iá‘á‘•calÈ€BLSTá‘¡á‘¥á‘ªá‘´ar;æˆ£ine;ä¼eparator;æ˜ilde;æ‰€ThinSpace;æ€Šr;ì€€ğ”™pf;ì€€ğ•cr;ì€€ğ’±dash;æŠªÊ€cefosá’§á’¬á’±á’¶á’¼irc;ä…´dge;æ‹€r;ì€€ğ”špf;ì€€ğ•cr;ì€€ğ’²È€fiosá“‹á“á“’á“˜r;ì€€ğ”›;äpf;ì€€ğ•cr;ì€€ğ’³Ò€AIUacfosuá“±á“µá“¹á“½á”„á”á””á”šá” cy;ä¯cy;ä‡cy;ä®cuteè€»ÃäƒÄ€iyá”‰á”rc;ä…¶;ä«r;ì€€ğ”œpf;ì€€ğ•cr;ì€€ğ’´ml;ä…¸Ğ€Hacdefosá”µá”¹á”¿á•‹á•á•á• á•¤cy;ä–cute;ä…¹Ä€ayá•„á•‰ron;ä…½;ä—ot;ä…»Ç²á•”\0á•›oWidtÃ¨à«™a;ä–r;æ„¨pf;æ„¤cr;ì€€ğ’µà¯¡á–ƒá–Šá–\0á–°á–¶á–¿\0\0\0\0á—†á—›á—«á™Ÿá™­\0áš•áš›áš²áš¹\0áš¾cuteè€»Ã¡äƒ¡reve;ä„ƒÌ€;Ediuyá–œá–á–¡á–£á–¨á–­æˆ¾;ì€€âˆ¾Ì³;æˆ¿rcè€»Ã¢äƒ¢teè‚»Â´Ì†;ä°ligè€»Ã¦äƒ¦Ä€;rÂ²á–º;ì€€ğ”raveè€»Ã äƒ Ä€epá—Šá—–Ä€fpá—á—”sym;æ„µÃ¨á—“ha;ä±Ä€apá—ŸcÄ€clá—¤á—§r;ä„g;æ¨¿É¤á—°\0\0á˜ŠÊ€;adsvá—ºá—»á—¿á˜á˜‡æˆ§nd;æ©•;æ©œlope;æ©˜;æ©šÎ€;elmrszá˜˜á˜™á˜›á˜á˜¿á™á™™æˆ ;æ¦¤eÂ»á˜™sdÄ€;aá˜¥á˜¦æˆ¡Ñ¡á˜°á˜²á˜´á˜¶á˜¸á˜ºá˜¼á˜¾;æ¦¨;æ¦©;æ¦ª;æ¦«;æ¦¬;æ¦­;æ¦®;æ¦¯tÄ€;vá™…á™†æˆŸbÄ€;dá™Œá™æŠ¾;æ¦Ä€ptá™”á™—h;æˆ¢Â»Â¹arr;æ¼Ä€gpá™£á™§on;ä„…f;ì€€ğ•’Î€;Eaeiopá‹á™»á™½áš‚áš„áš‡ášŠ;æ©°cir;æ©¯;æ‰Šd;æ‰‹s;ä€§roxÄ€;eá‹áš’Ã±ášƒingè€»Ã¥äƒ¥Æ€ctyáš¡áš¦áš¨r;ì€€ğ’¶;ä€ªmpÄ€;eá‹áš¯Ã±Êˆildeè€»Ã£äƒ£mlè€»Ã¤äƒ¤Ä€ciá›‚á›ˆoninÃ´É²nt;æ¨‘à €Nabcdefiklnoprsuá›­á›±áœ°áœ¼áƒáˆá¸á½áŸ áŸ¦á ¹á¡áœá¤½á¥ˆá¥°ot;æ«­Ä€crá›¶áœkÈ€cepsáœ€áœ…áœáœ“ong;æ‰Œpsilon;ä¶rime;æ€µimÄ€;eáœšáœ›æˆ½q;æ‹Å¶áœ¢áœ¦ee;æŠ½edÄ€;gáœ¬áœ­æŒ…eÂ»áœ­rkÄ€;táœáœ·brk;æ¶Ä€oyáœá;ä±quo;æ€Ê€cmprtá“á›á¡á¤á¨ausÄ€;eÄŠÄ‰ptyv;æ¦°sÃ©áœŒnoÃµÄ“Æ€ahwá¯á±á³;ä²;æ„¶een;æ‰¬r;ì€€ğ”ŸgÎ€costuvwááá³áŸáŸ•áŸ›áŸÆ€aiuá”á–ášÃ°İ rc;æ—¯pÂ»á±Æ€dptá¤á¨á­ot;æ¨€lus;æ¨imes;æ¨‚É±á¹\0\0á¾cup;æ¨†ar;æ˜…riangleÄ€duáŸáŸ’own;æ–½p;æ–³plus;æ¨„eÃ¥á‘„Ã¥á’­arow;æ¤Æ€akoáŸ­á ¦á µÄ€cnáŸ²á £kÆ€lstáŸºÖ«á ‚ozenge;æ§«riangleÈ€;dlrá ’á “á ˜á æ–´own;æ–¾eft;æ—‚ight;æ–¸k;æ£Æ±á «\0á ³Æ²á ¯\0á ±;æ–’;æ–‘4;æ–“ck;æ–ˆÄ€eoá ¾á¡Ä€;qá¡ƒá¡†ì€€=âƒ¥uiv;ì€€â‰¡âƒ¥t;æŒÈ€ptwxá¡™á¡á¡§á¡¬f;ì€€ğ•“Ä€;tá‹á¡£omÂ»áŒtie;æ‹ˆØ€DHUVbdhmptuvá¢…á¢–á¢ªá¢»á£—á£›á£¬á£¿á¤…á¤Šá¤á¤¡È€LRlrá¢á¢á¢’á¢”;æ•—;æ•”;æ•–;æ•“Ê€;DUduá¢¡á¢¢á¢¤á¢¦á¢¨æ•;æ•¦;æ•©;æ•¤;æ•§È€LRlrá¢³á¢µá¢·á¢¹;æ•;æ•š;æ•œ;æ•™Î€;HLRhlrá£Šá£‹á£á£á£‘á£“á£•æ•‘;æ•¬;æ•£;æ• ;æ•«;æ•¢;æ•Ÿox;æ§‰È€LRlrá£¤á£¦á£¨á£ª;æ••;æ•’;æ”;æ”ŒÊ€;DUduÚ½á£·á£¹á£»á£½;æ•¥;æ•¨;æ”¬;æ”´inus;æŠŸlus;æŠimes;æŠ È€LRlrá¤™á¤›á¤á¤Ÿ;æ•›;æ•˜;æ”˜;æ””Î€;HLRhlrá¤°á¤±á¤³á¤µá¤·á¤¹á¤»æ”‚;æ•ª;æ•¡;æ•;æ”¼;æ”¤;æ”œÄ€evÄ£á¥‚barè€»Â¦ä‚¦È€ceioá¥‘á¥–á¥šá¥ r;ì€€ğ’·mi;æmÄ€;eáœšáœœlÆ€;bhá¥¨á¥©á¥«äœ;æ§…sub;æŸˆÅ¬á¥´á¥¾lÄ€;eá¥¹á¥ºæ€¢tÂ»á¥ºpÆ€;EeÄ¯á¦…á¦‡;æª®Ä€;qÛœÛ›à³¡á¦§\0á§¨á¨‘á¨•á¨²\0á¨·á©\0\0áª´\0\0á«\0\0á¬¡á¬®á­á­’\0á¯½\0á°ŒÆ€cprá¦­á¦²á§ute;ä„‡Ì€;abcdsá¦¿á§€á§„á§Šá§•á§™æˆ©nd;æ©„rcup;æ©‰Ä€auá§á§’p;æ©‹p;æ©‡ot;æ©€;ì€€âˆ©ï¸€Ä€eoá§¢á§¥t;æÃ®Ú“È€aeiuá§°á§»á¨á¨…Ç°á§µ\0á§¸s;æ©on;ä„dilè€»Ã§äƒ§rc;ä„‰psÄ€;sá¨Œá¨æ©Œm;æ©ot;ä„‹Æ€dmná¨›á¨ á¨¦ilè‚»Â¸Æ­ptyv;æ¦²tè„€Â¢;eá¨­á¨®ä‚¢rÃ¤Æ²r;ì€€ğ” Æ€ceiá¨½á©€á©y;ä‘‡ckÄ€;má©‡á©ˆæœ“arkÂ»á©ˆ;ä‡rÎ€;Ecefmsá©Ÿá© á©¢á©«áª¤áªªáª®æ—‹;æ§ƒÆ€;elá©©á©ªá©­ä‹†q;æ‰—eÉ¡á©´\0\0áªˆrrowÄ€lrá©¼áªeft;æ†ºight;æ†»Ê€RSacdáª’áª”áª–áªšáªŸÂ»à½‡;æ“ˆst;æŠ›irc;æŠšash;æŠnint;æ¨id;æ«¯cir;æ§‚ubsÄ€;uáª»áª¼æ™£itÂ»áª¼Ë¬á«‡á«”á«º\0á¬ŠonÄ€;eá«á«ä€ºÄ€;qÃ‡Ã†É­á«™\0\0á«¢aÄ€;tá«á«Ÿä€¬;ä€Æ€;flá«¨á«©á««æˆÃ®á… eÄ€mxá«±á«¶entÂ»á«©eÃ³ÉÇ§á«¾\0á¬‡Ä€;dáŠ»á¬‚ot;æ©­nÃ´É†Æ€fryá¬á¬”á¬—;ì€€ğ•”oÃ¤É”è„€Â©;sÅ•á¬r;æ„—Ä€aoá¬¥á¬©rr;æ†µss;æœ—Ä€cuá¬²á¬·r;ì€€ğ’¸Ä€bpá¬¼á­„Ä€;eá­á­‚æ«;æ«‘Ä€;eá­‰á­Šæ«;æ«’dot;æ‹¯Î€delprvwá­ á­¬á­·á®‚á®¬á¯”á¯¹arrÄ€lrá­¨á­ª;æ¤¸;æ¤µÉ°á­²\0\0á­µr;æ‹c;æ‹ŸarrÄ€;pá­¿á®€æ†¶;æ¤½Ì€;bcdosá®á®á®–á®¡á®¥á®¨æˆªrcap;æ©ˆÄ€auá®›á®p;æ©†p;æ©Šot;æŠr;æ©…;ì€€âˆªï¸€È€alrvá®µá®¿á¯á¯£rrÄ€;má®¼á®½æ†·;æ¤¼yÆ€evwá¯‡á¯”á¯˜qÉ°á¯\0\0á¯’reÃ£á­³uÃ£á­µee;æ‹edge;æ‹enè€»Â¤ä‚¤earrowÄ€lrá¯®á¯³eftÂ»á®€ightÂ»á®½eÃ¤á¯Ä€ciá°á°‡oninÃ´Ç·nt;æˆ±lcty;æŒ­à¦€AHabcdefhijlorstuwzá°¸á°»á°¿á±á±©á±µá²Šá²á²¬á²·á³»á³¿á´áµ»á¶‘á¶«á¶»á·†á·rÃ²Îar;æ¥¥È€glrsá±ˆá±á±’á±”ger;æ€ eth;æ„¸Ã²á„³hÄ€;vá±šá±›æ€Â»à¤ŠÅ«á±¡á±§arow;æ¤aÃ£Ì•Ä€ayá±®á±³ron;ä„;ä´Æ€;aoÌ²á±¼á²„Ä€grÊ¿á²r;æ‡Štseq;æ©·Æ€glmá²‘á²”á²˜è€»Â°ä‚°ta;ä´ptyv;æ¦±Ä€irá²£á²¨sht;æ¥¿;ì€€ğ”¡arÄ€lrá²³á²µÂ»à£œÂ»á€Ê€aegsvá³‚Í¸á³–á³œá³ mÆ€;osÌ¦á³Šá³”ndÄ€;sÌ¦á³‘uit;æ™¦amma;äin;æ‹²Æ€;ioá³§á³¨á³¸äƒ·deè„€Ã·;oá³§á³°ntimes;æ‹‡nÃ¸á³·cy;ä‘’cÉ¯á´†\0\0á´Šrn;æŒop;æŒÊ€lptuwá´˜á´á´¢áµ‰áµ•lar;ä€¤f;ì€€ğ••Ê€;empsÌ‹á´­á´·á´½áµ‚qÄ€;dÍ’á´³ot;æ‰‘inus;æˆ¸lus;æˆ”quare;æŠ¡blebarwedgÃ¥ÃºnÆ€adhá„®áµáµ§ownarrowÃ³á²ƒarpoonÄ€lráµ²áµ¶efÃ´á²´ighÃ´á²¶Å¢áµ¿á¶…karoÃ·à½‚É¯á¶Š\0\0á¶rn;æŒŸop;æŒŒÆ€cotá¶˜á¶£á¶¦Ä€ryá¶á¶¡;ì€€ğ’¹;ä‘•l;æ§¶rok;ä„‘Ä€drá¶°á¶´ot;æ‹±iÄ€;fá¶ºá –æ–¿Ä€ahá·€á·ƒrÃ²Ğ©aÃ²à¾¦angle;æ¦¦Ä€ciá·’á·•y;ä‘Ÿgrarr;æŸ¿à¤€Dacdefglmnopqrstuxá¸á¸‰á¸™á¸¸Õ¸á¸¼á¹‰á¹¡á¹¾áº¥áº¯áº½á»¡á¼ªá¼·á½„á½á½šÄ€Doá¸†á´´oÃ´á²‰Ä€csá¸á¸”uteè€»Ã©äƒ©ter;æ©®È€aioyá¸¢á¸§á¸±á¸¶ron;ä„›rÄ€;cá¸­á¸®æ‰–è€»Ãªäƒªlon;æ‰•;ä‘ot;ä„—Ä€Drá¹á¹…ot;æ‰’;ì€€ğ”¢Æ€;rsá¹á¹‘á¹—æªšaveè€»Ã¨äƒ¨Ä€;dá¹œá¹æª–ot;æª˜È€;ilsá¹ªá¹«á¹²á¹´æª™nters;æ§;æ„“Ä€;dá¹¹á¹ºæª•ot;æª—Æ€apsáº…áº‰áº—cr;ä„“tyÆ€;sváº’áº“áº•æˆ…etÂ»áº“pÄ€1;áºáº¤Ä³áº¡áº£;æ€„;æ€…æ€ƒÄ€gsáºªáº¬;ä…‹p;æ€‚Ä€gpáº´áº¸on;ä„™f;ì€€ğ•–Æ€alsá»„á»á»’rÄ€;sá»Šá»‹æ‹•l;æ§£us;æ©±iÆ€;lvá»šá»›á»ŸäµonÂ»á»›;äµÈ€csuvá»ªá»³á¼‹á¼£Ä€ioá»¯á¸±rcÂ»á¸®É©á»¹\0\0á»»Ã­ÕˆantÄ€glá¼‚á¼†trÂ»á¹essÂ»á¹ºÆ€aeiá¼’á¼–á¼šls;ä€½st;æ‰ŸvÄ€;DÈµá¼ D;æ©¸parsl;æ§¥Ä€Daá¼¯á¼³ot;æ‰“rr;æ¥±Æ€cdiá¼¾á½á»¸r;æ„¯oÃ´Í’Ä€ahá½‰á½‹;ä·è€»Ã°äƒ°Ä€mrá½“á½—lè€»Ã«äƒ«o;æ‚¬Æ€cipá½¡á½¤á½§l;ä€¡sÃ´Õ®Ä€eoá½¬á½´ctatioÃ®Õ™nentialÃ¥Õ¹à§¡á¾’\0á¾\0á¾¡á¾§\0\0á¿†á¿Œ\0á¿“\0á¿¦á¿ªâ€€\0â€ˆâšllingdotseÃ±á¹„y;ä‘„male;æ™€Æ€ilrá¾­á¾³á¿lig;è€€ï¬ƒÉ©á¾¹\0\0á¾½g;è€€ï¬€ig;è€€ï¬„;ì€€ğ”£lig;è€€ï¬lig;ì€€fjÆ€altá¿™á¿œá¿¡t;æ™­ig;è€€ï¬‚ns;æ–±of;ä†’Ç°á¿®\0á¿³f;ì€€ğ•—Ä€akÖ¿á¿·Ä€;vá¿¼á¿½æ‹”;æ«™artint;æ¨Ä€aoâ€Œâ•Ä€csâ€‘â’Î±â€šâ€°â€¸â…âˆ\0âÎ²â€¢â€¥â€§â€ªâ€¬\0â€®è€»Â½ä‚½;æ…“è€»Â¼ä‚¼;æ…•;æ…™;æ…›Æ³â€´\0â€¶;æ…”;æ…–Ê´â€¾â\0\0âƒè€»Â¾ä‚¾;æ…—;æ…œ5;æ…˜Æ¶âŒ\0â;æ…š;æ…8;æ…l;æ„wn;æŒ¢cr;ì€€ğ’»à¢€Eabcdefgijlnorstvâ‚‚â‚‰â‚Ÿâ‚¥â‚°â‚´âƒ°âƒµâƒºâƒ¿â„ƒâ„’â„¸Ì—â„¾â…’â†Ä€;lÙâ‚‡;æªŒÆ€cmpâ‚â‚•â‚ute;ä‡µmaÄ€;dâ‚œá³šä³;æª†reve;ä„ŸÄ€iyâ‚ªâ‚®rc;ä„;ä³ot;ä„¡È€;lqsØ¾Ù‚â‚½âƒ‰Æ€;qsØ¾ÙŒâƒ„lanÃ´Ù¥È€;cdlÙ¥âƒ’âƒ•âƒ¥c;æª©otÄ€;oâƒœâƒæª€Ä€;lâƒ¢âƒ£æª‚;æª„Ä€;eâƒªâƒ­ì€€â‹›ï¸€s;æª”r;ì€€ğ”¤Ä€;gÙ³Ø›mel;æ„·cy;ä‘“È€;EajÙšâ„Œâ„â„;æª’;æª¥;æª¤È€Eaesâ„›â„â„©â„´;æ‰©pÄ€;pâ„£â„¤æªŠroxÂ»â„¤Ä€;qâ„®â„¯æªˆÄ€;qâ„®â„›im;æ‹§pf;ì€€ğ•˜Ä€ciâ…ƒâ…†r;æ„ŠmÆ€;elÙ«â…â…;æª;æªèŒ€>;cdlqr×®â… â…ªâ…®â…³â…¹Ä€ciâ…¥â…§;æª§r;æ©ºot;æ‹—Par;æ¦•uest;æ©¼Ê€adelsâ†„â…ªâ†Ù–â†›Ç°â†‰\0â†proÃ¸â‚r;æ¥¸qÄ€lqØ¿â†–lesÃ³â‚ˆiÃ­Ù«Ä€enâ†£â†­rtneqq;ì€€â‰©ï¸€Ã…â†ªÔ€Aabcefkosyâ‡„â‡‡â‡±â‡µâ‡ºâˆ˜âˆâˆ¯â‰¨â‰½rÃ²Î È€ilmrâ‡â‡”â‡—â‡›rsÃ°á’„fÂ»â€¤ilÃ´Ú©Ä€drâ‡ â‡¤cy;ä‘ŠÆ€;cwà£´â‡«â‡¯ir;æ¥ˆ;æ†­ar;æ„irc;ä„¥Æ€alrâˆâˆâˆ“rtsÄ€;uâˆ‰âˆŠæ™¥itÂ»âˆŠlip;æ€¦con;æŠ¹r;ì€€ğ”¥sÄ€ewâˆ£âˆ©arow;æ¤¥arow;æ¤¦Ê€amoprâˆºâˆ¾â‰ƒâ‰â‰£rr;æ‡¿tht;æˆ»kÄ€lrâ‰‰â‰“eftarrow;æ†©ightarrow;æ†ªf;ì€€ğ•™bar;æ€•Æ€cltâ‰¯â‰´â‰¸r;ì€€ğ’½asÃ¨â‡´rok;ä„§Ä€bpâŠ‚âŠ‡ull;æƒhenÂ»á±›à«¡âŠ£\0âŠª\0âŠ¸â‹…â‹\0â‹•â‹³\0\0â‹¸âŒ¢â§â¢â¿\0â†âªâ´cuteè€»Ã­äƒ­Æ€;iyİ±âŠ°âŠµrcè€»Ã®äƒ®;ä¸Ä€cxâŠ¼âŠ¿y;äµclè€»Â¡ä‚¡Ä€frÎŸâ‹‰;ì€€ğ”¦raveè€»Ã¬äƒ¬È€;inoÜ¾â‹â‹©â‹®Ä€inâ‹¢â‹¦nt;æ¨Œt;æˆ­fin;æ§œta;æ„©lig;ä„³Æ€aopâ‹¾âŒšâŒÆ€cgtâŒ…âŒˆâŒ—r;ä„«Æ€elpÜŸâŒâŒ“inÃ¥ŞarÃ´Ü h;ä„±f;æŠ·ed;ä†µÊ€;cfotÓ´âŒ¬âŒ±âŒ½âare;æ„…inÄ€;tâŒ¸âŒ¹æˆie;æ§doÃ´âŒ™Ê€;celpİ—âŒââ›â¡al;æŠºÄ€grâ•â™erÃ³á•£Ã£âarhk;æ¨—rod;æ¨¼È€cgptâ¯â²â¶â»y;ä‘‘on;ä„¯f;ì€€ğ•ša;ä¹uestè€»Â¿ä‚¿Ä€ciâŠâr;ì€€ğ’¾nÊ€;EdsvÓ´â›ââ¡Ó³;æ‹¹ot;æ‹µÄ€;vâ¦â§æ‹´;æ‹³Ä€;iİ·â®lde;ä„©Ç«â¸\0â¼cy;ä‘–lè€»Ã¯äƒ¯Ì€cfmosuâŒâ—âœâ¡â§âµÄ€iyâ‘â•rc;ä„µ;ä¹r;ì€€ğ”§ath;äˆ·pf;ì€€ğ•›Ç£â¬\0â±r;ì€€ğ’¿rcy;ä‘˜kcy;ä‘”Ğ€acfghjosâ‹â–â¢â§â­â±âµâ»ppaÄ€;vâ“â”äº;ä°Ä€eyâ›â dil;ä„·;äºr;ì€€ğ”¨reen;ä„¸cy;ä‘…cy;ä‘œpf;ì€€ğ•œcr;ì€€ğ“€à®€ABEHabcdefghjlmnoprstuvâ‘°â’â’†â’â’‘â”â”½â•šâ–€â™â™â™¥â™¹â™½âššâš²â›˜ââ¨â‹âŸ€â â ’Æ€artâ‘·â‘ºâ‘¼rÃ²à§†Ã²Î•ail;æ¤›arr;æ¤Ä€;gà¦”â’‹;æª‹ar;æ¥¢à¥£â’¥\0â’ª\0â’±\0\0\0\0\0â’µâ’º\0â“†â“ˆâ“\0â“¹ute;ä„ºmptyv;æ¦´raÃ®à¡Œbda;ä»gÆ€;dlà¢â“â“ƒ;æ¦‘Ã¥à¢;æª…uoè€»Â«ä‚«rĞ€;bfhlpstà¢™â“â“¦â“©â“«â“®â“±â“µÄ€;fà¢â“£s;æ¤Ÿs;æ¤Ã«â‰’p;æ†«l;æ¤¹im;æ¥³l;æ†¢Æ€;aeâ“¿â”€â”„æª«il;æ¤™Ä€;sâ”‰â”Šæª­;ì€€âª­ï¸€Æ€abrâ”•â”™â”rr;æ¤Œrk;æ²Ä€akâ”¢â”¬cÄ€ekâ”¨â”ª;ä»;ä›Ä€esâ”±â”³;æ¦‹lÄ€duâ”¹â”»;æ¦;æ¦È€aeuyâ•†â•‹â•–â•˜ron;ä„¾Ä€diâ•â•”il;ä„¼Ã¬à¢°Ã¢â”©;ä»È€cqrsâ•£â•¦â•­â•½a;æ¤¶uoÄ€;rà¸™á†Ä€duâ•²â•·har;æ¥§shar;æ¥‹h;æ†²Ê€;fgqsâ–‹â–Œà¦‰â—³â—¿æ‰¤tÊ€ahlrtâ–˜â–¤â–·â—‚â—¨rrowÄ€;tà¢™â–¡aÃ©â“¶arpoonÄ€duâ–¯â–´ownÂ»ÑšpÂ»à¥¦eftarrows;æ‡‡ightÆ€ahsâ—â—–â—rrowÄ€;sà£´à¢§arpoonÃ³à¾˜quigarroÃ·â‡°hreetimes;æ‹‹Æ€;qsâ–‹à¦“â—ºlanÃ´à¦¬Ê€;cdgsà¦¬â˜Šâ˜â˜â˜¨c;æª¨otÄ€;oâ˜”â˜•æ©¿Ä€;râ˜šâ˜›æª;æªƒÄ€;eâ˜¢â˜¥ì€€â‹šï¸€s;æª“Ê€adegsâ˜³â˜¹â˜½â™‰â™‹pproÃ¸â“†ot;æ‹–qÄ€gqâ™ƒâ™…Ã´à¦‰gtÃ²â’ŒÃ´à¦›iÃ­à¦²Æ€ilrâ™•à£¡â™šsht;æ¥¼;ì€€ğ”©Ä€;Eà¦œâ™£;æª‘Å¡â™©â™¶rÄ€duâ–²â™®Ä€;là¥¥â™³;æ¥ªlk;æ–„cy;ä‘™Ê€;achtà©ˆâšˆâš‹âš‘âš–rÃ²â—orneÃ²á´ˆard;æ¥«ri;æ—ºÄ€ioâšŸâš¤dot;ä…€ustÄ€;aâš¬âš­æ°cheÂ»âš­È€Eaesâš»âš½â›‰â›”;æ‰¨pÄ€;pâ›ƒâ›„æª‰roxÂ»â›„Ä€;qâ›â›æª‡Ä€;qâ›âš»im;æ‹¦Ğ€abnoptwzâ›©â›´â›·âœšâœ¯ââ‡âÄ€nrâ›®â›±g;æŸ¬r;æ‡½rÃ«à£gÆ€lmrâ›¿âœâœ”eftÄ€arà§¦âœ‡ightÃ¡à§²apsto;æŸ¼ightÃ¡à§½parrowÄ€lrâœ¥âœ©efÃ´â“­ight;æ†¬Æ€aflâœ¶âœ¹âœ½r;æ¦…;ì€€ğ•us;æ¨­imes;æ¨´Å¡â‹âst;æˆ—Ã¡áÆ€;efâ—â˜á €æ—ŠngeÂ»â˜arÄ€;lâ¤â¥ä€¨t;æ¦“Ê€achmtâ³â¶â¼â…â‡rÃ²à¢¨orneÃ²á¶ŒarÄ€;dà¾˜âƒ;æ¥­;æ€ri;æŠ¿Ì€achiqtâ˜âà©€â¢â®â»quo;æ€¹r;ì€€ğ“mÆ€;egà¦²âªâ¬;æª;æªÄ€buâ”ªâ³oÄ€;rà¸Ÿâ¹;æ€šrok;ä…‚è€<;cdhilqrà «âŸ’â˜¹âŸœâŸ âŸ¥âŸªâŸ°Ä€ciâŸ—âŸ™;æª¦r;æ©¹reÃ¥â—²mes;æ‹‰arr;æ¥¶uest;æ©»Ä€PiâŸµâŸ¹ar;æ¦–Æ€;efâ €à¤­á ›æ—ƒrÄ€duâ ‡â shar;æ¥Šhar;æ¥¦Ä€enâ —â ¡rtneqq;ì€€â‰¨ï¸€Ã…â Ü€Dacdefhilnopsuâ¡€â¡…â¢‚â¢â¢“â¢ â¢¥â¢¨â£šâ£¢â£¤àªƒâ£³â¤‚Dot;æˆºÈ€clprâ¡â¡’â¡£â¡½rè€»Â¯ä‚¯Ä€etâ¡—â¡™;æ™‚Ä€;eâ¡â¡Ÿæœ seÂ»â¡ŸÄ€;sá€»â¡¨toÈ€;dluá€»â¡³â¡·â¡»owÃ®ÒŒefÃ´à¤Ã°á‘ker;æ–®Ä€oyâ¢‡â¢Œmma;æ¨©;ä¼ash;æ€”asuredangleÂ»á˜¦r;ì€€ğ”ªo;æ„§Æ€cdnâ¢¯â¢´â£‰roè€»Âµä‚µÈ€;acdá‘¤â¢½â£€â£„sÃ´áš§ir;æ«°otè‚»Â·ÆµusÆ€;bdâ£’á¤ƒâ£“æˆ’Ä€;uá´¼â£˜;æ¨ªÅ£â£â£¡p;æ«›Ã²âˆ’Ã°àªÄ€dpâ£©â£®els;æŠ§f;ì€€ğ•Ä€ctâ£¸â£½r;ì€€ğ“‚posÂ»á–Æ€;lmâ¤‰â¤Šâ¤ä¼timap;æŠ¸à°€GLRVabcdefghijlmoprstuvwâ¥‚â¥“â¥¾â¦‰â¦˜â§šâ§©â¨•â¨šâ©˜â©âªƒâª•âª¤âª¨â¬„â¬‡â­„â­¿â®®â°´â±§â±¼â³©Ä€gtâ¥‡â¥‹;ì€€â‹™Ì¸Ä€;vâ¥à¯ì€€â‰«âƒ’Æ€eltâ¥šâ¥²â¥¶ftÄ€arâ¥¡â¥§rrow;æ‡ightarrow;æ‡;ì€€â‹˜Ì¸Ä€;vâ¥»à±‡ì€€â‰ªâƒ’ightarrow;æ‡Ä€Ddâ¦â¦“ash;æŠ¯ash;æŠ®Ê€bcnptâ¦£â¦§â¦¬â¦±â§ŒlaÂ»Ëute;ä…„g;ì€€âˆ âƒ’Ê€;Eiopà¶„â¦¼â§€â§…â§ˆ;ì€€â©°Ì¸d;ì€€â‰‹Ì¸s;ä…‰roÃ¸à¶„urÄ€;aâ§“â§”æ™®lÄ€;sâ§“à¬¸Ç³â§Ÿ\0â§£pè‚»Â à¬·mpÄ€;eà¯¹à°€Ê€aeouyâ§´â§¾â¨ƒâ¨â¨“Ç°â§¹\0â§»;æ©ƒon;ä…ˆdil;ä…†ngÄ€;dàµ¾â¨Šot;ì€€â©­Ì¸p;æ©‚;ä½ash;æ€“Î€;Aadqsxà®’â¨©â¨­â¨»â©â©…â©rr;æ‡—rÄ€hrâ¨³â¨¶k;æ¤¤Ä€;oá²á°ot;ì€€â‰Ì¸uiÃ¶à­£Ä€eiâ©Šâ©ar;æ¤¨Ã­à®˜istÄ€;sà® à®Ÿr;ì€€ğ”«È€Eestà¯…â©¦â©¹â©¼Æ€;qsà®¼â©­à¯¡Æ€;qsà®¼à¯…â©´lanÃ´à¯¢iÃ­à¯ªÄ€;rà®¶âªÂ»à®·Æ€AapâªŠâªâª‘rÃ²â¥±rr;æ†®ar;æ«²Æ€;svà¾âªœà¾ŒÄ€;dâª¡âª¢æ‹¼;æ‹ºcy;ä‘šÎ€AEadestâª·âªºâª¾â«‚â«…â«¶â«¹rÃ²â¥¦;ì€€â‰¦Ì¸rr;æ†šr;æ€¥È€;fqsà°»â«â«£â«¯tÄ€arâ«”â«™rroÃ·â«ightarroÃ·âªÆ€;qsà°»âªºâ«ªlanÃ´à±•Ä€;sà±•â«´Â»à°¶iÃ­à±Ä€;rà°µâ«¾iÄ€;eà°šà°¥iÃ¤à¶Ä€ptâ¬Œâ¬‘f;ì€€ğ•Ÿè†€Â¬;inâ¬™â¬šâ¬¶ä‚¬nÈ€;Edvà®‰â¬¤â¬¨â¬®;ì€€â‹¹Ì¸ot;ì€€â‹µÌ¸Ç¡à®‰â¬³â¬µ;æ‹·;æ‹¶iÄ€;và²¸â¬¼Ç¡à²¸â­â­ƒ;æ‹¾;æ‹½Æ€aorâ­‹â­£â­©rÈ€;astà­»â­•â­šâ­ŸlleÃ¬à­»l;ì€€â«½âƒ¥;ì€€âˆ‚Ì¸lint;æ¨”Æ€;ceà²’â­°â­³uÃ¥à²¥Ä€;cà²˜â­¸Ä€;eà²’â­½Ã±à²˜È€Aaitâ®ˆâ®‹â®â®§rÃ²â¦ˆrrÆ€;cwâ®”â®•â®™æ†›;ì€€â¤³Ì¸;ì€€â†Ì¸ghtarrowÂ»â®•riÄ€;eà³‹à³–Î€chimpquâ®½â¯â¯™â¬„à­¸â¯¤â¯¯È€;cerà´²â¯†à´·â¯‰uÃ¥àµ…;ì€€ğ“ƒortÉ­â¬…\0\0â¯–arÃ¡â­–mÄ€;eàµ®â¯ŸÄ€;qàµ´àµ³suÄ€bpâ¯«â¯­Ã¥à³¸Ã¥à´‹Æ€bcpâ¯¶â°‘â°™È€;Eesâ¯¿â°€à´¢â°„æŠ„;ì€€â«…Ì¸etÄ€;eà´›â°‹qÄ€;qà´£â°€cÄ€;eà´²â°—Ã±à´¸È€;Eesâ°¢â°£àµŸâ°§æŠ…;ì€€â«†Ì¸etÄ€;eàµ˜â°®qÄ€;qàµ â°£È€gilrâ°½â°¿â±…â±‡Ã¬à¯—ldeè€»Ã±äƒ±Ã§à±ƒiangleÄ€lrâ±’â±œeftÄ€;eà°šâ±šÃ±à°¦ightÄ€;eà³‹â±¥Ã±à³—Ä€;mâ±¬â±­ä½Æ€;esâ±´â±µâ±¹ä€£ro;æ„–p;æ€‡Ò€DHadgilrsâ²â²”â²™â²â²£â²°â²¶â³“â³£ash;æŠ­arr;æ¤„p;ì€€â‰âƒ’ash;æŠ¬Ä€etâ²¨â²¬;ì€€â‰¥âƒ’;ì€€>âƒ’nfin;æ§Æ€Aetâ²½â³â³…rr;æ¤‚;ì€€â‰¤âƒ’Ä€;râ³Šâ³ì€€<âƒ’ie;ì€€âŠ´âƒ’Ä€Atâ³˜â³œrr;æ¤ƒrie;ì€€âŠµâƒ’im;ì€€âˆ¼âƒ’Æ€Aanâ³°â³´â´‚rr;æ‡–rÄ€hrâ³ºâ³½k;æ¤£Ä€;oá§á¥ear;æ¤§á‰“áª•\0\0\0\0\0\0\0\0\0\0\0\0\0â´­\0â´¸âµˆâµ âµ¥âµ²â¶„á¬‡\0\0â¶â¶«\0â·ˆâ·\0â·œâ¸™â¸«â¸¾â¹ƒÄ€csâ´±áª—uteè€»Ã³äƒ³Ä€iyâ´¼âµ…rÄ€;cáªâµ‚è€»Ã´äƒ´;ä¾Ê€abiosáª âµ’âµ—Çˆâµšlac;ä…‘v;æ¨¸old;æ¦¼lig;ä…“Ä€crâµ©âµ­ir;æ¦¿;ì€€ğ”¬Í¯âµ¹\0\0âµ¼\0â¶‚n;ä‹›aveè€»Ã²äƒ²;æ§Ä€bmâ¶ˆà·´ar;æ¦µÈ€acitâ¶•â¶˜â¶¥â¶¨rÃ²áª€Ä€irâ¶â¶ r;æ¦¾oss;æ¦»nÃ¥à¹’;æ§€Æ€aeiâ¶±â¶µâ¶¹cr;ä…ga;ä‰Æ€cdnâ·€â·…Çron;ä¿;æ¦¶pf;ì€€ğ• Æ€aelâ·”â·—Ç’r;æ¦·rp;æ¦¹Î€;adiosvâ·ªâ·«â·®â¸ˆâ¸â¸â¸–æˆ¨rÃ²áª†È€;efmâ··â·¸â¸‚â¸…æ©rÄ€;oâ·¾â·¿æ„´fÂ»â·¿è€»Âªä‚ªè€»Âºä‚ºgof;æŠ¶r;æ©–lope;æ©—;æ©›Æ€cloâ¸Ÿâ¸¡â¸§Ã²â¸ashè€»Ã¸äƒ¸l;æŠ˜iÅ¬â¸¯â¸´deè€»ÃµäƒµesÄ€;aÇ›â¸ºs;æ¨¶mlè€»Ã¶äƒ¶bar;æŒ½à«¡â¹\0â¹½\0âº€âº\0âº¢âº¹\0\0â»‹àºœ\0â¼“\0\0â¼«â¾¼\0â¿ˆrÈ€;astĞƒâ¹§â¹²àº…è„€Â¶;lâ¹­â¹®ä‚¶leÃ¬ĞƒÉ©â¹¸\0\0â¹»m;æ«³;æ«½y;ä¿rÊ€cimptâº‹âºâº“á¡¥âº—nt;ä€¥od;ä€®il;æ€°enk;æ€±r;ì€€ğ”­Æ€imoâº¨âº°âº´Ä€;vâº­âº®ä†;ä•maÃ´à©¶ne;æ˜Æ€;tvâº¿â»€â»ˆä€chforkÂ»á¿½;ä–Ä€auâ»â»ŸnÄ€ckâ»•â»kÄ€;hâ‡´â»›;æ„Ã¶â‡´sÒ€;abcdemstâ»³â»´á¤ˆâ»¹â»½â¼„â¼†â¼Šâ¼ä€«cir;æ¨£ir;æ¨¢Ä€ouáµ€â¼‚;æ¨¥;æ©²nè‚»Â±àºim;æ¨¦wo;æ¨§Æ€ipuâ¼™â¼ â¼¥ntint;æ¨•f;ì€€ğ•¡ndè€»Â£ä‚£Ô€;Eaceinosuà»ˆâ¼¿â½â½„â½‡â¾â¾‰â¾’â½¾â¾¶;æª³p;æª·uÃ¥à»™Ä€;cà»â½ŒÌ€;acensà»ˆâ½™â½Ÿâ½¦â½¨â½¾pproÃ¸â½ƒurlyeÃ±à»™Ã±à»Æ€aesâ½¯â½¶â½ºpprox;æª¹qq;æªµim;æ‹¨iÃ­à»ŸmeÄ€;sâ¾ˆàº®æ€²Æ€Easâ½¸â¾â½ºÃ°â½µÆ€dfpà»¬â¾™â¾¯Æ€alsâ¾ â¾¥â¾ªlar;æŒ®ine;æŒ’urf;æŒ“Ä€;tà»»â¾´Ã¯à»»rel;æŠ°Ä€ciâ¿€â¿…r;ì€€ğ“…;äˆncsp;æ€ˆÌ€fiopsuâ¿šâ‹¢â¿Ÿâ¿¥â¿«â¿±r;ì€€ğ”®pf;ì€€ğ•¢rime;æ—cr;ì€€ğ“†Æ€aeoâ¿¸ã€‰ã€“tÄ€eiâ¿¾ã€…rnionÃ³Ú°nt;æ¨–stÄ€;eã€ã€‘ä€¿Ã±á¼™Ã´à¼”àª€ABHabcdefhilmnoprstuxã€ã‘ã•ã™ãƒ ã„ã„«ã…‡ã…¢ã…²ã†ãˆ†ãˆ•ãˆ¤ãˆ©ã‰˜ã‰®ã‰²ãŠãŠ°ãŠ·Æ€artã‡ãŠãŒrÃ²á‚³Ã²Ïail;æ¤œarÃ²á±¥ar;æ¥¤Î€cdenqrtã¨ãµã¸ã¿ã‚ã‚”ãƒŒÄ€euã­ã±;ì€€âˆ½Ì±te;ä…•iÃ£á…®mptyv;æ¦³gÈ€;delà¿‘ã‚‰ã‚‹ã‚;æ¦’;æ¦¥Ã¥à¿‘uoè€»Â»ä‚»rÖ€;abcfhlpstwà¿œã‚¬ã‚¯ã‚·ã‚¹ã‚¼ã‚¾ãƒ€ãƒƒãƒ‡ãƒŠp;æ¥µÄ€;fà¿ ã‚´s;æ¤ ;æ¤³s;æ¤Ã«â‰Ã°âœ®l;æ¥…im;æ¥´l;æ†£;æ†Ä€aiãƒ‘ãƒ•il;æ¤šoÄ€;nãƒ›ãƒœæˆ¶alÃ³à¼Æ€abrãƒ§ãƒªãƒ®rÃ²áŸ¥rk;æ³Ä€akãƒ³ãƒ½cÄ€ekãƒ¹ãƒ»;ä½;äÄ€esã„‚ã„„;æ¦ŒlÄ€duã„Šã„Œ;æ¦;æ¦È€aeuyã„—ã„œã„§ã„©ron;ä…™Ä€diã„¡ã„¥il;ä…—Ã¬à¿²Ã¢ãƒº;ä‘€È€clqsã„´ã„·ã„½ã…„a;æ¤·dhar;æ¥©uoÄ€;rÈÈh;æ†³Æ€acgã…ã…Ÿà½„lÈ€;ipsà½¸ã…˜ã…›á‚œnÃ¥á‚»arÃ´à¾©t;æ–­Æ€ilrã…©á€£ã…®sht;æ¥½;ì€€ğ”¯Ä€aoã…·ã††rÄ€duã…½ã…¿Â»Ñ»Ä€;lá‚‘ã†„;æ¥¬Ä€;vã†‹ã†Œä;ä±Æ€gnsã†•ã‡¹ã‡¼htÌ€ahlrstã†¤ã†°ã‡‚ã‡˜ã‡¤ã‡®rrowÄ€;tà¿œã†­aÃ©ãƒˆarpoonÄ€duã†»ã†¿owÃ®ã…¾pÂ»á‚’eftÄ€ahã‡Šã‡rrowÃ³à¿ªarpoonÃ³Õ‘ightarrows;æ‡‰quigarroÃ·ãƒ‹hreetimes;æ‹Œg;ä‹šingdotseÃ±á¼²Æ€ahmãˆãˆãˆ“rÃ²à¿ªaÃ²Õ‘;æ€oustÄ€;aãˆãˆŸæ±cheÂ»ãˆŸmid;æ«®È€abptãˆ²ãˆ½ã‰€ã‰’Ä€nrãˆ·ãˆºg;æŸ­r;æ‡¾rÃ«á€ƒÆ€aflã‰‡ã‰Šã‰r;æ¦†;ì€€ğ•£us;æ¨®imes;æ¨µÄ€apã‰ã‰§rÄ€;gã‰£ã‰¤ä€©t;æ¦”olint;æ¨’arÃ²ã‡£È€achqã‰»ãŠ€á‚¼ãŠ…quo;æ€ºr;ì€€ğ“‡Ä€buãƒ»ãŠŠoÄ€;rÈ”È“Æ€hirãŠ—ãŠ›ãŠ reÃ¥ã‡¸mes;æ‹ŠiÈ€;eflãŠªá™á ¡ãŠ«æ–¹tri;æ§luhar;æ¥¨;æ„àµ¡ã‹•ã‹›ã‹ŸãŒ¬ãŒ¸ã±\0ãºã¤\0\0ã¬ã°\0ã¨ã‘ˆã‘šã’­ã’±ã“Šã“±\0ã˜–\0\0ã˜³cute;ä…›quÃ¯âºÔ€;Eaceinpsyá‡­ã‹³ã‹µã‹¿ãŒ‚ãŒ‹ãŒãŒŸãŒ¦ãŒ©;æª´Ç°ã‹º\0ã‹¼;æª¸on;ä…¡uÃ¥á‡¾Ä€;dá‡³ãŒ‡il;ä…Ÿrc;ä…Æ€EasãŒ–ãŒ˜ãŒ›;æª¶p;æªºim;æ‹©olint;æ¨“iÃ­áˆ„;ä‘otÆ€;beãŒ´áµ‡ãŒµæ‹…;æ©¦Î€Aacmstxã†ãŠã—ã›ãã£ã­rr;æ‡˜rÄ€hrãã’Ã«âˆ¨Ä€;oà¨¶à¨´tè€»Â§ä‚§i;ä€»war;æ¤©mÄ€inã©Ã°nuÃ³Ã±t;æœ¶rÄ€;oã¶â•ì€€ğ”°È€acoyã‚ã†ã‘ã rp;æ™¯Ä€hyã‹ãcy;ä‘‰;ä‘ˆrtÉ­ã™\0\0ãœiÃ¤á‘¤araÃ¬â¹¯è€»Â­ä‚­Ä€gmã¨ã´maÆ€;fvã±ã²ã²äƒ;ä‚Ğ€;deglnpráŠ«ã…ã‰ãã–ãã¡ã¦ot;æ©ªÄ€;qáŠ±áŠ°Ä€;Eã“ã”æª;æª Ä€;Eã›ãœæª;æªŸe;æ‰†lus;æ¨¤arr;æ¥²arÃ²á„½È€aeitã¸ãˆãã—Ä€lsã½ã„lsetmÃ©ãªhp;æ¨³parsl;æ§¤Ä€dlá‘£ã”e;æŒ£Ä€;eãœãæªªÄ€;sã¢ã£æª¬;ì€€âª¬ï¸€Æ€flpã®ã³ã‘‚tcy;ä‘ŒÄ€;bã¸ã¹ä€¯Ä€;aã¾ã¿æ§„r;æŒ¿f;ì€€ğ•¤aÄ€drã‘Ğ‚esÄ€;uã‘”ã‘•æ™ itÂ»ã‘•Æ€csuã‘ ã‘¹ã’ŸÄ€auã‘¥ã‘¯pÄ€;sá†ˆã‘«;ì€€âŠ“ï¸€pÄ€;sá†´ã‘µ;ì€€âŠ”ï¸€uÄ€bpã‘¿ã’Æ€;esá†—á†œã’†etÄ€;eá†—ã’Ã±á†Æ€;esá†¨á†­ã’–etÄ€;eá†¨ã’Ã±á†®Æ€;afá…»ã’¦Ö°rÅ¥ã’«Ö±Â»á…¼arÃ²á…ˆÈ€cemtã’¹ã’¾ã“‚ã“…r;ì€€ğ“ˆtmÃ®Ã±iÃ¬ã•arÃ¦á†¾Ä€arã“ã“•rÄ€;fã“”á¿æ˜†Ä€anã“šã“­ightÄ€epã“£ã“ªpsiloÃ®á» hÃ©âº¯sÂ»â¡’Ê€bcmnpã“»ã•áˆ‰ã–‹ã–Ò€;Edemnprsã”ã”ã”‘ã”•ã”ã”£ã”¬ã”±ã”¶æŠ‚;æ«…ot;æª½Ä€;dá‡šã”šot;æ«ƒult;æ«Ä€Eeã”¨ã”ª;æ«‹;æŠŠlus;æª¿arr;æ¥¹Æ€eiuã”½ã•’ã••tÆ€;enã”ã•…ã•‹qÄ€;qá‡šã”eqÄ€;qã”«ã”¨m;æ«‡Ä€bpã•šã•œ;æ«•;æ«“cÌ€;acensá‡­ã•¬ã•²ã•¹ã•»ãŒ¦pproÃ¸ã‹ºurlyeÃ±á‡¾Ã±á‡³Æ€aesã–‚ã–ˆãŒ›pproÃ¸ãŒšqÃ±ãŒ—g;æ™ªÚ€123;Edehlmnpsã–©ã–¬ã–¯áˆœã–²ã–´ã—€ã—‰ã—•ã—šã—Ÿã—¨ã—­è€»Â¹ä‚¹è€»Â²ä‚²è€»Â³ä‚³;æ«†Ä€osã–¹ã–¼t;æª¾ub;æ«˜Ä€;dáˆ¢ã—…ot;æ«„sÄ€ouã—ã—’l;æŸ‰b;æ«—arr;æ¥»ult;æ«‚Ä€Eeã—¤ã—¦;æ«Œ;æŠ‹lus;æ«€Æ€eiuã—´ã˜‰ã˜ŒtÆ€;enáˆœã—¼ã˜‚qÄ€;qáˆ¢ã–²eqÄ€;qã—§ã—¤m;æ«ˆÄ€bpã˜‘ã˜“;æ«”;æ«–Æ€Aanã˜œã˜ ã˜­rr;æ‡™rÄ€hrã˜¦ã˜¨Ã«âˆ®Ä€;oà¨«à¨©war;æ¤ªligè€»ÃŸäƒŸà¯¡ã™‘ã™ã™ á‹ã™³ã™¹\0ã™¾ã›‚\0\0\0\0\0ã››ãœƒ\0ãœ‰ã¬\0\0\0ã‡É²ã™–\0\0ã™›get;æŒ–;ä„rÃ«à¹ŸÆ€aeyã™¦ã™«ã™°ron;ä…¥dil;ä…£;ä‘‚lrec;æŒ•r;ì€€ğ”±È€eikoãš†ãšãšµãš¼Ç²ãš‹\0ãš‘eÄ€4fáŠ„áŠaÆ€;svãš˜ãš™ãš›ä¸ym;ä‘Ä€cnãš¢ãš²kÄ€asãš¨ãš®pproÃ¸á‹imÂ»áŠ¬sÃ°áŠÄ€asãšºãš®Ã°á‹rnè€»Ã¾äƒ¾Ç¬ÌŸã›†â‹§esè†€Ã—;bdã›ã›ã›˜äƒ—Ä€;aá¤ã›•r;æ¨±;æ¨°Æ€epsã›¡ã›£ãœ€Ã¡â©È€;bcfÒ†ã›¬ã›°ã›´ot;æŒ¶ir;æ«±Ä€;oã›¹ã›¼ì€€ğ•¥rk;æ«šÃ¡ã¢rime;æ€´Æ€aipãœãœ’ã¤dÃ¥á‰ˆÎ€adempstãœ¡ãã€ã‘ã—ãœãŸngleÊ€;dlqrãœ°ãœ±ãœ¶ã€ã‚æ–µownÂ»á¶»eftÄ€;eâ €ãœ¾Ã±à¤®;æ‰œightÄ€;eãŠªã‹Ã±ášot;æ—¬inus;æ¨ºlus;æ¨¹b;æ§ime;æ¨»ezium;æ¢Æ€chtã²ã½ãÄ€ryã·ã»;ì€€ğ“‰;ä‘†cy;ä‘›rok;ä…§Ä€ioã‹ãxÃ´á·headÄ€lrã—ã eftarroÃ·à¡ightarrowÂ»à½à¤€AHabcdfghlmoprstuwãŸãŸ“ãŸ—ãŸ¤ãŸ°ãŸ¼ã ã œã £ã ´ã¡‘ã¡ã¡«ã¢©ã£Œã£’ã£ªã£¶rÃ²Ï­ar;æ¥£Ä€crãŸœãŸ¢uteè€»ÃºäƒºÃ²á…rÇ£ãŸª\0ãŸ­y;ä‘ve;ä…­Ä€iyãŸµãŸºrcè€»Ã»äƒ»;ä‘ƒÆ€abhã ƒã †ã ‹rÃ²á­lac;ä…±aÃ²áƒÄ€irã “ã ˜sht;æ¥¾;ì€€ğ”²raveè€»Ã¹äƒ¹Å¡ã §ã ±rÄ€lrã ¬ã ®Â»à¥—Â»á‚ƒlk;æ–€Ä€ctã ¹ã¡É¯ã ¿\0\0ã¡ŠrnÄ€;eã¡…ã¡†æŒœrÂ»ã¡†op;æŒri;æ—¸Ä€alã¡–ã¡šcr;ä…«è‚»Â¨Í‰Ä€gpã¡¢ã¡¦on;ä…³f;ì€€ğ•¦Ì€adhlsuá…‹ã¡¸ã¡½á²ã¢‘ã¢ ownÃ¡á³arpoonÄ€lrã¢ˆã¢ŒefÃ´ã ­ighÃ´ã ¯iÆ€;hlã¢™ã¢šã¢œä…Â»áºonÂ»ã¢šparrows;æ‡ˆÆ€citã¢°ã£„ã£ˆÉ¯ã¢¶\0\0ã£rnÄ€;eã¢¼ã¢½æŒrÂ»ã¢½op;æŒng;ä…¯ri;æ—¹cr;ì€€ğ“ŠÆ€dirã£™ã£ã£¢ot;æ‹°lde;ä…©iÄ€;fãœ°ã£¨Â»á “Ä€amã£¯ã£²rÃ²ã¢¨lè€»Ã¼äƒ¼angle;æ¦§Ş€ABDacdeflnoprszã¤œã¤Ÿã¤©ã¤­ã¦µã¦¸ã¦½ã§Ÿã§¤ã§¨ã§³ã§¹ã§½ã¨ã¨ rÃ²Ï·arÄ€;vã¤¦ã¤§æ«¨;æ«©asÃ¨Ï¡Ä€nrã¤²ã¤·grt;æ¦œÎ€eknprstã“£ã¥†ã¥‹ã¥’ã¥ã¥¤ã¦–appÃ¡â•othinÃ§áº–Æ€hirã“«â»ˆã¥™opÃ´â¾µÄ€;há·ã¥¢Ã¯ã†Ä€iuã¥©ã¥­gmÃ¡ã³Ä€bpã¥²ã¦„setneqÄ€;qã¥½ã¦€ì€€âŠŠï¸€;ì€€â«‹ï¸€setneqÄ€;qã¦ã¦’ì€€âŠ‹ï¸€;ì€€â«Œï¸€Ä€hrã¦›ã¦ŸetÃ¡ãšœiangleÄ€lrã¦ªã¦¯eftÂ»à¤¥ightÂ»á‘y;ä²ashÂ»á€¶Æ€elrã§„ã§’ã§—Æ€;beâ·ªã§‹ã§ar;æŠ»q;æ‰šlip;æ‹®Ä€btã§œá‘¨aÃ²á‘©r;ì€€ğ”³trÃ©ã¦®suÄ€bpã§¯ã§±Â»à´œÂ»àµ™pf;ì€€ğ•§roÃ°à»»trÃ©ã¦´Ä€cuã¨†ã¨‹r;ì€€ğ“‹Ä€bpã¨ã¨˜nÄ€Eeã¦€ã¨–Â»ã¥¾nÄ€Eeã¦’ã¨Â»ã¦igzag;æ¦šÎ€cefoprsã¨¶ã¨»ã©–ã©›ã©”ã©¡ã©ªirc;ä…µÄ€diã©€ã©‘Ä€bgã©…ã©‰ar;æ©ŸeÄ€;qá—ºã©;æ‰™erp;æ„˜r;ì€€ğ”´pf;ì€€ğ•¨Ä€;eá‘¹ã©¦atÃ¨á‘¹cr;ì€€ğ“Œà«£áãª‡\0ãª‹\0ãªãª›\0\0ãªãª¨ãª«ãª¯\0\0ã«ƒã«\0ã«˜áŸœáŸŸtrÃ©áŸ‘r;ì€€ğ”µÄ€Aaãª”ãª—rÃ²ÏƒrÃ²à§¶;ä¾Ä€Aaãª¡ãª¤rÃ²Î¸rÃ²à§«aÃ°âœ“is;æ‹»Æ€dptá¤ãªµãª¾Ä€flãªºá©;ì€€ğ•©imÃ¥á²Ä€Aaã«‡ã«ŠrÃ²ÏrÃ²à¨Ä€cqã«’á¸r;ì€€ğ“Ä€ptáŸ–ã«œrÃ©áŸ”Ğ€acefiosuã«°ã«½ã¬ˆã¬Œã¬‘ã¬•ã¬›ã¬¡cÄ€uyã«¶ã«»teè€»Ã½äƒ½;ä‘Ä€iyã¬‚ã¬†rc;ä…·;ä‘‹nè€»Â¥ä‚¥r;ì€€ğ”¶cy;ä‘—pf;ì€€ğ•ªcr;ì€€ğ“Ä€cmã¬¦ã¬©y;ä‘lè€»Ã¿äƒ¿Ô€acdefhioswã­‚ã­ˆã­”ã­˜ã­¤ã­©ã­­ã­´ã­ºã®€cute;ä…ºÄ€ayã­ã­’ron;ä…¾;ä·ot;ä…¼Ä€etã­ã­¡trÃ¦á•Ÿa;ä¶r;ì€€ğ”·cy;ä¶grarr;æ‡pf;ì€€ğ•«cr;ì€€ğ“Ä€jnã®…ã®‡;æ€j;æ€Œ'.split("").map((e10) => e10.charCodeAt(0))
);
var o1 = new Uint16Array(
  // prettier-ignore
  "È€aglq	\x1BÉ­\0\0p;ä€¦os;ä€§t;ä€¾t;ä€¼uot;ä€¢".split("").map((e10) => e10.charCodeAt(0))
);
var Wu;
var S4 = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var Oo = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (Wu = String.fromCodePoint) !== null && Wu !== void 0 ? Wu : function(e10) {
    let t = "";
    return e10 > 65535 && (e10 -= 65536, t += String.fromCharCode(e10 >>> 10 & 1023 | 55296), e10 = 56320 | e10 & 1023), t += String.fromCharCode(e10), t;
  }
);
function A4(e10) {
  var t;
  return e10 >= 55296 && e10 <= 57343 || e10 > 1114111 ? 65533 : (t = S4.get(e10)) !== null && t !== void 0 ? t : e10;
}
var bt;
(function(e10) {
  e10[e10.NUM = 35] = "NUM", e10[e10.SEMI = 59] = "SEMI", e10[e10.EQUALS = 61] = "EQUALS", e10[e10.ZERO = 48] = "ZERO", e10[e10.NINE = 57] = "NINE", e10[e10.LOWER_A = 97] = "LOWER_A", e10[e10.LOWER_F = 102] = "LOWER_F", e10[e10.LOWER_X = 120] = "LOWER_X", e10[e10.LOWER_Z = 122] = "LOWER_Z", e10[e10.UPPER_A = 65] = "UPPER_A", e10[e10.UPPER_F = 70] = "UPPER_F", e10[e10.UPPER_Z = 90] = "UPPER_Z";
})(bt || (bt = {}));
var E4 = 32;
var Zn;
(function(e10) {
  e10[e10.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e10[e10.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e10[e10.JUMP_TABLE = 127] = "JUMP_TABLE";
})(Zn || (Zn = {}));
function zo(e10) {
  return e10 >= bt.ZERO && e10 <= bt.NINE;
}
function C4(e10) {
  return e10 >= bt.UPPER_A && e10 <= bt.UPPER_F || e10 >= bt.LOWER_A && e10 <= bt.LOWER_F;
}
function T4(e10) {
  return e10 >= bt.UPPER_A && e10 <= bt.UPPER_Z || e10 >= bt.LOWER_A && e10 <= bt.LOWER_Z || zo(e10);
}
function D4(e10) {
  return e10 === bt.EQUALS || T4(e10);
}
var pt;
(function(e10) {
  e10[e10.EntityStart = 0] = "EntityStart", e10[e10.NumericStart = 1] = "NumericStart", e10[e10.NumericDecimal = 2] = "NumericDecimal", e10[e10.NumericHex = 3] = "NumericHex", e10[e10.NamedEntity = 4] = "NamedEntity";
})(pt || (pt = {}));
var cn;
(function(e10) {
  e10[e10.Legacy = 0] = "Legacy", e10[e10.Strict = 1] = "Strict", e10[e10.Attribute = 2] = "Attribute";
})(cn || (cn = {}));
var a1 = class {
  constructor(t, n, r) {
    this.decodeTree = t, this.emitCodePoint = n, this.errors = r, this.state = pt.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = cn.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(t) {
    this.decodeMode = t, this.state = pt.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(t, n) {
    switch (this.state) {
      case pt.EntityStart:
        return t.charCodeAt(n) === bt.NUM ? (this.state = pt.NumericStart, this.consumed += 1, this.stateNumericStart(t, n + 1)) : (this.state = pt.NamedEntity, this.stateNamedEntity(t, n));
      case pt.NumericStart:
        return this.stateNumericStart(t, n);
      case pt.NumericDecimal:
        return this.stateNumericDecimal(t, n);
      case pt.NumericHex:
        return this.stateNumericHex(t, n);
      case pt.NamedEntity:
        return this.stateNamedEntity(t, n);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(t, n) {
    return n >= t.length ? -1 : (t.charCodeAt(n) | E4) === bt.LOWER_X ? (this.state = pt.NumericHex, this.consumed += 1, this.stateNumericHex(t, n + 1)) : (this.state = pt.NumericDecimal, this.stateNumericDecimal(t, n));
  }
  addToNumericResult(t, n, r, i) {
    if (n !== r) {
      const s = r - n;
      this.result = this.result * Math.pow(i, s) + parseInt(t.substr(n, s), i), this.consumed += s;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const i = t.charCodeAt(n);
      if (zo(i) || C4(i))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 16), this.emitNumericEntity(i, 3);
    }
    return this.addToNumericResult(t, r, n, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const i = t.charCodeAt(n);
      if (zo(i))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 10), this.emitNumericEntity(i, 2);
    }
    return this.addToNumericResult(t, r, n, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(t, n) {
    var r;
    if (this.consumed <= n)
      return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (t === bt.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === cn.Strict)
      return 0;
    return this.emitCodePoint(A4(this.result), this.consumed), this.errors && (t !== bt.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(t, n) {
    const { decodeTree: r } = this;
    let i = r[this.treeIndex], s = (i & Zn.VALUE_LENGTH) >> 14;
    for (; n < t.length; n++, this.excess++) {
      const o = t.charCodeAt(n);
      if (this.treeIndex = M4(r, i, this.treeIndex + Math.max(1, s), o), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === cn.Attribute && // We shouldn't have consumed any characters after the entity,
        (s === 0 || // And there should be no invalid characters.
        D4(o)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (i = r[this.treeIndex], s = (i & Zn.VALUE_LENGTH) >> 14, s !== 0) {
        if (o === bt.SEMI)
          return this.emitNamedEntityData(this.treeIndex, s, this.consumed + this.excess);
        this.decodeMode !== cn.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var t;
    const { result: n, decodeTree: r } = this, i = (r[n] & Zn.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(n, i, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(t, n, r) {
    const { decodeTree: i } = this;
    return this.emitCodePoint(n === 1 ? i[t] & ~Zn.VALUE_LENGTH : i[t + 1], r), n === 3 && this.emitCodePoint(i[t + 2], r), r;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var t;
    switch (this.state) {
      case pt.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== cn.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case pt.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case pt.NumericHex:
        return this.emitNumericEntity(0, 3);
      case pt.NumericStart:
        return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case pt.EntityStart:
        return 0;
    }
  }
};
function l1(e10) {
  let t = "";
  const n = new a1(e10, (r) => t += Oo(r));
  return function(i, s) {
    let o = 0, l = 0;
    for (; (l = i.indexOf("&", l)) >= 0; ) {
      t += i.slice(o, l), n.startEntity(s);
      const h2 = n.write(
        i,
        // Skip the "&"
        l + 1
      );
      if (h2 < 0) {
        o = l + n.end();
        break;
      }
      o = l + h2, l = h2 === 0 ? o + 1 : o;
    }
    const f = t + i.slice(o);
    return t = "", f;
  };
}
function M4(e10, t, n, r) {
  const i = (t & Zn.BRANCH_LENGTH) >> 7, s = t & Zn.JUMP_TABLE;
  if (i === 0)
    return s !== 0 && r === s ? n : -1;
  if (s) {
    const f = r - s;
    return f < 0 || f >= i ? -1 : e10[n + f] - 1;
  }
  let o = n, l = o + i - 1;
  for (; o <= l; ) {
    const f = o + l >>> 1, h2 = e10[f];
    if (h2 < r)
      o = f + 1;
    else if (h2 > r)
      l = f - 1;
    else
      return e10[f + i];
  }
  return -1;
}
l1(u1);
l1(o1);
var nf = /["&'<>$\x80-\uFFFF]/g;
var N4 = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var I4 = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (e10, t) => e10.codePointAt(t) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (e10, t) => (e10.charCodeAt(t) & 64512) === 55296 ? (e10.charCodeAt(t) - 55296) * 1024 + e10.charCodeAt(t + 1) - 56320 + 65536 : e10.charCodeAt(t)
  )
);
function c1(e10) {
  let t = "", n = 0, r;
  for (; (r = nf.exec(e10)) !== null; ) {
    const i = r.index, s = e10.charCodeAt(i), o = N4.get(s);
    o !== void 0 ? (t += e10.substring(n, i) + o, n = i + 1) : (t += `${e10.substring(n, i)}&#x${I4(e10, i).toString(16)};`, n = nf.lastIndex += +((s & 64512) === 55296));
  }
  return t + e10.substr(n);
}
function f1(e10, t) {
  return function(r) {
    let i, s = 0, o = "";
    for (; i = e10.exec(r); )
      s !== i.index && (o += r.substring(s, i.index)), o += t.get(i[0].charCodeAt(0)), s = i.index + 1;
    return o + r.substring(s);
  };
}
var F4 = f1(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var B4 = f1(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));
var O4 = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((e10) => [e10.toLowerCase(), e10]));
var z4 = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((e10) => [e10.toLowerCase(), e10]));
var $4 = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function L4(e10) {
  return e10.replace(/"/g, "&quot;");
}
function q4(e10, t) {
  var n;
  if (!e10)
    return;
  const r = ((n = t.encodeEntities) !== null && n !== void 0 ? n : t.decodeEntities) === false ? L4 : t.xmlMode || t.encodeEntities !== "utf8" ? c1 : F4;
  return Object.keys(e10).map((i) => {
    var s, o;
    const l = (s = e10[i]) !== null && s !== void 0 ? s : "";
    return t.xmlMode === "foreign" && (i = (o = z4.get(i)) !== null && o !== void 0 ? o : i), !t.emptyAttrs && !t.xmlMode && l === "" ? i : `${i}="${r(l)}"`;
  }).join(" ");
}
var rf = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function B0(e10, t = {}) {
  const n = "length" in e10 ? e10 : [e10];
  let r = "";
  for (let i = 0; i < n.length; i++)
    r += R4(n[i], t);
  return r;
}
function R4(e10, t) {
  switch (e10.type) {
    case d4:
      return B0(e10.children, t);
    case v4:
    case m4:
      return U4(e10);
    case g4:
      return W4(e10);
    case w4:
      return G4(e10);
    case b4:
    case y4:
    case x4:
      return j4(e10, t);
    case p4:
      return V4(e10, t);
  }
}
var P4 = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var H4 = /* @__PURE__ */ new Set(["svg", "math"]);
function j4(e10, t) {
  var n;
  t.xmlMode === "foreign" && (e10.name = (n = O4.get(e10.name)) !== null && n !== void 0 ? n : e10.name, e10.parent && P4.has(e10.parent.name) && (t = { ...t, xmlMode: false })), !t.xmlMode && H4.has(e10.name) && (t = { ...t, xmlMode: "foreign" });
  let r = `<${e10.name}`;
  const i = q4(e10.attribs, t);
  return i && (r += ` ${i}`), e10.children.length === 0 && (t.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    t.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    t.selfClosingTags && rf.has(e10.name)
  )) ? (t.xmlMode || (r += " "), r += "/>") : (r += ">", e10.children.length > 0 && (r += B0(e10.children, t)), (t.xmlMode || !rf.has(e10.name)) && (r += `</${e10.name}>`)), r;
}
function U4(e10) {
  return `<${e10.data}>`;
}
function V4(e10, t) {
  var n;
  let r = e10.data || "";
  return ((n = t.encodeEntities) !== null && n !== void 0 ? n : t.decodeEntities) !== false && !(!t.xmlMode && e10.parent && $4.has(e10.parent.name)) && (r = t.xmlMode || t.encodeEntities !== "utf8" ? c1(r) : B4(r)), r;
}
function G4(e10) {
  return `<![CDATA[${e10.children[0].data}]]>`;
}
function W4(e10) {
  return `<!--${e10.data}-->`;
}
function h1(e10, t) {
  return B0(e10, t);
}
function K4(e10, t) {
  return xt(e10) ? e10.children.map((n) => h1(n, t)).join("") : "";
}
function Ys(e10) {
  return Array.isArray(e10) ? e10.map(Ys).join("") : ke(e10) ? e10.name === "br" ? `
` : Ys(e10.children) : F0(e10) ? Ys(e10.children) : yr(e10) ? e10.data : "";
}
function Kr(e10) {
  return Array.isArray(e10) ? e10.map(Kr).join("") : xt(e10) && !ka(e10) ? Kr(e10.children) : yr(e10) ? e10.data : "";
}
function f0(e10) {
  return Array.isArray(e10) ? e10.map(f0).join("") : xt(e10) && (e10.type === $e.Tag || F0(e10)) ? f0(e10.children) : yr(e10) ? e10.data : "";
}
function O0(e10) {
  return xt(e10) ? e10.children : [];
}
function d1(e10) {
  return e10.parent || null;
}
function p1(e10) {
  const t = d1(e10);
  if (t != null)
    return O0(t);
  const n = [e10];
  let { prev: r, next: i } = e10;
  for (; r != null; )
    n.unshift(r), { prev: r } = r;
  for (; i != null; )
    n.push(i), { next: i } = i;
  return n;
}
function X4(e10, t) {
  var n;
  return (n = e10.attribs) === null || n === void 0 ? void 0 : n[t];
}
function Y4(e10, t) {
  return e10.attribs != null && Object.prototype.hasOwnProperty.call(e10.attribs, t) && e10.attribs[t] != null;
}
function Z4(e10) {
  return e10.name;
}
function _a(e10) {
  let { next: t } = e10;
  for (; t !== null && !ke(t); )
    ({ next: t } = t);
  return t;
}
function Sa(e10) {
  let { prev: t } = e10;
  for (; t !== null && !ke(t); )
    ({ prev: t } = t);
  return t;
}
function Sr(e10) {
  if (e10.prev && (e10.prev.next = e10.next), e10.next && (e10.next.prev = e10.prev), e10.parent) {
    const t = e10.parent.children, n = t.lastIndexOf(e10);
    n >= 0 && t.splice(n, 1);
  }
  e10.next = null, e10.prev = null, e10.parent = null;
}
function J4(e10, t) {
  const n = t.prev = e10.prev;
  n && (n.next = t);
  const r = t.next = e10.next;
  r && (r.prev = t);
  const i = t.parent = e10.parent;
  if (i) {
    const s = i.children;
    s[s.lastIndexOf(e10)] = t, e10.parent = null;
  }
}
function Q4(e10, t) {
  if (Sr(t), t.next = null, t.parent = e10, e10.children.push(t) > 1) {
    const n = e10.children[e10.children.length - 2];
    n.next = t, t.prev = n;
  } else
    t.prev = null;
}
function e3(e10, t) {
  Sr(t);
  const { parent: n } = e10, r = e10.next;
  if (t.next = r, t.prev = e10, e10.next = t, t.parent = n, r) {
    if (r.prev = t, n) {
      const i = n.children;
      i.splice(i.lastIndexOf(r), 0, t);
    }
  } else n && n.children.push(t);
}
function t3(e10, t) {
  if (Sr(t), t.parent = e10, t.prev = null, e10.children.unshift(t) !== 1) {
    const n = e10.children[1];
    n.prev = t, t.next = n;
  } else
    t.next = null;
}
function n3(e10, t) {
  Sr(t);
  const { parent: n } = e10;
  if (n) {
    const r = n.children;
    r.splice(r.indexOf(e10), 0, t);
  }
  e10.prev && (e10.prev.next = t), t.parent = n, t.prev = e10.prev, t.next = e10, e10.prev = t;
}
function z0(e10, t, n = true, r = 1 / 0) {
  return Aa(e10, Array.isArray(t) ? t : [t], n, r);
}
function Aa(e10, t, n, r) {
  const i = [], s = [t], o = [0];
  for (; ; ) {
    if (o[0] >= s[0].length) {
      if (o.length === 1)
        return i;
      s.shift(), o.shift();
      continue;
    }
    const l = s[0][o[0]++];
    if (e10(l) && (i.push(l), --r <= 0))
      return i;
    n && xt(l) && l.children.length > 0 && (o.unshift(0), s.unshift(l.children));
  }
}
function r3(e10, t) {
  return t.find(e10);
}
function Ea(e10, t, n = true) {
  let r = null;
  for (let i = 0; i < t.length && !r; i++) {
    const s = t[i];
    if (ke(s))
      e10(s) ? r = s : n && s.children.length > 0 && (r = Ea(e10, s.children, true));
    else continue;
  }
  return r;
}
function m1(e10, t) {
  return t.some((n) => ke(n) && (e10(n) || m1(e10, n.children)));
}
function i3(e10, t) {
  const n = [], r = [t], i = [0];
  for (; ; ) {
    if (i[0] >= r[0].length) {
      if (r.length === 1)
        return n;
      r.shift(), i.shift();
      continue;
    }
    const s = r[0][i[0]++];
    ke(s) && (e10(s) && n.push(s), s.children.length > 0 && (i.unshift(0), r.unshift(s.children)));
  }
}
var h0 = {
  tag_name(e10) {
    return typeof e10 == "function" ? (t) => ke(t) && e10(t.name) : e10 === "*" ? ke : (t) => ke(t) && t.name === e10;
  },
  tag_type(e10) {
    return typeof e10 == "function" ? (t) => e10(t.type) : (t) => t.type === e10;
  },
  tag_contains(e10) {
    return typeof e10 == "function" ? (t) => yr(t) && e10(t.data) : (t) => yr(t) && t.data === e10;
  }
};
function g1(e10, t) {
  return typeof t == "function" ? (n) => ke(n) && t(n.attribs[e10]) : (n) => ke(n) && n.attribs[e10] === t;
}
function s3(e10, t) {
  return (n) => e10(n) || t(n);
}
function b1(e10) {
  const t = Object.keys(e10).map((n) => {
    const r = e10[n];
    return Object.prototype.hasOwnProperty.call(h0, n) ? h0[n](r) : g1(n, r);
  });
  return t.length === 0 ? null : t.reduce(s3);
}
function u3(e10, t) {
  const n = b1(e10);
  return n ? n(t) : true;
}
function o3(e10, t, n, r = 1 / 0) {
  const i = b1(e10);
  return i ? z0(i, t, n, r) : [];
}
function a3(e10, t, n = true) {
  return Array.isArray(t) || (t = [t]), Ea(g1("id", e10), t, n);
}
function ri(e10, t, n = true, r = 1 / 0) {
  return z0(h0.tag_name(e10), t, n, r);
}
function l3(e10, t, n = true, r = 1 / 0) {
  return z0(h0.tag_type(e10), t, n, r);
}
function c3(e10) {
  let t = e10.length;
  for (; --t >= 0; ) {
    const n = e10[t];
    if (t > 0 && e10.lastIndexOf(n, t - 1) >= 0) {
      e10.splice(t, 1);
      continue;
    }
    for (let r = n.parent; r; r = r.parent)
      if (e10.includes(r)) {
        e10.splice(t, 1);
        break;
      }
  }
  return e10;
}
var Vt;
(function(e10) {
  e10[e10.DISCONNECTED = 1] = "DISCONNECTED", e10[e10.PRECEDING = 2] = "PRECEDING", e10[e10.FOLLOWING = 4] = "FOLLOWING", e10[e10.CONTAINS = 8] = "CONTAINS", e10[e10.CONTAINED_BY = 16] = "CONTAINED_BY";
})(Vt || (Vt = {}));
function y1(e10, t) {
  const n = [], r = [];
  if (e10 === t)
    return 0;
  let i = xt(e10) ? e10 : e10.parent;
  for (; i; )
    n.unshift(i), i = i.parent;
  for (i = xt(t) ? t : t.parent; i; )
    r.unshift(i), i = i.parent;
  const s = Math.min(n.length, r.length);
  let o = 0;
  for (; o < s && n[o] === r[o]; )
    o++;
  if (o === 0)
    return Vt.DISCONNECTED;
  const l = n[o - 1], f = l.children, h2 = n[o], p = r[o];
  return f.indexOf(h2) > f.indexOf(p) ? l === t ? Vt.FOLLOWING | Vt.CONTAINED_BY : Vt.FOLLOWING : l === e10 ? Vt.PRECEDING | Vt.CONTAINS : Vt.PRECEDING;
}
function ii(e10) {
  return e10 = e10.filter((t, n, r) => !r.includes(t, n + 1)), e10.sort((t, n) => {
    const r = y1(t, n);
    return r & Vt.PRECEDING ? -1 : r & Vt.FOLLOWING ? 1 : 0;
  }), e10;
}
function f3(e10) {
  const t = d0(g3, e10);
  return t ? t.name === "feed" ? h3(t) : d3(t) : null;
}
function h3(e10) {
  var t;
  const n = e10.children, r = {
    type: "atom",
    items: ri("entry", n).map((o) => {
      var l;
      const { children: f } = o, h2 = { media: x1(f) };
      Mt(h2, "id", "id", f), Mt(h2, "title", "title", f);
      const p = (l = d0("link", f)) === null || l === void 0 ? void 0 : l.attribs.href;
      p && (h2.link = p);
      const b = Jn("summary", f) || Jn("content", f);
      b && (h2.description = b);
      const v = Jn("updated", f);
      return v && (h2.pubDate = new Date(v)), h2;
    })
  };
  Mt(r, "id", "id", n), Mt(r, "title", "title", n);
  const i = (t = d0("link", n)) === null || t === void 0 ? void 0 : t.attribs.href;
  i && (r.link = i), Mt(r, "description", "subtitle", n);
  const s = Jn("updated", n);
  return s && (r.updated = new Date(s)), Mt(r, "author", "email", n, true), r;
}
function d3(e10) {
  var t, n;
  const r = (n = (t = d0("channel", e10.children)) === null || t === void 0 ? void 0 : t.children) !== null && n !== void 0 ? n : [], i = {
    type: e10.name.substr(0, 3),
    id: "",
    items: ri("item", e10.children).map((o) => {
      const { children: l } = o, f = { media: x1(l) };
      Mt(f, "id", "guid", l), Mt(f, "title", "title", l), Mt(f, "link", "link", l), Mt(f, "description", "description", l);
      const h2 = Jn("pubDate", l) || Jn("dc:date", l);
      return h2 && (f.pubDate = new Date(h2)), f;
    })
  };
  Mt(i, "title", "title", r), Mt(i, "link", "link", r), Mt(i, "description", "description", r);
  const s = Jn("lastBuildDate", r);
  return s && (i.updated = new Date(s)), Mt(i, "author", "managingEditor", r, true), i;
}
var p3 = ["url", "type", "lang"];
var m3 = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function x1(e10) {
  return ri("media:content", e10).map((t) => {
    const { attribs: n } = t, r = {
      medium: n.medium,
      isDefault: !!n.isDefault
    };
    for (const i of p3)
      n[i] && (r[i] = n[i]);
    for (const i of m3)
      n[i] && (r[i] = parseInt(n[i], 10));
    return n.expression && (r.expression = n.expression), r;
  });
}
function d0(e10, t) {
  return ri(e10, t, true, 1)[0];
}
function Jn(e10, t, n = false) {
  return Kr(ri(e10, t, n, 1)).trim();
}
function Mt(e10, t, n, r, i = false) {
  const s = Jn(n, r, i);
  s && (e10[t] = s);
}
function g3(e10) {
  return e10 === "rss" || e10 === "feed" || e10 === "rdf:RDF";
}
var $0 = Object.freeze(Object.defineProperty({
  __proto__: null,
  get DocumentPosition() {
    return Vt;
  },
  append: e3,
  appendChild: Q4,
  compareDocumentPosition: y1,
  existsOne: m1,
  filter: z0,
  find: Aa,
  findAll: i3,
  findOne: Ea,
  findOneChild: r3,
  getAttributeValue: X4,
  getChildren: O0,
  getElementById: a3,
  getElements: o3,
  getElementsByTagName: ri,
  getElementsByTagType: l3,
  getFeed: f3,
  getInnerHTML: K4,
  getName: Z4,
  getOuterHTML: h1,
  getParent: d1,
  getSiblings: p1,
  getText: Ys,
  hasAttrib: Y4,
  hasChildren: xt,
  innerText: f0,
  isCDATA: F0,
  isComment: ka,
  isDocument: _r,
  isTag: ke,
  isText: yr,
  nextElementSibling: _a,
  prepend: n3,
  prependChild: t3,
  prevElementSibling: Sa,
  removeElement: Sr,
  removeSubsets: c3,
  replaceElement: J4,
  testElement: u3,
  textContent: Kr,
  uniqueSort: ii
}, Symbol.toStringTag, { value: "Module" }));
function w1(e10, t, n) {
  return e10 ? e10(t ?? e10._root.children, null, void 0, n).toString() : "";
}
function b3(e10, t) {
  return typeof e10 == "object" && e10 != null && !("length" in e10) && !("type" in e10);
}
function y3(e10, t) {
  const n = b3(e10) ? (t = e10, void 0) : e10, r = {
    ...this === null || this === void 0 ? void 0 : this._options,
    ...Bo(t)
  };
  return w1(this, n, r);
}
function x3(e10) {
  const t = { ...this._options, xmlMode: true };
  return w1(this, e10, t);
}
function qi(e10) {
  const t = e10 ?? (this ? this.root() : []);
  let n = "";
  for (let r = 0; r < t.length; r++)
    n += Kr(t[r]);
  return n;
}
function w3(e10, t, n = typeof t == "boolean" ? t : false) {
  if (!e10 || typeof e10 != "string")
    return null;
  typeof t == "boolean" && (n = t);
  const r = this.load(e10, this._options, false);
  return n || r("script").remove(), [...r.root()[0].children];
}
function v3() {
  return this(this._root);
}
function v1(e10, t) {
  if (t === e10)
    return false;
  let n = t;
  for (; n && n !== n.parent; )
    if (n = n.parent, n === e10)
      return true;
  return false;
}
function k3(e10) {
  return this.root().extract(e10);
}
function _3(e10, t) {
  if (!sf(e10) || !sf(t))
    return;
  let n = e10.length;
  const r = +t.length;
  for (let i = 0; i < r; i++)
    e10[n++] = t[i];
  return e10.length = n, e10;
}
function sf(e10) {
  if (Array.isArray(e10))
    return true;
  if (typeof e10 != "object" || e10 === null || !("length" in e10) || typeof e10.length != "number" || e10.length < 0)
    return false;
  for (let t = 0; t < e10.length; t++)
    if (!(t in e10))
      return false;
  return true;
}
var S3 = Object.freeze(Object.defineProperty({
  __proto__: null,
  contains: v1,
  extract: k3,
  html: y3,
  merge: _3,
  parseHTML: w3,
  root: v3,
  text: qi,
  xml: x3
}, Symbol.toStringTag, { value: "Module" }));
function On(e10) {
  return e10.cheerio != null;
}
function A3(e10) {
  return e10.replace(/[._-](\w|$)/g, (t, n) => n.toUpperCase());
}
function E3(e10) {
  return e10.replace(/[A-Z]/g, "-$&").toLowerCase();
}
function rt(e10, t) {
  const n = e10.length;
  for (let r = 0; r < n; r++)
    t(e10[r], r);
  return e10;
}
var hr;
(function(e10) {
  e10[e10.LowerA = 97] = "LowerA", e10[e10.LowerZ = 122] = "LowerZ", e10[e10.UpperA = 65] = "UpperA", e10[e10.UpperZ = 90] = "UpperZ", e10[e10.Exclamation = 33] = "Exclamation";
})(hr || (hr = {}));
function $o(e10) {
  const t = e10.indexOf("<");
  if (t < 0 || t > e10.length - 3)
    return false;
  const n = e10.charCodeAt(t + 1);
  return (n >= hr.LowerA && n <= hr.LowerZ || n >= hr.UpperA && n <= hr.UpperZ || n === hr.Exclamation) && e10.includes(">", t + 2);
}
var Ri = Object.prototype.hasOwnProperty;
var Pi = /\s+/;
var Lo = "data-";
var Ca = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;
var C3 = /^{[^]*}$|^\[[^]*]$/;
function p0(e10, t, n) {
  var r;
  if (!(!e10 || !ke(e10))) {
    if ((r = e10.attribs) !== null && r !== void 0 || (e10.attribs = {}), !t)
      return e10.attribs;
    if (Ri.call(e10.attribs, t))
      return !n && Ca.test(t) ? t : e10.attribs[t];
    if (e10.name === "option" && t === "value")
      return qi(e10.children);
    if (e10.name === "input" && (e10.attribs.type === "radio" || e10.attribs.type === "checkbox") && t === "value")
      return "on";
  }
}
function Pr(e10, t, n) {
  n === null ? _1(e10, t) : e10.attribs[t] = `${n}`;
}
function T3(e10, t) {
  if (typeof e10 == "object" || t !== void 0) {
    if (typeof t == "function") {
      if (typeof e10 != "string")
        throw new Error("Bad combination of arguments.");
      return rt(this, (n, r) => {
        ke(n) && Pr(n, e10, t.call(n, r, n.attribs[e10]));
      });
    }
    return rt(this, (n) => {
      if (ke(n))
        if (typeof e10 == "object")
          for (const r of Object.keys(e10)) {
            const i = e10[r];
            Pr(n, r, i);
          }
        else
          Pr(n, e10, t);
    });
  }
  return arguments.length > 1 ? this : p0(this[0], e10, this.options.xmlMode);
}
function uf(e10, t, n) {
  return t in e10 ? (
    // @ts-expect-error TS doesn't like us accessing the value directly here.
    e10[t]
  ) : !n && Ca.test(t) ? p0(e10, t, false) !== void 0 : p0(e10, t, n);
}
function Ku(e10, t, n, r) {
  t in e10 ? e10[t] = n : Pr(e10, t, !r && Ca.test(t) ? n ? "" : null : `${n}`);
}
function D3(e10, t) {
  var n;
  if (typeof e10 == "string" && t === void 0) {
    const r = this[0];
    if (!r || !ke(r))
      return;
    switch (e10) {
      case "style": {
        const i = this.css(), s = Object.keys(i);
        for (let o = 0; o < s.length; o++)
          i[o] = s[o];
        return i.length = s.length, i;
      }
      case "tagName":
      case "nodeName":
        return r.name.toUpperCase();
      case "href":
      case "src": {
        const i = (n = r.attribs) === null || n === void 0 ? void 0 : n[e10];
        return typeof URL < "u" && (e10 === "href" && (r.tagName === "a" || r.tagName === "link") || e10 === "src" && (r.tagName === "img" || r.tagName === "iframe" || r.tagName === "audio" || r.tagName === "video" || r.tagName === "source")) && i !== void 0 && this.options.baseURI ? new URL(i, this.options.baseURI).href : i;
      }
      case "innerText":
        return f0(r);
      case "textContent":
        return Kr(r);
      case "outerHTML":
        return this.clone().wrap("<container />").parent().html();
      case "innerHTML":
        return this.html();
      default:
        return uf(r, e10, this.options.xmlMode);
    }
  }
  if (typeof e10 == "object" || t !== void 0) {
    if (typeof t == "function") {
      if (typeof e10 == "object")
        throw new TypeError("Bad combination of arguments.");
      return rt(this, (r, i) => {
        ke(r) && Ku(r, e10, t.call(r, i, uf(r, e10, this.options.xmlMode)), this.options.xmlMode);
      });
    }
    return rt(this, (r) => {
      if (ke(r))
        if (typeof e10 == "object")
          for (const i of Object.keys(e10)) {
            const s = e10[i];
            Ku(r, i, s, this.options.xmlMode);
          }
        else
          Ku(r, e10, t, this.options.xmlMode);
    });
  }
}
function of(e10, t, n) {
  var r;
  (r = e10.data) !== null && r !== void 0 || (e10.data = {}), typeof t == "object" ? Object.assign(e10.data, t) : typeof t == "string" && n !== void 0 && (e10.data[t] = n);
}
function M3(e10) {
  for (const t of Object.keys(e10.attribs)) {
    if (!t.startsWith(Lo))
      continue;
    const n = A3(t.slice(Lo.length));
    Ri.call(e10.data, n) || (e10.data[n] = k1(e10.attribs[t]));
  }
  return e10.data;
}
function N3(e10, t) {
  const n = Lo + E3(t), r = e10.data;
  if (Ri.call(r, t))
    return r[t];
  if (Ri.call(e10.attribs, n))
    return r[t] = k1(e10.attribs[n]);
}
function k1(e10) {
  if (e10 === "null")
    return null;
  if (e10 === "true")
    return true;
  if (e10 === "false")
    return false;
  const t = Number(e10);
  if (e10 === String(t))
    return t;
  if (C3.test(e10))
    try {
      return JSON.parse(e10);
    } catch {
    }
  return e10;
}
function I3(e10, t) {
  var n;
  const r = this[0];
  if (!r || !ke(r))
    return;
  const i = r;
  return (n = i.data) !== null && n !== void 0 || (i.data = {}), e10 == null ? M3(i) : typeof e10 == "object" || t !== void 0 ? (rt(this, (s) => {
    ke(s) && (typeof e10 == "object" ? of(s, e10) : of(s, e10, t));
  }), this) : N3(i, e10);
}
function F3(e10) {
  const t = arguments.length === 0, n = this[0];
  if (!n || !ke(n))
    return t ? void 0 : this;
  switch (n.name) {
    case "textarea":
      return this.text(e10);
    case "select": {
      const r = this.find("option:selected");
      if (!t) {
        if (this.attr("multiple") == null && typeof e10 == "object")
          return this;
        this.find("option").removeAttr("selected");
        const i = typeof e10 == "object" ? e10 : [e10];
        for (const s of i)
          this.find(`option[value="${s}"]`).attr("selected", "");
        return this;
      }
      return this.attr("multiple") ? r.toArray().map((i) => qi(i.children)) : r.attr("value");
    }
    case "input":
    case "option":
      return t ? this.attr("value") : this.attr("value", e10);
  }
}
function _1(e10, t) {
  !e10.attribs || !Ri.call(e10.attribs, t) || delete e10.attribs[t];
}
function m0(e10) {
  return e10 ? e10.trim().split(Pi) : [];
}
function B3(e10) {
  const t = m0(e10);
  for (const n of t)
    rt(this, (r) => {
      ke(r) && _1(r, n);
    });
  return this;
}
function O3(e10) {
  return this.toArray().some((t) => {
    const n = ke(t) && t.attribs.class;
    let r = -1;
    if (n && e10.length > 0)
      for (; (r = n.indexOf(e10, r + 1)) > -1; ) {
        const i = r + e10.length;
        if ((r === 0 || Pi.test(n[r - 1])) && (i === n.length || Pi.test(n[i])))
          return true;
      }
    return false;
  });
}
function S1(e10) {
  if (typeof e10 == "function")
    return rt(this, (r, i) => {
      if (ke(r)) {
        const s = r.attribs.class || "";
        S1.call([r], e10.call(r, i, s));
      }
    });
  if (!e10 || typeof e10 != "string")
    return this;
  const t = e10.split(Pi), n = this.length;
  for (let r = 0; r < n; r++) {
    const i = this[r];
    if (!ke(i))
      continue;
    const s = p0(i, "class", false);
    if (s) {
      let o = ` ${s} `;
      for (const l of t) {
        const f = `${l} `;
        o.includes(` ${f}`) || (o += f);
      }
      Pr(i, "class", o.trim());
    } else
      Pr(i, "class", t.join(" ").trim());
  }
  return this;
}
function A1(e10) {
  if (typeof e10 == "function")
    return rt(this, (i, s) => {
      ke(i) && A1.call([i], e10.call(i, s, i.attribs.class || ""));
    });
  const t = m0(e10), n = t.length, r = arguments.length === 0;
  return rt(this, (i) => {
    if (ke(i))
      if (r)
        i.attribs.class = "";
      else {
        const s = m0(i.attribs.class);
        let o = false;
        for (let l = 0; l < n; l++) {
          const f = s.indexOf(t[l]);
          f >= 0 && (s.splice(f, 1), o = true, l--);
        }
        o && (i.attribs.class = s.join(" "));
      }
  });
}
function E1(e10, t) {
  if (typeof e10 == "function")
    return rt(this, (o, l) => {
      ke(o) && E1.call([o], e10.call(o, l, o.attribs.class || "", t), t);
    });
  if (!e10 || typeof e10 != "string")
    return this;
  const n = e10.split(Pi), r = n.length, i = typeof t == "boolean" ? t ? 1 : -1 : 0, s = this.length;
  for (let o = 0; o < s; o++) {
    const l = this[o];
    if (!ke(l))
      continue;
    const f = m0(l.attribs.class);
    for (let h2 = 0; h2 < r; h2++) {
      const p = f.indexOf(n[h2]);
      i >= 0 && p < 0 ? f.push(n[h2]) : i <= 0 && p >= 0 && f.splice(p, 1);
    }
    l.attribs.class = f.join(" ");
  }
  return this;
}
var z3 = Object.freeze(Object.defineProperty({
  __proto__: null,
  addClass: S1,
  attr: T3,
  data: I3,
  hasClass: O3,
  prop: D3,
  removeAttr: B3,
  removeClass: A1,
  toggleClass: E1,
  val: F3
}, Symbol.toStringTag, { value: "Module" }));
var xe;
(function(e10) {
  e10.Attribute = "attribute", e10.Pseudo = "pseudo", e10.PseudoElement = "pseudo-element", e10.Tag = "tag", e10.Universal = "universal", e10.Adjacent = "adjacent", e10.Child = "child", e10.Descendant = "descendant", e10.Parent = "parent", e10.Sibling = "sibling", e10.ColumnCombinator = "column-combinator";
})(xe || (xe = {}));
var ht;
(function(e10) {
  e10.Any = "any", e10.Element = "element", e10.End = "end", e10.Equals = "equals", e10.Exists = "exists", e10.Hyphen = "hyphen", e10.Not = "not", e10.Start = "start";
})(ht || (ht = {}));
var af = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
var $3 = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
var L3 = /* @__PURE__ */ new Map([
  [126, ht.Element],
  [94, ht.Start],
  [36, ht.End],
  [42, ht.Any],
  [33, ht.Not],
  [124, ht.Hyphen]
]);
var q3 = /* @__PURE__ */ new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context"
]);
function Bi(e10) {
  switch (e10.type) {
    case xe.Adjacent:
    case xe.Child:
    case xe.Descendant:
    case xe.Parent:
    case xe.Sibling:
    case xe.ColumnCombinator:
      return true;
    default:
      return false;
  }
}
var R3 = /* @__PURE__ */ new Set(["contains", "icontains"]);
function P3(e10, t, n) {
  const r = parseInt(t, 16) - 65536;
  return r !== r || n ? t : r < 0 ? (
    // BMP codepoint
    String.fromCharCode(r + 65536)
  ) : (
    // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(r >> 10 | 55296, r & 1023 | 56320)
  );
}
function xi(e10) {
  return e10.replace($3, P3);
}
function Xu(e10) {
  return e10 === 39 || e10 === 34;
}
function lf(e10) {
  return e10 === 32 || e10 === 9 || e10 === 10 || e10 === 12 || e10 === 13;
}
function L0(e10) {
  const t = [], n = C1(t, `${e10}`, 0);
  if (n < e10.length)
    throw new Error(`Unmatched selector: ${e10.slice(n)}`);
  return t;
}
function C1(e10, t, n) {
  let r = [];
  function i(v) {
    const k = t.slice(n + v).match(af);
    if (!k)
      throw new Error(`Expected name, found ${t.slice(n)}`);
    const [w] = k;
    return n += v + w.length, xi(w);
  }
  function s(v) {
    for (n += v; n < t.length && lf(t.charCodeAt(n)); )
      n++;
  }
  function o() {
    n += 1;
    const v = n;
    let k = 1;
    for (; k > 0 && n < t.length; n++)
      t.charCodeAt(n) === 40 && !l(n) ? k++ : t.charCodeAt(n) === 41 && !l(n) && k--;
    if (k)
      throw new Error("Parenthesis not matched");
    return xi(t.slice(v, n - 1));
  }
  function l(v) {
    let k = 0;
    for (; t.charCodeAt(--v) === 92; )
      k++;
    return (k & 1) === 1;
  }
  function f() {
    if (r.length > 0 && Bi(r[r.length - 1]))
      throw new Error("Did not expect successive traversals.");
  }
  function h2(v) {
    if (r.length > 0 && r[r.length - 1].type === xe.Descendant) {
      r[r.length - 1].type = v;
      return;
    }
    f(), r.push({ type: v });
  }
  function p(v, k) {
    r.push({
      type: xe.Attribute,
      name: v,
      action: k,
      value: i(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function b() {
    if (r.length && r[r.length - 1].type === xe.Descendant && r.pop(), r.length === 0)
      throw new Error("Empty sub-selector");
    e10.push(r);
  }
  if (s(0), t.length === n)
    return n;
  e: for (; n < t.length; ) {
    const v = t.charCodeAt(n);
    switch (v) {
      case 32:
      case 9:
      case 10:
      case 12:
      case 13: {
        (r.length === 0 || r[0].type !== xe.Descendant) && (f(), r.push({ type: xe.Descendant })), s(1);
        break;
      }
      case 62: {
        h2(xe.Child), s(1);
        break;
      }
      case 60: {
        h2(xe.Parent), s(1);
        break;
      }
      case 126: {
        h2(xe.Sibling), s(1);
        break;
      }
      case 43: {
        h2(xe.Adjacent), s(1);
        break;
      }
      case 46: {
        p("class", ht.Element);
        break;
      }
      case 35: {
        p("id", ht.Equals);
        break;
      }
      case 91: {
        s(1);
        let k, w = null;
        t.charCodeAt(n) === 124 ? k = i(1) : t.startsWith("*|", n) ? (w = "*", k = i(2)) : (k = i(0), t.charCodeAt(n) === 124 && t.charCodeAt(n + 1) !== 61 && (w = k, k = i(1))), s(0);
        let A = ht.Exists;
        const T = L3.get(t.charCodeAt(n));
        if (T) {
          if (A = T, t.charCodeAt(n + 1) !== 61)
            throw new Error("Expected `=`");
          s(2);
        } else t.charCodeAt(n) === 61 && (A = ht.Equals, s(1));
        let D = "", N = null;
        if (A !== "exists") {
          if (Xu(t.charCodeAt(n))) {
            const z = t.charCodeAt(n);
            let R = n + 1;
            for (; R < t.length && (t.charCodeAt(R) !== z || l(R)); )
              R += 1;
            if (t.charCodeAt(R) !== z)
              throw new Error("Attribute value didn't end");
            D = xi(t.slice(n + 1, R)), n = R + 1;
          } else {
            const z = n;
            for (; n < t.length && (!lf(t.charCodeAt(n)) && t.charCodeAt(n) !== 93 || l(n)); )
              n += 1;
            D = xi(t.slice(z, n));
          }
          s(0);
          const q = t.charCodeAt(n) | 32;
          q === 115 ? (N = false, s(1)) : q === 105 && (N = true, s(1));
        }
        if (t.charCodeAt(n) !== 93)
          throw new Error("Attribute selector didn't terminate");
        n += 1;
        const O = {
          type: xe.Attribute,
          name: k,
          action: A,
          value: D,
          namespace: w,
          ignoreCase: N
        };
        r.push(O);
        break;
      }
      case 58: {
        if (t.charCodeAt(n + 1) === 58) {
          r.push({
            type: xe.PseudoElement,
            name: i(2).toLowerCase(),
            data: t.charCodeAt(n) === 40 ? o() : null
          });
          continue;
        }
        const k = i(1).toLowerCase();
        let w = null;
        if (t.charCodeAt(n) === 40)
          if (q3.has(k)) {
            if (Xu(t.charCodeAt(n + 1)))
              throw new Error(`Pseudo-selector ${k} cannot be quoted`);
            if (w = [], n = C1(w, t, n + 1), t.charCodeAt(n) !== 41)
              throw new Error(`Missing closing parenthesis in :${k} (${t})`);
            n += 1;
          } else {
            if (w = o(), R3.has(k)) {
              const A = w.charCodeAt(0);
              A === w.charCodeAt(w.length - 1) && Xu(A) && (w = w.slice(1, -1));
            }
            w = xi(w);
          }
        r.push({ type: xe.Pseudo, name: k, data: w });
        break;
      }
      case 44: {
        b(), r = [], s(1);
        break;
      }
      default: {
        if (t.startsWith("/*", n)) {
          const A = t.indexOf("*/", n + 2);
          if (A < 0)
            throw new Error("Comment was not terminated");
          n = A + 2, r.length === 0 && s(0);
          break;
        }
        let k = null, w;
        if (v === 42)
          n += 1, w = "*";
        else if (v === 124) {
          if (w = "", t.charCodeAt(n + 1) === 124) {
            h2(xe.ColumnCombinator), s(2);
            break;
          }
        } else if (af.test(t.slice(n)))
          w = i(0);
        else
          break e;
        t.charCodeAt(n) === 124 && t.charCodeAt(n + 1) !== 124 && (k = w, t.charCodeAt(n + 1) === 42 ? (w = "*", n += 2) : w = i(1)), r.push(w === "*" ? { type: xe.Universal, namespace: k } : { type: xe.Tag, name: w, namespace: k });
      }
    }
  }
  return b(), n;
}
function H3(e10) {
  return e10 && e10.__esModule && Object.prototype.hasOwnProperty.call(e10, "default") ? e10.default : e10;
}
var Yu;
var cf;
function j3() {
  return cf || (cf = 1, Yu = {
    trueFunc: function() {
      return true;
    },
    falseFunc: function() {
      return false;
    }
  }), Yu;
}
var g0 = j3();
var Ce = H3(g0);
var T1 = /* @__PURE__ */ new Map([
  [xe.Universal, 50],
  [xe.Tag, 30],
  [xe.Attribute, 1],
  [xe.Pseudo, 0]
]);
function Ta(e10) {
  return !T1.has(e10.type);
}
var U3 = /* @__PURE__ */ new Map([
  [ht.Exists, 10],
  [ht.Equals, 8],
  [ht.Not, 7],
  [ht.Start, 6],
  [ht.End, 6],
  [ht.Any, 5]
]);
function V3(e10) {
  const t = e10.map(D1);
  for (let n = 1; n < e10.length; n++) {
    const r = t[n];
    if (!(r < 0))
      for (let i = n - 1; i >= 0 && r < t[i]; i--) {
        const s = e10[i + 1];
        e10[i + 1] = e10[i], e10[i] = s, t[i + 1] = t[i], t[i] = r;
      }
  }
}
function D1(e10) {
  var t, n;
  let r = (t = T1.get(e10.type)) !== null && t !== void 0 ? t : -1;
  return e10.type === xe.Attribute ? (r = (n = U3.get(e10.action)) !== null && n !== void 0 ? n : 4, e10.action === ht.Equals && e10.name === "id" && (r = 9), e10.ignoreCase && (r >>= 1)) : e10.type === xe.Pseudo && (e10.data ? e10.name === "has" || e10.name === "contains" ? r = 0 : Array.isArray(e10.data) ? (r = Math.min(...e10.data.map((i) => Math.min(...i.map(D1)))), r < 0 && (r = 0)) : r = 2 : r = 3), r;
}
var G3 = /[-[\]{}()*+?.,\\^$|#\s]/g;
function ff(e10) {
  return e10.replace(G3, "\\$&");
}
var W3 = /* @__PURE__ */ new Set([
  "accept",
  "accept-charset",
  "align",
  "alink",
  "axis",
  "bgcolor",
  "charset",
  "checked",
  "clear",
  "codetype",
  "color",
  "compact",
  "declare",
  "defer",
  "dir",
  "direction",
  "disabled",
  "enctype",
  "face",
  "frame",
  "hreflang",
  "http-equiv",
  "lang",
  "language",
  "link",
  "media",
  "method",
  "multiple",
  "nohref",
  "noresize",
  "noshade",
  "nowrap",
  "readonly",
  "rel",
  "rev",
  "rules",
  "scope",
  "scrolling",
  "selected",
  "shape",
  "target",
  "text",
  "type",
  "valign",
  "valuetype",
  "vlink"
]);
function sr(e10, t) {
  return typeof e10.ignoreCase == "boolean" ? e10.ignoreCase : e10.ignoreCase === "quirks" ? !!t.quirksMode : !t.xmlMode && W3.has(e10.name);
}
var K3 = {
  equals(e10, t, n) {
    const { adapter: r } = n, { name: i } = t;
    let { value: s } = t;
    return sr(t, n) ? (s = s.toLowerCase(), (o) => {
      const l = r.getAttributeValue(o, i);
      return l != null && l.length === s.length && l.toLowerCase() === s && e10(o);
    }) : (o) => r.getAttributeValue(o, i) === s && e10(o);
  },
  hyphen(e10, t, n) {
    const { adapter: r } = n, { name: i } = t;
    let { value: s } = t;
    const o = s.length;
    return sr(t, n) ? (s = s.toLowerCase(), function(f) {
      const h2 = r.getAttributeValue(f, i);
      return h2 != null && (h2.length === o || h2.charAt(o) === "-") && h2.substr(0, o).toLowerCase() === s && e10(f);
    }) : function(f) {
      const h2 = r.getAttributeValue(f, i);
      return h2 != null && (h2.length === o || h2.charAt(o) === "-") && h2.substr(0, o) === s && e10(f);
    };
  },
  element(e10, t, n) {
    const { adapter: r } = n, { name: i, value: s } = t;
    if (/\s/.test(s))
      return Ce.falseFunc;
    const o = new RegExp(`(?:^|\\s)${ff(s)}(?:$|\\s)`, sr(t, n) ? "i" : "");
    return function(f) {
      const h2 = r.getAttributeValue(f, i);
      return h2 != null && h2.length >= s.length && o.test(h2) && e10(f);
    };
  },
  exists(e10, { name: t }, { adapter: n }) {
    return (r) => n.hasAttrib(r, t) && e10(r);
  },
  start(e10, t, n) {
    const { adapter: r } = n, { name: i } = t;
    let { value: s } = t;
    const o = s.length;
    return o === 0 ? Ce.falseFunc : sr(t, n) ? (s = s.toLowerCase(), (l) => {
      const f = r.getAttributeValue(l, i);
      return f != null && f.length >= o && f.substr(0, o).toLowerCase() === s && e10(l);
    }) : (l) => {
      var f;
      return !!(!((f = r.getAttributeValue(l, i)) === null || f === void 0) && f.startsWith(s)) && e10(l);
    };
  },
  end(e10, t, n) {
    const { adapter: r } = n, { name: i } = t;
    let { value: s } = t;
    const o = -s.length;
    return o === 0 ? Ce.falseFunc : sr(t, n) ? (s = s.toLowerCase(), (l) => {
      var f;
      return ((f = r.getAttributeValue(l, i)) === null || f === void 0 ? void 0 : f.substr(o).toLowerCase()) === s && e10(l);
    }) : (l) => {
      var f;
      return !!(!((f = r.getAttributeValue(l, i)) === null || f === void 0) && f.endsWith(s)) && e10(l);
    };
  },
  any(e10, t, n) {
    const { adapter: r } = n, { name: i, value: s } = t;
    if (s === "")
      return Ce.falseFunc;
    if (sr(t, n)) {
      const o = new RegExp(ff(s), "i");
      return function(f) {
        const h2 = r.getAttributeValue(f, i);
        return h2 != null && h2.length >= s.length && o.test(h2) && e10(f);
      };
    }
    return (o) => {
      var l;
      return !!(!((l = r.getAttributeValue(o, i)) === null || l === void 0) && l.includes(s)) && e10(o);
    };
  },
  not(e10, t, n) {
    const { adapter: r } = n, { name: i } = t;
    let { value: s } = t;
    return s === "" ? (o) => !!r.getAttributeValue(o, i) && e10(o) : sr(t, n) ? (s = s.toLowerCase(), (o) => {
      const l = r.getAttributeValue(o, i);
      return (l == null || l.length !== s.length || l.toLowerCase() !== s) && e10(o);
    }) : (o) => r.getAttributeValue(o, i) !== s && e10(o);
  }
};
var X3 = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
var hf = 48;
var Y3 = 57;
function Z3(e10) {
  if (e10 = e10.trim().toLowerCase(), e10 === "even")
    return [2, 0];
  if (e10 === "odd")
    return [2, 1];
  let t = 0, n = 0, r = s(), i = o();
  if (t < e10.length && e10.charAt(t) === "n" && (t++, n = r * (i ?? 1), l(), t < e10.length ? (r = s(), l(), i = o()) : r = i = 0), i === null || t < e10.length)
    throw new Error(`n-th rule couldn't be parsed ('${e10}')`);
  return [n, r * i];
  function s() {
    return e10.charAt(t) === "-" ? (t++, -1) : (e10.charAt(t) === "+" && t++, 1);
  }
  function o() {
    const f = t;
    let h2 = 0;
    for (; t < e10.length && e10.charCodeAt(t) >= hf && e10.charCodeAt(t) <= Y3; )
      h2 = h2 * 10 + (e10.charCodeAt(t) - hf), t++;
    return t === f ? null : h2;
  }
  function l() {
    for (; t < e10.length && X3.has(e10.charCodeAt(t)); )
      t++;
  }
}
function J3(e10) {
  const t = e10[0], n = e10[1] - 1;
  if (n < 0 && t <= 0)
    return Ce.falseFunc;
  if (t === -1)
    return (s) => s <= n;
  if (t === 0)
    return (s) => s === n;
  if (t === 1)
    return n < 0 ? Ce.trueFunc : (s) => s >= n;
  const r = Math.abs(t), i = (n % r + r) % r;
  return t > 1 ? (s) => s >= n && s % r === i : (s) => s <= n && s % r === i;
}
function Fs(e10) {
  return J3(Z3(e10));
}
function Bs(e10, t) {
  return (n) => {
    const r = t.getParent(n);
    return r != null && t.isTag(r) && e10(n);
  };
}
var qo = {
  contains(e10, t, { adapter: n }) {
    return function(i) {
      return e10(i) && n.getText(i).includes(t);
    };
  },
  icontains(e10, t, { adapter: n }) {
    const r = t.toLowerCase();
    return function(s) {
      return e10(s) && n.getText(s).toLowerCase().includes(r);
    };
  },
  // Location specific methods
  "nth-child"(e10, t, { adapter: n, equals: r }) {
    const i = Fs(t);
    return i === Ce.falseFunc ? Ce.falseFunc : i === Ce.trueFunc ? Bs(e10, n) : function(o) {
      const l = n.getSiblings(o);
      let f = 0;
      for (let h2 = 0; h2 < l.length && !r(o, l[h2]); h2++)
        n.isTag(l[h2]) && f++;
      return i(f) && e10(o);
    };
  },
  "nth-last-child"(e10, t, { adapter: n, equals: r }) {
    const i = Fs(t);
    return i === Ce.falseFunc ? Ce.falseFunc : i === Ce.trueFunc ? Bs(e10, n) : function(o) {
      const l = n.getSiblings(o);
      let f = 0;
      for (let h2 = l.length - 1; h2 >= 0 && !r(o, l[h2]); h2--)
        n.isTag(l[h2]) && f++;
      return i(f) && e10(o);
    };
  },
  "nth-of-type"(e10, t, { adapter: n, equals: r }) {
    const i = Fs(t);
    return i === Ce.falseFunc ? Ce.falseFunc : i === Ce.trueFunc ? Bs(e10, n) : function(o) {
      const l = n.getSiblings(o);
      let f = 0;
      for (let h2 = 0; h2 < l.length; h2++) {
        const p = l[h2];
        if (r(o, p))
          break;
        n.isTag(p) && n.getName(p) === n.getName(o) && f++;
      }
      return i(f) && e10(o);
    };
  },
  "nth-last-of-type"(e10, t, { adapter: n, equals: r }) {
    const i = Fs(t);
    return i === Ce.falseFunc ? Ce.falseFunc : i === Ce.trueFunc ? Bs(e10, n) : function(o) {
      const l = n.getSiblings(o);
      let f = 0;
      for (let h2 = l.length - 1; h2 >= 0; h2--) {
        const p = l[h2];
        if (r(o, p))
          break;
        n.isTag(p) && n.getName(p) === n.getName(o) && f++;
      }
      return i(f) && e10(o);
    };
  },
  // TODO determine the actual root element
  root(e10, t, { adapter: n }) {
    return (r) => {
      const i = n.getParent(r);
      return (i == null || !n.isTag(i)) && e10(r);
    };
  },
  scope(e10, t, n, r) {
    const { equals: i } = n;
    return !r || r.length === 0 ? qo.root(e10, t, n) : r.length === 1 ? (s) => i(r[0], s) && e10(s) : (s) => r.includes(s) && e10(s);
  },
  hover: Zu("isHovered"),
  visited: Zu("isVisited"),
  active: Zu("isActive")
};
function Zu(e10) {
  return function(n, r, { adapter: i }) {
    const s = i[e10];
    return typeof s != "function" ? Ce.falseFunc : function(l) {
      return s(l) && n(l);
    };
  };
}
var df = {
  empty(e10, { adapter: t }) {
    return !t.getChildren(e10).some((n) => (
      // FIXME: `getText` call is potentially expensive.
      t.isTag(n) || t.getText(n) !== ""
    ));
  },
  "first-child"(e10, { adapter: t, equals: n }) {
    if (t.prevElementSibling)
      return t.prevElementSibling(e10) == null;
    const r = t.getSiblings(e10).find((i) => t.isTag(i));
    return r != null && n(e10, r);
  },
  "last-child"(e10, { adapter: t, equals: n }) {
    const r = t.getSiblings(e10);
    for (let i = r.length - 1; i >= 0; i--) {
      if (n(e10, r[i]))
        return true;
      if (t.isTag(r[i]))
        break;
    }
    return false;
  },
  "first-of-type"(e10, { adapter: t, equals: n }) {
    const r = t.getSiblings(e10), i = t.getName(e10);
    for (let s = 0; s < r.length; s++) {
      const o = r[s];
      if (n(e10, o))
        return true;
      if (t.isTag(o) && t.getName(o) === i)
        break;
    }
    return false;
  },
  "last-of-type"(e10, { adapter: t, equals: n }) {
    const r = t.getSiblings(e10), i = t.getName(e10);
    for (let s = r.length - 1; s >= 0; s--) {
      const o = r[s];
      if (n(e10, o))
        return true;
      if (t.isTag(o) && t.getName(o) === i)
        break;
    }
    return false;
  },
  "only-of-type"(e10, { adapter: t, equals: n }) {
    const r = t.getName(e10);
    return t.getSiblings(e10).every((i) => n(e10, i) || !t.isTag(i) || t.getName(i) !== r);
  },
  "only-child"(e10, { adapter: t, equals: n }) {
    return t.getSiblings(e10).every((r) => n(e10, r) || !t.isTag(r));
  }
};
function pf(e10, t, n, r) {
  if (n === null) {
    if (e10.length > r)
      throw new Error(`Pseudo-class :${t} requires an argument`);
  } else if (e10.length === r)
    throw new Error(`Pseudo-class :${t} doesn't have any arguments`);
}
var Q3 = {
  // Links
  "any-link": ":is(a, area, link)[href]",
  link: ":any-link:not(:visited)",
  // Forms
  // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
  disabled: `:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,
  enabled: ":not(:disabled)",
  checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
  required: ":is(input, select, textarea)[required]",
  optional: ":is(input, select, textarea):not([required])",
  // JQuery extensions
  // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
  selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
  checkbox: "[type=checkbox]",
  file: "[type=file]",
  password: "[type=password]",
  radio: "[type=radio]",
  reset: "[type=reset]",
  image: "[type=image]",
  submit: "[type=submit]",
  parent: ":not(:empty)",
  header: ":is(h1, h2, h3, h4, h5, h6)",
  button: ":is(button, input[type=button])",
  input: ":is(input, textarea, select, button)",
  text: "input:is(:not([type!='']), [type=text])"
};
var M1 = {};
function e6(e10, t) {
  return e10 === Ce.falseFunc ? Ce.falseFunc : (n) => t.isTag(n) && e10(n);
}
function N1(e10, t) {
  const n = t.getSiblings(e10);
  if (n.length <= 1)
    return [];
  const r = n.indexOf(e10);
  return r < 0 || r === n.length - 1 ? [] : n.slice(r + 1).filter(t.isTag);
}
function Ro(e10) {
  return {
    xmlMode: !!e10.xmlMode,
    lowerCaseAttributeNames: !!e10.lowerCaseAttributeNames,
    lowerCaseTags: !!e10.lowerCaseTags,
    quirksMode: !!e10.quirksMode,
    cacheResults: !!e10.cacheResults,
    pseudos: e10.pseudos,
    adapter: e10.adapter,
    equals: e10.equals
  };
}
var Ju = (e10, t, n, r, i) => {
  const s = i(t, Ro(n), r);
  return s === Ce.trueFunc ? e10 : s === Ce.falseFunc ? Ce.falseFunc : (o) => s(o) && e10(o);
};
var Qu = {
  is: Ju,
  /**
   * `:matches` and `:where` are aliases for `:is`.
   */
  matches: Ju,
  where: Ju,
  not(e10, t, n, r, i) {
    const s = i(t, Ro(n), r);
    return s === Ce.falseFunc ? e10 : s === Ce.trueFunc ? Ce.falseFunc : (o) => !s(o) && e10(o);
  },
  has(e10, t, n, r, i) {
    const { adapter: s } = n, o = Ro(n);
    o.relativeSelector = true;
    const l = t.some((p) => p.some(Ta)) ? (
      // Used as a placeholder. Will be replaced with the actual element.
      [M1]
    ) : void 0, f = i(t, o, l);
    if (f === Ce.falseFunc)
      return Ce.falseFunc;
    const h2 = e6(f, s);
    if (l && f !== Ce.trueFunc) {
      const { shouldTestNextSiblings: p = false } = f;
      return (b) => {
        if (!e10(b))
          return false;
        l[0] = b;
        const v = s.getChildren(b), k = p ? [...v, ...N1(b, s)] : v;
        return s.existsOne(h2, k);
      };
    }
    return (p) => e10(p) && s.existsOne(h2, s.getChildren(p));
  }
};
function t6(e10, t, n, r, i) {
  var s;
  const { name: o, data: l } = t;
  if (Array.isArray(l)) {
    if (!(o in Qu))
      throw new Error(`Unknown pseudo-class :${o}(${l})`);
    return Qu[o](e10, l, n, r, i);
  }
  const f = (s = n.pseudos) === null || s === void 0 ? void 0 : s[o], h2 = typeof f == "string" ? f : Q3[o];
  if (typeof h2 == "string") {
    if (l != null)
      throw new Error(`Pseudo ${o} doesn't have any arguments`);
    const p = L0(h2);
    return Qu.is(e10, p, n, r, i);
  }
  if (typeof f == "function")
    return pf(f, o, l, 1), (p) => f(p, l) && e10(p);
  if (o in qo)
    return qo[o](e10, l, n, r);
  if (o in df) {
    const p = df[o];
    return pf(p, o, l, 2), (b) => p(b, n, l) && e10(b);
  }
  throw new Error(`Unknown pseudo-class :${o}`);
}
function eo(e10, t) {
  const n = t.getParent(e10);
  return n && t.isTag(n) ? n : null;
}
function n6(e10, t, n, r, i) {
  const { adapter: s, equals: o } = n;
  switch (t.type) {
    case xe.PseudoElement:
      throw new Error("Pseudo-elements are not supported by css-select");
    case xe.ColumnCombinator:
      throw new Error("Column combinators are not yet supported by css-select");
    case xe.Attribute: {
      if (t.namespace != null)
        throw new Error("Namespaced attributes are not yet supported by css-select");
      return (!n.xmlMode || n.lowerCaseAttributeNames) && (t.name = t.name.toLowerCase()), K3[t.action](e10, t, n);
    }
    case xe.Pseudo:
      return t6(e10, t, n, r, i);
    case xe.Tag: {
      if (t.namespace != null)
        throw new Error("Namespaced tag names are not yet supported by css-select");
      let { name: l } = t;
      return (!n.xmlMode || n.lowerCaseTags) && (l = l.toLowerCase()), function(h2) {
        return s.getName(h2) === l && e10(h2);
      };
    }
    case xe.Descendant: {
      if (n.cacheResults === false || typeof WeakSet > "u")
        return function(h2) {
          let p = h2;
          for (; p = eo(p, s); )
            if (e10(p))
              return true;
          return false;
        };
      const l = /* @__PURE__ */ new WeakSet();
      return function(h2) {
        let p = h2;
        for (; p = eo(p, s); )
          if (!l.has(p)) {
            if (s.isTag(p) && e10(p))
              return true;
            l.add(p);
          }
        return false;
      };
    }
    case "_flexibleDescendant":
      return function(f) {
        let h2 = f;
        do
          if (e10(h2))
            return true;
        while (h2 = eo(h2, s));
        return false;
      };
    case xe.Parent:
      return function(f) {
        return s.getChildren(f).some((h2) => s.isTag(h2) && e10(h2));
      };
    case xe.Child:
      return function(f) {
        const h2 = s.getParent(f);
        return h2 != null && s.isTag(h2) && e10(h2);
      };
    case xe.Sibling:
      return function(f) {
        const h2 = s.getSiblings(f);
        for (let p = 0; p < h2.length; p++) {
          const b = h2[p];
          if (o(f, b))
            break;
          if (s.isTag(b) && e10(b))
            return true;
        }
        return false;
      };
    case xe.Adjacent:
      return s.prevElementSibling ? function(f) {
        const h2 = s.prevElementSibling(f);
        return h2 != null && e10(h2);
      } : function(f) {
        const h2 = s.getSiblings(f);
        let p;
        for (let b = 0; b < h2.length; b++) {
          const v = h2[b];
          if (o(f, v))
            break;
          s.isTag(v) && (p = v);
        }
        return !!p && e10(p);
      };
    case xe.Universal: {
      if (t.namespace != null && t.namespace !== "*")
        throw new Error("Namespaced universal selectors are not yet supported by css-select");
      return e10;
    }
  }
}
function I1(e10) {
  return e10.type === xe.Pseudo && (e10.name === "scope" || Array.isArray(e10.data) && e10.data.some((t) => t.some(I1)));
}
var r6 = { type: xe.Descendant };
var i6 = {
  type: "_flexibleDescendant"
};
var s6 = {
  type: xe.Pseudo,
  name: "scope",
  data: null
};
function u6(e10, { adapter: t }, n) {
  const r = !!(n == null ? void 0 : n.every((i) => {
    const s = t.isTag(i) && t.getParent(i);
    return i === M1 || s && t.isTag(s);
  }));
  for (const i of e10) {
    if (!(i.length > 0 && Ta(i[0]) && i[0].type !== xe.Descendant)) if (r && !i.some(I1))
      i.unshift(r6);
    else
      continue;
    i.unshift(s6);
  }
}
function F1(e10, t, n) {
  var r;
  e10.forEach(V3), n = (r = t.context) !== null && r !== void 0 ? r : n;
  const i = Array.isArray(n), s = n && (Array.isArray(n) ? n : [n]);
  if (t.relativeSelector !== false)
    u6(e10, t, s);
  else if (e10.some((f) => f.length > 0 && Ta(f[0])))
    throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
  let o = false;
  const l = e10.map((f) => {
    if (f.length >= 2) {
      const [h2, p] = f;
      h2.type !== xe.Pseudo || h2.name !== "scope" || (i && p.type === xe.Descendant ? f[1] = i6 : (p.type === xe.Adjacent || p.type === xe.Sibling) && (o = true));
    }
    return o6(f, t, s);
  }).reduce(a6, Ce.falseFunc);
  return l.shouldTestNextSiblings = o, l;
}
function o6(e10, t, n) {
  var r;
  return e10.reduce((i, s) => i === Ce.falseFunc ? Ce.falseFunc : n6(i, s, t, n, F1), (r = t.rootFunc) !== null && r !== void 0 ? r : Ce.trueFunc);
}
function a6(e10, t) {
  return t === Ce.falseFunc || e10 === Ce.trueFunc ? e10 : e10 === Ce.falseFunc || t === Ce.trueFunc ? t : function(r) {
    return e10(r) || t(r);
  };
}
var B1 = (e10, t) => e10 === t;
var l6 = {
  adapter: $0,
  equals: B1
};
function c6(e10) {
  var t, n, r, i;
  const s = e10 ?? l6;
  return (t = s.adapter) !== null && t !== void 0 || (s.adapter = $0), (n = s.equals) !== null && n !== void 0 || (s.equals = (i = (r = s.adapter) === null || r === void 0 ? void 0 : r.equals) !== null && i !== void 0 ? i : B1), s;
}
function f6(e10) {
  return function(n, r, i) {
    const s = c6(r);
    return e10(n, s, i);
  };
}
var Da = f6(F1);
function O1(e10, t, n = false) {
  return n && (e10 = h6(e10, t)), Array.isArray(e10) ? t.removeSubsets(e10) : t.getChildren(e10);
}
function h6(e10, t) {
  const n = Array.isArray(e10) ? e10.slice(0) : [e10], r = n.length;
  for (let i = 0; i < r; i++) {
    const s = N1(n[i], t);
    n.push(...s);
  }
  return n;
}
var d6 = /* @__PURE__ */ new Set([
  "first",
  "last",
  "eq",
  "gt",
  "nth",
  "lt",
  "even",
  "odd"
]);
function b0(e10) {
  return e10.type !== "pseudo" ? false : d6.has(e10.name) ? true : e10.name === "not" && Array.isArray(e10.data) ? e10.data.some((t) => t.some(b0)) : false;
}
function p6(e10, t, n) {
  const r = t != null ? parseInt(t, 10) : NaN;
  switch (e10) {
    case "first":
      return 1;
    case "nth":
    case "eq":
      return isFinite(r) ? r >= 0 ? r + 1 : 1 / 0 : 0;
    case "lt":
      return isFinite(r) ? r >= 0 ? Math.min(r, n) : 1 / 0 : 0;
    case "gt":
      return isFinite(r) ? 1 / 0 : 0;
    case "odd":
      return 2 * n;
    case "even":
      return 2 * n - 1;
    case "last":
    case "not":
      return 1 / 0;
  }
}
function m6(e10) {
  for (; e10.parent; )
    e10 = e10.parent;
  return e10;
}
function Ma(e10) {
  const t = [], n = [];
  for (const r of e10)
    r.some(b0) ? t.push(r) : n.push(r);
  return [n, t];
}
var g6 = {
  type: xe.Universal,
  namespace: null
};
var b6 = {
  type: xe.Pseudo,
  name: "scope",
  data: null
};
function z1(e10, t, n = {}) {
  return $1([e10], t, n);
}
function $1(e10, t, n = {}) {
  if (typeof t == "function")
    return e10.some(t);
  const [r, i] = Ma(L0(t));
  return r.length > 0 && e10.some(Da(r, n)) || i.some((s) => R1(s, e10, n).length > 0);
}
function y6(e10, t, n, r) {
  const i = typeof n == "string" ? parseInt(n, 10) : NaN;
  switch (e10) {
    case "first":
    case "lt":
      return t;
    case "last":
      return t.length > 0 ? [t[t.length - 1]] : t;
    case "nth":
    case "eq":
      return isFinite(i) && Math.abs(i) < t.length ? [i < 0 ? t[t.length + i] : t[i]] : [];
    case "gt":
      return isFinite(i) ? t.slice(i + 1) : [];
    case "even":
      return t.filter((s, o) => o % 2 === 0);
    case "odd":
      return t.filter((s, o) => o % 2 === 1);
    case "not": {
      const s = new Set(q1(n, t, r));
      return t.filter((o) => !s.has(o));
    }
  }
}
function L1(e10, t, n = {}) {
  return q1(L0(e10), t, n);
}
function q1(e10, t, n) {
  if (t.length === 0)
    return [];
  const [r, i] = Ma(e10);
  let s;
  if (r.length) {
    const o = Ho(t, r, n);
    if (i.length === 0)
      return o;
    o.length && (s = new Set(o));
  }
  for (let o = 0; o < i.length && (s == null ? void 0 : s.size) !== t.length; o++) {
    const l = i[o];
    if ((s ? t.filter((p) => ke(p) && !s.has(p)) : t).length === 0)
      break;
    const h2 = R1(l, t, n);
    if (h2.length)
      if (s)
        h2.forEach((p) => s.add(p));
      else {
        if (o === i.length - 1)
          return h2;
        s = new Set(h2);
      }
  }
  return typeof s < "u" ? s.size === t.length ? t : (
    // Filter elements to preserve order
    t.filter((o) => s.has(o))
  ) : [];
}
function R1(e10, t, n) {
  var r;
  if (e10.some(Bi)) {
    const i = (r = n.root) !== null && r !== void 0 ? r : m6(t[0]), s = { ...n, context: t, relativeSelector: false };
    return e10.push(b6), y0(i, e10, s, true, t.length);
  }
  return y0(t, e10, n, false, t.length);
}
function x6(e10, t, n = {}, r = 1 / 0) {
  if (typeof e10 == "function")
    return P1(t, e10);
  const [i, s] = Ma(L0(e10)), o = s.map((l) => y0(t, l, n, true, r));
  return i.length && o.push(Po(t, i, n, r)), o.length === 0 ? [] : o.length === 1 ? o[0] : ii(o.reduce((l, f) => [...l, ...f]));
}
function y0(e10, t, n, r, i) {
  const s = t.findIndex(b0), o = t.slice(0, s), l = t[s], f = t.length - 1 === s ? i : 1 / 0, h2 = p6(l.name, l.data, f);
  if (h2 === 0)
    return [];
  const b = (o.length === 0 && !Array.isArray(e10) ? O0(e10).filter(ke) : o.length === 0 ? (Array.isArray(e10) ? e10 : [e10]).filter(ke) : r || o.some(Bi) ? Po(e10, [o], n, h2) : Ho(e10, [o], n)).slice(0, h2);
  let v = y6(l.name, b, l.data, n);
  if (v.length === 0 || t.length === s + 1)
    return v;
  const k = t.slice(s + 1), w = k.some(Bi);
  if (w) {
    if (Bi(k[0])) {
      const { type: A } = k[0];
      (A === xe.Sibling || A === xe.Adjacent) && (v = O1(v, $0, true)), k.unshift(g6);
    }
    n = {
      ...n,
      // Avoid absolutizing the selector
      relativeSelector: false,
      /*
       * Add a custom root func, to make sure traversals don't match elements
       * that aren't a part of the considered tree.
       */
      rootFunc: (A) => v.includes(A)
    };
  } else n.rootFunc && n.rootFunc !== g0.trueFunc && (n = { ...n, rootFunc: g0.trueFunc });
  return k.some(b0) ? y0(v, k, n, false, i) : w ? (
    // Query existing elements to resolve traversal.
    Po(v, [k], n, i)
  ) : (
    // If we don't have any more traversals, simply filter elements.
    Ho(v, [k], n)
  );
}
function Po(e10, t, n, r) {
  const i = Da(t, n, e10);
  return P1(e10, i, r);
}
function P1(e10, t, n = 1 / 0) {
  const r = O1(e10, $0, t.shouldTestNextSiblings);
  return Aa((i) => ke(i) && t(i), r, true, n);
}
function Ho(e10, t, n) {
  const r = (Array.isArray(e10) ? e10 : [e10]).filter(ke);
  if (r.length === 0)
    return r;
  const i = Da(t, n);
  return i === g0.trueFunc ? r : r.filter(i);
}
var w6 = /^\s*[+~]/;
function v6(e10) {
  if (!e10)
    return this._make([]);
  if (typeof e10 != "string") {
    const t = On(e10) ? e10.toArray() : [e10], n = this.toArray();
    return this._make(t.filter((r) => n.some((i) => v1(i, r))));
  }
  return this._findBySelector(e10, Number.POSITIVE_INFINITY);
}
function k6(e10, t) {
  var n;
  const r = this.toArray(), i = w6.test(e10) ? r : this.children().toArray(), s = {
    context: r,
    root: (n = this._root) === null || n === void 0 ? void 0 : n[0],
    // Pass options that are recognized by `cheerio-select`
    xmlMode: this.options.xmlMode,
    lowerCaseTags: this.options.lowerCaseTags,
    lowerCaseAttributeNames: this.options.lowerCaseAttributeNames,
    pseudos: this.options.pseudos,
    quirksMode: this.options.quirksMode
  };
  return this._make(x6(e10, i, s, t));
}
function Na(e10) {
  return function(t, ...n) {
    return function(r) {
      var i;
      let s = e10(t, this);
      return r && (s = Ba(s, r, this.options.xmlMode, (i = this._root) === null || i === void 0 ? void 0 : i[0])), this._make(
        // Post processing is only necessary if there is more than one element.
        this.length > 1 && s.length > 1 ? n.reduce((o, l) => l(o), s) : s
      );
    };
  };
}
var Qi = Na((e10, t) => {
  let n = [];
  for (let r = 0; r < t.length; r++) {
    const i = e10(t[r]);
    i.length > 0 && (n = n.concat(i));
  }
  return n;
});
var Ia = Na((e10, t) => {
  const n = [];
  for (let r = 0; r < t.length; r++) {
    const i = e10(t[r]);
    i !== null && n.push(i);
  }
  return n;
});
function Fa(e10, ...t) {
  let n = null;
  const r = Na((i, s) => {
    const o = [];
    return rt(s, (l) => {
      for (let f; (f = i(l)) && !(n == null ? void 0 : n(f, o.length)); l = f)
        o.push(f);
    }), o;
  })(e10, ...t);
  return function(i, s) {
    n = typeof i == "string" ? (l) => z1(l, i, this.options) : i ? es(i) : null;
    const o = r.call(this, s);
    return n = null, o;
  };
}
function si(e10) {
  return e10.length > 1 ? Array.from(new Set(e10)) : e10;
}
var _6 = Ia(({ parent: e10 }) => e10 && !_r(e10) ? e10 : null, si);
var S6 = Qi((e10) => {
  const t = [];
  for (; e10.parent && !_r(e10.parent); )
    t.push(e10.parent), e10 = e10.parent;
  return t;
}, ii, (e10) => e10.reverse());
var A6 = Fa(({ parent: e10 }) => e10 && !_r(e10) ? e10 : null, ii, (e10) => e10.reverse());
function E6(e10) {
  var t;
  const n = [];
  if (!e10)
    return this._make(n);
  const r = {
    xmlMode: this.options.xmlMode,
    root: (t = this._root) === null || t === void 0 ? void 0 : t[0]
  }, i = typeof e10 == "string" ? (s) => z1(s, e10, r) : es(e10);
  return rt(this, (s) => {
    for (s && !_r(s) && !ke(s) && (s = s.parent); s && ke(s); ) {
      if (i(s, 0)) {
        n.includes(s) || n.push(s);
        break;
      }
      s = s.parent;
    }
  }), this._make(n);
}
var C6 = Ia((e10) => _a(e10));
var T6 = Qi((e10) => {
  const t = [];
  for (; e10.next; )
    e10 = e10.next, ke(e10) && t.push(e10);
  return t;
}, si);
var D6 = Fa((e10) => _a(e10), si);
var M6 = Ia((e10) => Sa(e10));
var N6 = Qi((e10) => {
  const t = [];
  for (; e10.prev; )
    e10 = e10.prev, ke(e10) && t.push(e10);
  return t;
}, si);
var I6 = Fa((e10) => Sa(e10), si);
var F6 = Qi((e10) => p1(e10).filter((t) => ke(t) && t !== e10), ii);
var B6 = Qi((e10) => O0(e10).filter(ke), si);
function O6() {
  const e10 = this.toArray().reduce((t, n) => xt(n) ? t.concat(n.children) : t, []);
  return this._make(e10);
}
function z6(e10) {
  let t = 0;
  const n = this.length;
  for (; t < n && e10.call(this[t], t, this[t]) !== false; )
    ++t;
  return this;
}
function $6(e10) {
  let t = [];
  for (let n = 0; n < this.length; n++) {
    const r = this[n], i = e10.call(r, n, r);
    i != null && (t = t.concat(i));
  }
  return this._make(t);
}
function es(e10) {
  return typeof e10 == "function" ? (t, n) => e10.call(t, n, t) : On(e10) ? (t) => Array.prototype.includes.call(e10, t) : function(t) {
    return e10 === t;
  };
}
function L6(e10) {
  var t;
  return this._make(Ba(this.toArray(), e10, this.options.xmlMode, (t = this._root) === null || t === void 0 ? void 0 : t[0]));
}
function Ba(e10, t, n, r) {
  return typeof t == "string" ? L1(t, e10, { xmlMode: n, root: r }) : e10.filter(es(t));
}
function q6(e10) {
  const t = this.toArray();
  return typeof e10 == "string" ? $1(t.filter(ke), e10, this.options) : e10 ? t.some(es(e10)) : false;
}
function R6(e10) {
  let t = this.toArray();
  if (typeof e10 == "string") {
    const n = new Set(L1(e10, t, this.options));
    t = t.filter((r) => !n.has(r));
  } else {
    const n = es(e10);
    t = t.filter((r, i) => !n(r, i));
  }
  return this._make(t);
}
function P6(e10) {
  return this.filter(typeof e10 == "string" ? (
    // Using the `:has` selector here short-circuits searches.
    `:has(${e10})`
  ) : (t, n) => this._make(n).find(e10).length > 0);
}
function H6() {
  return this.length > 1 ? this._make(this[0]) : this;
}
function j6() {
  return this.length > 0 ? this._make(this[this.length - 1]) : this;
}
function U6(e10) {
  var t;
  return e10 = +e10, e10 === 0 && this.length <= 1 ? this : (e10 < 0 && (e10 = this.length + e10), this._make((t = this[e10]) !== null && t !== void 0 ? t : []));
}
function V6(e10) {
  return e10 == null ? this.toArray() : this[e10 < 0 ? this.length + e10 : e10];
}
function G6() {
  return Array.prototype.slice.call(this);
}
function W6(e10) {
  let t, n;
  return e10 == null ? (t = this.parent().children(), n = this[0]) : typeof e10 == "string" ? (t = this._make(e10), n = this[0]) : (t = this, n = On(e10) ? e10[0] : e10), Array.prototype.indexOf.call(t, n);
}
function K6(e10, t) {
  return this._make(Array.prototype.slice.call(this, e10, t));
}
function X6() {
  var e10;
  return (e10 = this.prevObject) !== null && e10 !== void 0 ? e10 : this._make([]);
}
function Y6(e10, t) {
  const n = this._make(e10, t), r = ii([...this.get(), ...n.get()]);
  return this._make(r);
}
function Z6(e10) {
  return this.prevObject ? this.add(e10 ? this.prevObject.filter(e10) : this.prevObject) : this;
}
var J6 = Object.freeze(Object.defineProperty({
  __proto__: null,
  _findBySelector: k6,
  add: Y6,
  addBack: Z6,
  children: B6,
  closest: E6,
  contents: O6,
  each: z6,
  end: X6,
  eq: U6,
  filter: L6,
  filterArray: Ba,
  find: v6,
  first: H6,
  get: V6,
  has: P6,
  index: W6,
  is: q6,
  last: j6,
  map: $6,
  next: C6,
  nextAll: T6,
  nextUntil: D6,
  not: R6,
  parent: _6,
  parents: S6,
  parentsUntil: A6,
  prev: M6,
  prevAll: N6,
  prevUntil: I6,
  siblings: F6,
  slice: K6,
  toArray: G6
}, Symbol.toStringTag, { value: "Module" }));
function Q6(e10) {
  return function(n, r, i, s) {
    if (typeof Buffer < "u" && Buffer.isBuffer(n) && (n = n.toString()), typeof n == "string")
      return e10(n, r, i, s);
    const o = n;
    if (!Array.isArray(o) && _r(o))
      return o;
    const l = new $i([]);
    return xr(o, l), l;
  };
}
function xr(e10, t) {
  const n = Array.isArray(e10) ? e10 : [e10];
  t ? t.children = n : t = null;
  for (let r = 0; r < n.length; r++) {
    const i = n[r];
    i.parent && i.parent.children !== n && Sr(i), t ? (i.prev = n[r - 1] || null, i.next = n[r + 1] || null) : i.prev = i.next = null, i.parent = t;
  }
  return t;
}
function e5(e10, t) {
  if (e10 == null)
    return [];
  if (typeof e10 == "string")
    return this._parse(e10, this.options, false, null).children.slice(0);
  if ("length" in e10) {
    if (e10.length === 1)
      return this._makeDomArray(e10[0], t);
    const n = [];
    for (let r = 0; r < e10.length; r++) {
      const i = e10[r];
      if (typeof i == "object") {
        if (i == null)
          continue;
        if (!("length" in i)) {
          n.push(t ? Li(i, true) : i);
          continue;
        }
      }
      n.push(...this._makeDomArray(i, t));
    }
    return n;
  }
  return [t ? Li(e10, true) : e10];
}
function H1(e10) {
  return function(...t) {
    const n = this.length - 1;
    return rt(this, (r, i) => {
      if (!xt(r))
        return;
      const s = typeof t[0] == "function" ? t[0].call(r, i, this._render(r.children)) : t, o = this._makeDomArray(s, i < n);
      e10(o, r.children, r);
    });
  };
}
function nr(e10, t, n, r, i) {
  var s, o;
  const l = [
    t,
    n,
    ...r
  ], f = t === 0 ? null : e10[t - 1], h2 = t + n >= e10.length ? null : e10[t + n];
  for (let p = 0; p < r.length; ++p) {
    const b = r[p], v = b.parent;
    if (v) {
      const w = v.children.indexOf(b);
      w > -1 && (v.children.splice(w, 1), i === v && t > w && l[0]--);
    }
    b.parent = i, b.prev && (b.prev.next = (s = b.next) !== null && s !== void 0 ? s : null), b.next && (b.next.prev = (o = b.prev) !== null && o !== void 0 ? o : null), b.prev = p === 0 ? f : r[p - 1], b.next = p === r.length - 1 ? h2 : r[p + 1];
  }
  return f && (f.next = r[0]), h2 && (h2.prev = r[r.length - 1]), e10.splice(...l);
}
function t5(e10) {
  return (On(e10) ? e10 : this._make(e10)).append(this), this;
}
function n5(e10) {
  return (On(e10) ? e10 : this._make(e10)).prepend(this), this;
}
var r5 = H1((e10, t, n) => {
  nr(t, t.length, 0, e10, n);
});
var i5 = H1((e10, t, n) => {
  nr(t, 0, 0, e10, n);
});
function j1(e10) {
  return function(t) {
    const n = this.length - 1, r = this.parents().last();
    for (let i = 0; i < this.length; i++) {
      const s = this[i], o = typeof t == "function" ? t.call(s, i, s) : typeof t == "string" && !$o(t) ? r.find(t).clone() : t, [l] = this._makeDomArray(o, i < n);
      if (!l || !xt(l))
        continue;
      let f = l, h2 = 0;
      for (; h2 < f.children.length; ) {
        const p = f.children[h2];
        ke(p) ? (f = p, h2 = 0) : h2++;
      }
      e10(s, f, [l]);
    }
    return this;
  };
}
var s5 = j1((e10, t, n) => {
  const { parent: r } = e10;
  if (!r)
    return;
  const i = r.children, s = i.indexOf(e10);
  xr([e10], t), nr(i, s, 0, n, r);
});
var u5 = j1((e10, t, n) => {
  xt(e10) && (xr(e10.children, t), xr(n, e10));
});
function o5(e10) {
  return this.parent(e10).not("body").each((t, n) => {
    this._make(n).replaceWith(n.children);
  }), this;
}
function a5(e10) {
  const t = this[0];
  if (t) {
    const n = this._make(typeof e10 == "function" ? e10.call(t, 0, t) : e10).insertBefore(t);
    let r;
    for (let s = 0; s < n.length; s++)
      n[s].type === "tag" && (r = n[s]);
    let i = 0;
    for (; r && i < r.children.length; ) {
      const s = r.children[i];
      s.type === "tag" ? (r = s, i = 0) : i++;
    }
    r && this._make(r).append(this);
  }
  return this;
}
function l5(...e10) {
  const t = this.length - 1;
  return rt(this, (n, r) => {
    if (!xt(n) || !n.parent)
      return;
    const i = n.parent.children, s = i.indexOf(n);
    if (s < 0)
      return;
    const o = typeof e10[0] == "function" ? e10[0].call(n, r, this._render(n.children)) : e10, l = this._makeDomArray(o, r < t);
    nr(i, s + 1, 0, l, n.parent);
  });
}
function c5(e10) {
  typeof e10 == "string" && (e10 = this._make(e10)), this.remove();
  const t = [];
  for (const n of this._makeDomArray(e10)) {
    const r = this.clone().toArray(), { parent: i } = n;
    if (!i)
      continue;
    const s = i.children, o = s.indexOf(n);
    o < 0 || (nr(s, o + 1, 0, r, i), t.push(...r));
  }
  return this._make(t);
}
function f5(...e10) {
  const t = this.length - 1;
  return rt(this, (n, r) => {
    if (!xt(n) || !n.parent)
      return;
    const i = n.parent.children, s = i.indexOf(n);
    if (s < 0)
      return;
    const o = typeof e10[0] == "function" ? e10[0].call(n, r, this._render(n.children)) : e10, l = this._makeDomArray(o, r < t);
    nr(i, s, 0, l, n.parent);
  });
}
function h5(e10) {
  const t = this._make(e10);
  this.remove();
  const n = [];
  return rt(t, (r) => {
    const i = this.clone().toArray(), { parent: s } = r;
    if (!s)
      return;
    const o = s.children, l = o.indexOf(r);
    l < 0 || (nr(o, l, 0, i, s), n.push(...i));
  }), this._make(n);
}
function d5(e10) {
  const t = e10 ? this.filter(e10) : this;
  return rt(t, (n) => {
    Sr(n), n.prev = n.next = n.parent = null;
  }), this;
}
function p5(e10) {
  return rt(this, (t, n) => {
    const { parent: r } = t;
    if (!r)
      return;
    const i = r.children, s = typeof e10 == "function" ? e10.call(t, n, t) : e10, o = this._makeDomArray(s);
    xr(o, null);
    const l = i.indexOf(t);
    nr(i, l, 1, o, r), o.includes(t) || (t.parent = t.prev = t.next = null);
  });
}
function m5() {
  return rt(this, (e10) => {
    if (xt(e10)) {
      for (const t of e10.children)
        t.next = t.prev = t.parent = null;
      e10.children.length = 0;
    }
  });
}
function g5(e10) {
  if (e10 === void 0) {
    const t = this[0];
    return !t || !xt(t) ? null : this._render(t.children);
  }
  return rt(this, (t) => {
    if (!xt(t))
      return;
    for (const r of t.children)
      r.next = r.prev = r.parent = null;
    const n = On(e10) ? e10.toArray() : this._parse(`${e10}`, this.options, false, t).children;
    xr(n, t);
  });
}
function b5() {
  return this._render(this);
}
function y5(e10) {
  return e10 === void 0 ? qi(this) : typeof e10 == "function" ? rt(this, (t, n) => this._make(t).text(e10.call(t, n, qi([t])))) : rt(this, (t) => {
    if (!xt(t))
      return;
    for (const r of t.children)
      r.next = r.prev = r.parent = null;
    const n = new c0(`${e10}`);
    xr(n, t);
  });
}
function x5() {
  const e10 = Array.prototype.map.call(this.get(), (n) => Li(n, true)), t = new $i(e10);
  for (const n of e10)
    n.parent = t;
  return this._make(e10);
}
var w5 = Object.freeze(Object.defineProperty({
  __proto__: null,
  _makeDomArray: e5,
  after: l5,
  append: r5,
  appendTo: t5,
  before: f5,
  clone: x5,
  empty: m5,
  html: g5,
  insertAfter: c5,
  insertBefore: h5,
  prepend: i5,
  prependTo: n5,
  remove: d5,
  replaceWith: p5,
  text: y5,
  toString: b5,
  unwrap: o5,
  wrap: s5,
  wrapAll: a5,
  wrapInner: u5
}, Symbol.toStringTag, { value: "Module" }));
function v5(e10, t) {
  if (e10 != null && t != null || // When `prop` is a "plain" object
  typeof e10 == "object" && !Array.isArray(e10))
    return rt(this, (n, r) => {
      ke(n) && U1(n, e10, t, r);
    });
  if (this.length !== 0)
    return V1(this[0], e10);
}
function U1(e10, t, n, r) {
  if (typeof t == "string") {
    const i = V1(e10), s = typeof n == "function" ? n.call(e10, r, i[t]) : n;
    s === "" ? delete i[t] : s != null && (i[t] = s), e10.attribs.style = k5(i);
  } else if (typeof t == "object") {
    const i = Object.keys(t);
    for (let s = 0; s < i.length; s++) {
      const o = i[s];
      U1(e10, o, t[o], s);
    }
  }
}
function V1(e10, t) {
  if (!e10 || !ke(e10))
    return;
  const n = _5(e10.attribs.style);
  if (typeof t == "string")
    return n[t];
  if (Array.isArray(t)) {
    const r = {};
    for (const i of t)
      n[i] != null && (r[i] = n[i]);
    return r;
  }
  return n;
}
function k5(e10) {
  return Object.keys(e10).reduce((t, n) => `${t}${t ? " " : ""}${n}: ${e10[n]};`, "");
}
function _5(e10) {
  if (e10 = (e10 || "").trim(), !e10)
    return {};
  const t = {};
  let n;
  for (const r of e10.split(";")) {
    const i = r.indexOf(":");
    if (i < 1 || i === r.length - 1) {
      const s = r.trimEnd();
      s.length > 0 && n !== void 0 && (t[n] += `;${s}`);
    } else
      n = r.slice(0, i).trim(), t[n] = r.slice(i + 1).trim();
  }
  return t;
}
var S5 = Object.freeze(Object.defineProperty({
  __proto__: null,
  css: v5
}, Symbol.toStringTag, { value: "Module" }));
var mf = "input,select,textarea,keygen";
var A5 = /%20/g;
var gf = /\r?\n/g;
function E5() {
  return this.serializeArray().map((n) => `${encodeURIComponent(n.name)}=${encodeURIComponent(n.value)}`).join("&").replace(A5, "+");
}
function C5() {
  return this.map((e10, t) => {
    const n = this._make(t);
    return ke(t) && t.name === "form" ? n.find(mf).toArray() : n.filter(mf).toArray();
  }).filter(
    // Verify elements have a name (`attr.name`) and are not disabled (`:enabled`)
    '[name!=""]:enabled:not(:submit, :button, :image, :reset, :file):matches([checked], :not(:checkbox, :radio))'
  ).map((e10, t) => {
    var n;
    const r = this._make(t), i = r.attr("name"), s = (n = r.val()) !== null && n !== void 0 ? n : "";
    return Array.isArray(s) ? s.map((o) => (
      /*
       * We trim replace any line endings (e.g. `\r` or `\r\n` with `\r\n`) to guarantee consistency across platforms
       * These can occur inside of `<textarea>'s`
       */
      { name: i, value: o.replace(gf, `\r
`) }
    )) : { name: i, value: s.replace(gf, `\r
`) };
  }).toArray();
}
var T5 = Object.freeze(Object.defineProperty({
  __proto__: null,
  serialize: E5,
  serializeArray: C5
}, Symbol.toStringTag, { value: "Module" }));
function D5(e10) {
  var t;
  return typeof e10 == "string" ? { selector: e10, value: "textContent" } : {
    selector: e10.selector,
    value: (t = e10.value) !== null && t !== void 0 ? t : "textContent"
  };
}
function M5(e10) {
  const t = {};
  for (const n in e10) {
    const r = e10[n], i = Array.isArray(r), { selector: s, value: o } = D5(i ? r[0] : r), l = typeof o == "function" ? o : typeof o == "string" ? (f) => this._make(f).prop(o) : (f) => this._make(f).extract(o);
    if (i)
      t[n] = this._findBySelector(s, Number.POSITIVE_INFINITY).map((f, h2) => l(h2, n, t)).get();
    else {
      const f = this._findBySelector(s, 1);
      t[n] = f.length > 0 ? l(f[0], n, t) : void 0;
    }
  }
  return t;
}
var N5 = Object.freeze(Object.defineProperty({
  __proto__: null,
  extract: M5
}, Symbol.toStringTag, { value: "Module" }));
var ts = class {
  /**
   * Instance of cheerio. Methods are specified in the modules. Usage of this
   * constructor is not recommended. Please use `$.load` instead.
   *
   * @private
   * @param elements - The new selection.
   * @param root - Sets the root node.
   * @param options - Options for the instance.
   */
  constructor(t, n, r) {
    if (this.length = 0, this.options = r, this._root = n, t) {
      for (let i = 0; i < t.length; i++)
        this[i] = t[i];
      this.length = t.length;
    }
  }
};
ts.prototype.cheerio = "[cheerio object]";
ts.prototype.splice = Array.prototype.splice;
ts.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
Object.assign(ts.prototype, z3, J6, w5, S5, T5, N5);
function I5(e10, t) {
  return function n(r, i, s = true) {
    if (r == null)
      throw new Error("cheerio.load() expects a string");
    const o = Bo(i), l = e10(r, o, s, null);
    class f extends ts {
      _make(b, v) {
        const k = h2(b, v);
        return k.prevObject = this, k;
      }
      _parse(b, v, k, w) {
        return e10(b, v, k, w);
      }
      _render(b) {
        return t(b, this.options);
      }
    }
    function h2(p, b, v = l, k) {
      if (p && On(p))
        return p;
      const w = Bo(k, o), A = typeof v == "string" ? [e10(v, w, false, null)] : "length" in v ? v : [v], T = On(A) ? A : new f(A, null, w);
      if (T._root = T, !p)
        return new f(void 0, T, w);
      const D = typeof p == "string" && $o(p) ? (
        // $(<html>)
        e10(p, w, false, null).children
      ) : F5(p) ? (
        // $(dom)
        [p]
      ) : Array.isArray(p) ? (
        // $([dom])
        p
      ) : void 0, N = new f(D, T, w);
      if (D)
        return N;
      if (typeof p != "string")
        throw new TypeError("Unexpected type of selector");
      let O = p;
      const q = b ? (
        // If we don't have a context, maybe we have a root, from loading
        typeof b == "string" ? $o(b) ? (
          // $('li', '<ul>...</ul>')
          new f([e10(b, w, false, null)], T, w)
        ) : (
          // $('li', 'ul')
          (O = `${b} ${O}`, T)
        ) : On(b) ? (
          // $('li', $)
          b
        ) : (
          // $('li', node), $('li', [nodes])
          new f(Array.isArray(b) ? b : [b], T, w)
        )
      ) : T;
      return q ? q.find(O) : N;
    }
    return Object.assign(h2, S3, {
      load: n,
      // `_root` and `_options` are used in static methods.
      _root: l,
      _options: o,
      // Add `fn` for plugins
      fn: f.prototype,
      // Add the prototype here to maintain `instanceof` behavior.
      prototype: f.prototype
    }), h2;
  };
}
function F5(e10) {
  return !!e10.name || e10.type === "root" || e10.type === "text" || e10.type === "comment";
}
var we;
(function(e10) {
  e10[e10.Tab = 9] = "Tab", e10[e10.NewLine = 10] = "NewLine", e10[e10.FormFeed = 12] = "FormFeed", e10[e10.CarriageReturn = 13] = "CarriageReturn", e10[e10.Space = 32] = "Space", e10[e10.ExclamationMark = 33] = "ExclamationMark", e10[e10.Number = 35] = "Number", e10[e10.Amp = 38] = "Amp", e10[e10.SingleQuote = 39] = "SingleQuote", e10[e10.DoubleQuote = 34] = "DoubleQuote", e10[e10.Dash = 45] = "Dash", e10[e10.Slash = 47] = "Slash", e10[e10.Zero = 48] = "Zero", e10[e10.Nine = 57] = "Nine", e10[e10.Semi = 59] = "Semi", e10[e10.Lt = 60] = "Lt", e10[e10.Eq = 61] = "Eq", e10[e10.Gt = 62] = "Gt", e10[e10.Questionmark = 63] = "Questionmark", e10[e10.UpperA = 65] = "UpperA", e10[e10.LowerA = 97] = "LowerA", e10[e10.UpperF = 70] = "UpperF", e10[e10.LowerF = 102] = "LowerF", e10[e10.UpperZ = 90] = "UpperZ", e10[e10.LowerZ = 122] = "LowerZ", e10[e10.LowerX = 120] = "LowerX", e10[e10.OpeningSquareBracket = 91] = "OpeningSquareBracket";
})(we || (we = {}));
var ue;
(function(e10) {
  e10[e10.Text = 1] = "Text", e10[e10.BeforeTagName = 2] = "BeforeTagName", e10[e10.InTagName = 3] = "InTagName", e10[e10.InSelfClosingTag = 4] = "InSelfClosingTag", e10[e10.BeforeClosingTagName = 5] = "BeforeClosingTagName", e10[e10.InClosingTagName = 6] = "InClosingTagName", e10[e10.AfterClosingTagName = 7] = "AfterClosingTagName", e10[e10.BeforeAttributeName = 8] = "BeforeAttributeName", e10[e10.InAttributeName = 9] = "InAttributeName", e10[e10.AfterAttributeName = 10] = "AfterAttributeName", e10[e10.BeforeAttributeValue = 11] = "BeforeAttributeValue", e10[e10.InAttributeValueDq = 12] = "InAttributeValueDq", e10[e10.InAttributeValueSq = 13] = "InAttributeValueSq", e10[e10.InAttributeValueNq = 14] = "InAttributeValueNq", e10[e10.BeforeDeclaration = 15] = "BeforeDeclaration", e10[e10.InDeclaration = 16] = "InDeclaration", e10[e10.InProcessingInstruction = 17] = "InProcessingInstruction", e10[e10.BeforeComment = 18] = "BeforeComment", e10[e10.CDATASequence = 19] = "CDATASequence", e10[e10.InSpecialComment = 20] = "InSpecialComment", e10[e10.InCommentLike = 21] = "InCommentLike", e10[e10.BeforeSpecialS = 22] = "BeforeSpecialS", e10[e10.BeforeSpecialT = 23] = "BeforeSpecialT", e10[e10.SpecialStartSequence = 24] = "SpecialStartSequence", e10[e10.InSpecialTag = 25] = "InSpecialTag", e10[e10.InEntity = 26] = "InEntity";
})(ue || (ue = {}));
function Nn(e10) {
  return e10 === we.Space || e10 === we.NewLine || e10 === we.Tab || e10 === we.FormFeed || e10 === we.CarriageReturn;
}
function Os(e10) {
  return e10 === we.Slash || e10 === we.Gt || Nn(e10);
}
function B5(e10) {
  return e10 >= we.LowerA && e10 <= we.LowerZ || e10 >= we.UpperA && e10 <= we.UpperZ;
}
var fn;
(function(e10) {
  e10[e10.NoValue = 0] = "NoValue", e10[e10.Unquoted = 1] = "Unquoted", e10[e10.Single = 2] = "Single", e10[e10.Double = 3] = "Double";
})(fn || (fn = {}));
var wt = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  // CDATA[
  CdataEnd: new Uint8Array([93, 93, 62]),
  // ]]>
  CommentEnd: new Uint8Array([45, 45, 62]),
  // `-->`
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  // `<\/script`
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  // `</style`
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
  // `</title`
  TextareaEnd: new Uint8Array([
    60,
    47,
    116,
    101,
    120,
    116,
    97,
    114,
    101,
    97
  ])
  // `</textarea`
};
var O5 = class {
  constructor({ xmlMode: t = false, decodeEntities: n = true }, r) {
    this.cbs = r, this.state = ue.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.entityStart = 0, this.baseState = ue.Text, this.isSpecial = false, this.running = true, this.offset = 0, this.currentSequence = void 0, this.sequenceIndex = 0, this.xmlMode = t, this.decodeEntities = n, this.entityDecoder = new a1(t ? o1 : u1, (i, s) => this.emitCodePoint(i, s));
  }
  reset() {
    this.state = ue.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = ue.Text, this.currentSequence = void 0, this.running = true, this.offset = 0;
  }
  write(t) {
    this.offset += this.buffer.length, this.buffer = t, this.parse();
  }
  end() {
    this.running && this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true, this.index < this.buffer.length + this.offset && this.parse();
  }
  stateText(t) {
    t === we.Lt || !this.decodeEntities && this.fastForwardTo(we.Lt) ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = ue.BeforeTagName, this.sectionStart = this.index) : this.decodeEntities && t === we.Amp && this.startEntity();
  }
  stateSpecialStartSequence(t) {
    const n = this.sequenceIndex === this.currentSequence.length;
    if (!(n ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      Os(t)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (t | 32) === this.currentSequence[this.sequenceIndex]
    )))
      this.isSpecial = false;
    else if (!n) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0, this.state = ue.InTagName, this.stateInTagName(t);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(t) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (t === we.Gt || Nn(t)) {
        const n = this.index - this.currentSequence.length;
        if (this.sectionStart < n) {
          const r = this.index;
          this.index = n, this.cbs.ontext(this.sectionStart, n), this.index = r;
        }
        this.isSpecial = false, this.sectionStart = n + 2, this.stateInClosingTagName(t);
        return;
      }
      this.sequenceIndex = 0;
    }
    (t | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === wt.TitleEnd ? this.decodeEntities && t === we.Amp && this.startEntity() : this.fastForwardTo(we.Lt) && (this.sequenceIndex = 1) : this.sequenceIndex = +(t === we.Lt);
  }
  stateCDATASequence(t) {
    t === wt.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === wt.Cdata.length && (this.state = ue.InCommentLike, this.currentSequence = wt.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = ue.InDeclaration, this.stateInDeclaration(t));
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(t) {
    for (; ++this.index < this.buffer.length + this.offset; )
      if (this.buffer.charCodeAt(this.index - this.offset) === t)
        return true;
    return this.index = this.buffer.length + this.offset - 1, false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(t) {
    t === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === wt.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index, 2) : this.cbs.oncomment(this.sectionStart, this.index, 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = ue.Text) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : t !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(t) {
    return this.xmlMode ? !Os(t) : B5(t);
  }
  startSpecial(t, n) {
    this.isSpecial = true, this.currentSequence = t, this.sequenceIndex = n, this.state = ue.SpecialStartSequence;
  }
  stateBeforeTagName(t) {
    if (t === we.ExclamationMark)
      this.state = ue.BeforeDeclaration, this.sectionStart = this.index + 1;
    else if (t === we.Questionmark)
      this.state = ue.InProcessingInstruction, this.sectionStart = this.index + 1;
    else if (this.isTagStartChar(t)) {
      const n = t | 32;
      this.sectionStart = this.index, this.xmlMode ? this.state = ue.InTagName : n === wt.ScriptEnd[2] ? this.state = ue.BeforeSpecialS : n === wt.TitleEnd[2] ? this.state = ue.BeforeSpecialT : this.state = ue.InTagName;
    } else t === we.Slash ? this.state = ue.BeforeClosingTagName : (this.state = ue.Text, this.stateText(t));
  }
  stateInTagName(t) {
    Os(t) && (this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = ue.BeforeAttributeName, this.stateBeforeAttributeName(t));
  }
  stateBeforeClosingTagName(t) {
    Nn(t) || (t === we.Gt ? this.state = ue.Text : (this.state = this.isTagStartChar(t) ? ue.InClosingTagName : ue.InSpecialComment, this.sectionStart = this.index));
  }
  stateInClosingTagName(t) {
    (t === we.Gt || Nn(t)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = ue.AfterClosingTagName, this.stateAfterClosingTagName(t));
  }
  stateAfterClosingTagName(t) {
    (t === we.Gt || this.fastForwardTo(we.Gt)) && (this.state = ue.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeAttributeName(t) {
    t === we.Gt ? (this.cbs.onopentagend(this.index), this.isSpecial ? (this.state = ue.InSpecialTag, this.sequenceIndex = 0) : this.state = ue.Text, this.sectionStart = this.index + 1) : t === we.Slash ? this.state = ue.InSelfClosingTag : Nn(t) || (this.state = ue.InAttributeName, this.sectionStart = this.index);
  }
  stateInSelfClosingTag(t) {
    t === we.Gt ? (this.cbs.onselfclosingtag(this.index), this.state = ue.Text, this.sectionStart = this.index + 1, this.isSpecial = false) : Nn(t) || (this.state = ue.BeforeAttributeName, this.stateBeforeAttributeName(t));
  }
  stateInAttributeName(t) {
    (t === we.Eq || Os(t)) && (this.cbs.onattribname(this.sectionStart, this.index), this.sectionStart = this.index, this.state = ue.AfterAttributeName, this.stateAfterAttributeName(t));
  }
  stateAfterAttributeName(t) {
    t === we.Eq ? this.state = ue.BeforeAttributeValue : t === we.Slash || t === we.Gt ? (this.cbs.onattribend(fn.NoValue, this.sectionStart), this.sectionStart = -1, this.state = ue.BeforeAttributeName, this.stateBeforeAttributeName(t)) : Nn(t) || (this.cbs.onattribend(fn.NoValue, this.sectionStart), this.state = ue.InAttributeName, this.sectionStart = this.index);
  }
  stateBeforeAttributeValue(t) {
    t === we.DoubleQuote ? (this.state = ue.InAttributeValueDq, this.sectionStart = this.index + 1) : t === we.SingleQuote ? (this.state = ue.InAttributeValueSq, this.sectionStart = this.index + 1) : Nn(t) || (this.sectionStart = this.index, this.state = ue.InAttributeValueNq, this.stateInAttributeValueNoQuotes(t));
  }
  handleInAttributeValue(t, n) {
    t === n || !this.decodeEntities && this.fastForwardTo(n) ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(n === we.DoubleQuote ? fn.Double : fn.Single, this.index + 1), this.state = ue.BeforeAttributeName) : this.decodeEntities && t === we.Amp && this.startEntity();
  }
  stateInAttributeValueDoubleQuotes(t) {
    this.handleInAttributeValue(t, we.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(t) {
    this.handleInAttributeValue(t, we.SingleQuote);
  }
  stateInAttributeValueNoQuotes(t) {
    Nn(t) || t === we.Gt ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(fn.Unquoted, this.index), this.state = ue.BeforeAttributeName, this.stateBeforeAttributeName(t)) : this.decodeEntities && t === we.Amp && this.startEntity();
  }
  stateBeforeDeclaration(t) {
    t === we.OpeningSquareBracket ? (this.state = ue.CDATASequence, this.sequenceIndex = 0) : this.state = t === we.Dash ? ue.BeforeComment : ue.InDeclaration;
  }
  stateInDeclaration(t) {
    (t === we.Gt || this.fastForwardTo(we.Gt)) && (this.cbs.ondeclaration(this.sectionStart, this.index), this.state = ue.Text, this.sectionStart = this.index + 1);
  }
  stateInProcessingInstruction(t) {
    (t === we.Gt || this.fastForwardTo(we.Gt)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = ue.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeComment(t) {
    t === we.Dash ? (this.state = ue.InCommentLike, this.currentSequence = wt.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = ue.InDeclaration;
  }
  stateInSpecialComment(t) {
    (t === we.Gt || this.fastForwardTo(we.Gt)) && (this.cbs.oncomment(this.sectionStart, this.index, 0), this.state = ue.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeSpecialS(t) {
    const n = t | 32;
    n === wt.ScriptEnd[3] ? this.startSpecial(wt.ScriptEnd, 4) : n === wt.StyleEnd[3] ? this.startSpecial(wt.StyleEnd, 4) : (this.state = ue.InTagName, this.stateInTagName(t));
  }
  stateBeforeSpecialT(t) {
    const n = t | 32;
    n === wt.TitleEnd[3] ? this.startSpecial(wt.TitleEnd, 4) : n === wt.TextareaEnd[3] ? this.startSpecial(wt.TextareaEnd, 4) : (this.state = ue.InTagName, this.stateInTagName(t));
  }
  startEntity() {
    this.baseState = this.state, this.state = ue.InEntity, this.entityStart = this.index, this.entityDecoder.startEntity(this.xmlMode ? cn.Strict : this.baseState === ue.Text || this.baseState === ue.InSpecialTag ? cn.Legacy : cn.Attribute);
  }
  stateInEntity() {
    const t = this.entityDecoder.write(this.buffer, this.index - this.offset);
    t >= 0 ? (this.state = this.baseState, t === 0 && (this.index = this.entityStart)) : this.index = this.offset + this.buffer.length - 1;
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    this.running && this.sectionStart !== this.index && (this.state === ue.Text || this.state === ue.InSpecialTag && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === ue.InAttributeValueDq || this.state === ue.InAttributeValueSq || this.state === ue.InAttributeValueNq) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    for (; this.shouldContinue(); ) {
      const t = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case ue.Text: {
          this.stateText(t);
          break;
        }
        case ue.SpecialStartSequence: {
          this.stateSpecialStartSequence(t);
          break;
        }
        case ue.InSpecialTag: {
          this.stateInSpecialTag(t);
          break;
        }
        case ue.CDATASequence: {
          this.stateCDATASequence(t);
          break;
        }
        case ue.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(t);
          break;
        }
        case ue.InAttributeName: {
          this.stateInAttributeName(t);
          break;
        }
        case ue.InCommentLike: {
          this.stateInCommentLike(t);
          break;
        }
        case ue.InSpecialComment: {
          this.stateInSpecialComment(t);
          break;
        }
        case ue.BeforeAttributeName: {
          this.stateBeforeAttributeName(t);
          break;
        }
        case ue.InTagName: {
          this.stateInTagName(t);
          break;
        }
        case ue.InClosingTagName: {
          this.stateInClosingTagName(t);
          break;
        }
        case ue.BeforeTagName: {
          this.stateBeforeTagName(t);
          break;
        }
        case ue.AfterAttributeName: {
          this.stateAfterAttributeName(t);
          break;
        }
        case ue.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(t);
          break;
        }
        case ue.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(t);
          break;
        }
        case ue.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(t);
          break;
        }
        case ue.AfterClosingTagName: {
          this.stateAfterClosingTagName(t);
          break;
        }
        case ue.BeforeSpecialS: {
          this.stateBeforeSpecialS(t);
          break;
        }
        case ue.BeforeSpecialT: {
          this.stateBeforeSpecialT(t);
          break;
        }
        case ue.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(t);
          break;
        }
        case ue.InSelfClosingTag: {
          this.stateInSelfClosingTag(t);
          break;
        }
        case ue.InDeclaration: {
          this.stateInDeclaration(t);
          break;
        }
        case ue.BeforeDeclaration: {
          this.stateBeforeDeclaration(t);
          break;
        }
        case ue.BeforeComment: {
          this.stateBeforeComment(t);
          break;
        }
        case ue.InProcessingInstruction: {
          this.stateInProcessingInstruction(t);
          break;
        }
        case ue.InEntity: {
          this.stateInEntity();
          break;
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    this.state === ue.InEntity && (this.entityDecoder.end(), this.state = this.baseState), this.handleTrailingData(), this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const t = this.buffer.length + this.offset;
    this.sectionStart >= t || (this.state === ue.InCommentLike ? this.currentSequence === wt.CdataEnd ? this.cbs.oncdata(this.sectionStart, t, 0) : this.cbs.oncomment(this.sectionStart, t, 0) : this.state === ue.InTagName || this.state === ue.BeforeAttributeName || this.state === ue.BeforeAttributeValue || this.state === ue.AfterAttributeName || this.state === ue.InAttributeName || this.state === ue.InAttributeValueSq || this.state === ue.InAttributeValueDq || this.state === ue.InAttributeValueNq || this.state === ue.InClosingTagName || this.cbs.ontext(this.sectionStart, t));
  }
  emitCodePoint(t, n) {
    this.baseState !== ue.Text && this.baseState !== ue.InSpecialTag ? (this.sectionStart < this.entityStart && this.cbs.onattribdata(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + n, this.index = this.sectionStart - 1, this.cbs.onattribentity(t)) : (this.sectionStart < this.entityStart && this.cbs.ontext(this.sectionStart, this.entityStart), this.sectionStart = this.entityStart + n, this.index = this.sectionStart - 1, this.cbs.ontextentity(t, this.sectionStart));
  }
};
var Dr = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
var Pe = /* @__PURE__ */ new Set(["p"]);
var bf = /* @__PURE__ */ new Set(["thead", "tbody"]);
var yf = /* @__PURE__ */ new Set(["dd", "dt"]);
var xf = /* @__PURE__ */ new Set(["rt", "rp"]);
var z5 = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", Pe],
  ["h1", Pe],
  ["h2", Pe],
  ["h3", Pe],
  ["h4", Pe],
  ["h5", Pe],
  ["h6", Pe],
  ["select", Dr],
  ["input", Dr],
  ["output", Dr],
  ["button", Dr],
  ["datalist", Dr],
  ["textarea", Dr],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", yf],
  ["dt", yf],
  ["address", Pe],
  ["article", Pe],
  ["aside", Pe],
  ["blockquote", Pe],
  ["details", Pe],
  ["div", Pe],
  ["dl", Pe],
  ["fieldset", Pe],
  ["figcaption", Pe],
  ["figure", Pe],
  ["footer", Pe],
  ["form", Pe],
  ["header", Pe],
  ["hr", Pe],
  ["main", Pe],
  ["nav", Pe],
  ["ol", Pe],
  ["pre", Pe],
  ["section", Pe],
  ["table", Pe],
  ["ul", Pe],
  ["rt", xf],
  ["rp", xf],
  ["tbody", bf],
  ["tfoot", bf]
]);
var $5 = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
var wf = /* @__PURE__ */ new Set(["math", "svg"]);
var vf = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
var L5 = /\s|\//;
var q5 = class {
  constructor(t, n = {}) {
    var r, i, s, o, l, f;
    this.options = n, this.startIndex = 0, this.endIndex = 0, this.openTagStart = 0, this.tagname = "", this.attribname = "", this.attribvalue = "", this.attribs = null, this.stack = [], this.buffers = [], this.bufferOffset = 0, this.writeIndex = 0, this.ended = false, this.cbs = t ?? {}, this.htmlMode = !this.options.xmlMode, this.lowerCaseTagNames = (r = n.lowerCaseTags) !== null && r !== void 0 ? r : this.htmlMode, this.lowerCaseAttributeNames = (i = n.lowerCaseAttributeNames) !== null && i !== void 0 ? i : this.htmlMode, this.recognizeSelfClosing = (s = n.recognizeSelfClosing) !== null && s !== void 0 ? s : !this.htmlMode, this.tokenizer = new ((o = n.Tokenizer) !== null && o !== void 0 ? o : O5)(this.options, this), this.foreignContext = [!this.htmlMode], (f = (l = this.cbs).onparserinit) === null || f === void 0 || f.call(l, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(t, n) {
    var r, i;
    const s = this.getSlice(t, n);
    this.endIndex = n - 1, (i = (r = this.cbs).ontext) === null || i === void 0 || i.call(r, s), this.startIndex = n;
  }
  /** @internal */
  ontextentity(t, n) {
    var r, i;
    this.endIndex = n - 1, (i = (r = this.cbs).ontext) === null || i === void 0 || i.call(r, Oo(t)), this.startIndex = n;
  }
  /**
   * Checks if the current tag is a void element. Override this if you want
   * to specify your own additional void elements.
   */
  isVoidElement(t) {
    return this.htmlMode && $5.has(t);
  }
  /** @internal */
  onopentagname(t, n) {
    this.endIndex = n;
    let r = this.getSlice(t, n);
    this.lowerCaseTagNames && (r = r.toLowerCase()), this.emitOpenTag(r);
  }
  emitOpenTag(t) {
    var n, r, i, s;
    this.openTagStart = this.startIndex, this.tagname = t;
    const o = this.htmlMode && z5.get(t);
    if (o)
      for (; this.stack.length > 0 && o.has(this.stack[0]); ) {
        const l = this.stack.shift();
        (r = (n = this.cbs).onclosetag) === null || r === void 0 || r.call(n, l, true);
      }
    this.isVoidElement(t) || (this.stack.unshift(t), this.htmlMode && (wf.has(t) ? this.foreignContext.unshift(true) : vf.has(t) && this.foreignContext.unshift(false))), (s = (i = this.cbs).onopentagname) === null || s === void 0 || s.call(i, t), this.cbs.onopentag && (this.attribs = {});
  }
  endOpenTag(t) {
    var n, r;
    this.startIndex = this.openTagStart, this.attribs && ((r = (n = this.cbs).onopentag) === null || r === void 0 || r.call(n, this.tagname, this.attribs, t), this.attribs = null), this.cbs.onclosetag && this.isVoidElement(this.tagname) && this.cbs.onclosetag(this.tagname, true), this.tagname = "";
  }
  /** @internal */
  onopentagend(t) {
    this.endIndex = t, this.endOpenTag(false), this.startIndex = t + 1;
  }
  /** @internal */
  onclosetag(t, n) {
    var r, i, s, o, l, f, h2, p;
    this.endIndex = n;
    let b = this.getSlice(t, n);
    if (this.lowerCaseTagNames && (b = b.toLowerCase()), this.htmlMode && (wf.has(b) || vf.has(b)) && this.foreignContext.shift(), this.isVoidElement(b))
      this.htmlMode && b === "br" && ((o = (s = this.cbs).onopentagname) === null || o === void 0 || o.call(s, "br"), (f = (l = this.cbs).onopentag) === null || f === void 0 || f.call(l, "br", {}, true), (p = (h2 = this.cbs).onclosetag) === null || p === void 0 || p.call(h2, "br", false));
    else {
      const v = this.stack.indexOf(b);
      if (v !== -1)
        for (let k = 0; k <= v; k++) {
          const w = this.stack.shift();
          (i = (r = this.cbs).onclosetag) === null || i === void 0 || i.call(r, w, k !== v);
        }
      else this.htmlMode && b === "p" && (this.emitOpenTag("p"), this.closeCurrentTag(true));
    }
    this.startIndex = n + 1;
  }
  /** @internal */
  onselfclosingtag(t) {
    this.endIndex = t, this.recognizeSelfClosing || this.foreignContext[0] ? (this.closeCurrentTag(false), this.startIndex = t + 1) : this.onopentagend(t);
  }
  closeCurrentTag(t) {
    var n, r;
    const i = this.tagname;
    this.endOpenTag(t), this.stack[0] === i && ((r = (n = this.cbs).onclosetag) === null || r === void 0 || r.call(n, i, !t), this.stack.shift());
  }
  /** @internal */
  onattribname(t, n) {
    this.startIndex = t;
    const r = this.getSlice(t, n);
    this.attribname = this.lowerCaseAttributeNames ? r.toLowerCase() : r;
  }
  /** @internal */
  onattribdata(t, n) {
    this.attribvalue += this.getSlice(t, n);
  }
  /** @internal */
  onattribentity(t) {
    this.attribvalue += Oo(t);
  }
  /** @internal */
  onattribend(t, n) {
    var r, i;
    this.endIndex = n, (i = (r = this.cbs).onattribute) === null || i === void 0 || i.call(r, this.attribname, this.attribvalue, t === fn.Double ? '"' : t === fn.Single ? "'" : t === fn.NoValue ? void 0 : null), this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue), this.attribvalue = "";
  }
  getInstructionName(t) {
    const n = t.search(L5);
    let r = n < 0 ? t : t.substr(0, n);
    return this.lowerCaseTagNames && (r = r.toLowerCase()), r;
  }
  /** @internal */
  ondeclaration(t, n) {
    this.endIndex = n;
    const r = this.getSlice(t, n);
    if (this.cbs.onprocessinginstruction) {
      const i = this.getInstructionName(r);
      this.cbs.onprocessinginstruction(`!${i}`, `!${r}`);
    }
    this.startIndex = n + 1;
  }
  /** @internal */
  onprocessinginstruction(t, n) {
    this.endIndex = n;
    const r = this.getSlice(t, n);
    if (this.cbs.onprocessinginstruction) {
      const i = this.getInstructionName(r);
      this.cbs.onprocessinginstruction(`?${i}`, `?${r}`);
    }
    this.startIndex = n + 1;
  }
  /** @internal */
  oncomment(t, n, r) {
    var i, s, o, l;
    this.endIndex = n, (s = (i = this.cbs).oncomment) === null || s === void 0 || s.call(i, this.getSlice(t, n - r)), (l = (o = this.cbs).oncommentend) === null || l === void 0 || l.call(o), this.startIndex = n + 1;
  }
  /** @internal */
  oncdata(t, n, r) {
    var i, s, o, l, f, h2, p, b, v, k;
    this.endIndex = n;
    const w = this.getSlice(t, n - r);
    !this.htmlMode || this.options.recognizeCDATA ? ((s = (i = this.cbs).oncdatastart) === null || s === void 0 || s.call(i), (l = (o = this.cbs).ontext) === null || l === void 0 || l.call(o, w), (h2 = (f = this.cbs).oncdataend) === null || h2 === void 0 || h2.call(f)) : ((b = (p = this.cbs).oncomment) === null || b === void 0 || b.call(p, `[CDATA[${w}]]`), (k = (v = this.cbs).oncommentend) === null || k === void 0 || k.call(v)), this.startIndex = n + 1;
  }
  /** @internal */
  onend() {
    var t, n;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let r = 0; r < this.stack.length; r++)
        this.cbs.onclosetag(this.stack[r], true);
    }
    (n = (t = this.cbs).onend) === null || n === void 0 || n.call(t);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var t, n, r, i;
    (n = (t = this.cbs).onreset) === null || n === void 0 || n.call(t), this.tokenizer.reset(), this.tagname = "", this.attribname = "", this.attribs = null, this.stack.length = 0, this.startIndex = 0, this.endIndex = 0, (i = (r = this.cbs).onparserinit) === null || i === void 0 || i.call(r, this), this.buffers.length = 0, this.foreignContext.length = 0, this.foreignContext.unshift(!this.htmlMode), this.bufferOffset = 0, this.writeIndex = 0, this.ended = false;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(t) {
    this.reset(), this.end(t);
  }
  getSlice(t, n) {
    for (; t - this.bufferOffset >= this.buffers[0].length; )
      this.shiftBuffer();
    let r = this.buffers[0].slice(t - this.bufferOffset, n - this.bufferOffset);
    for (; n - this.bufferOffset > this.buffers[0].length; )
      this.shiftBuffer(), r += this.buffers[0].slice(0, n - this.bufferOffset);
    return r;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length, this.writeIndex--, this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(t) {
    var n, r;
    if (this.ended) {
      (r = (n = this.cbs).onerror) === null || r === void 0 || r.call(n, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(t), this.tokenizer.running && (this.tokenizer.write(t), this.writeIndex++);
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(t) {
    var n, r;
    if (this.ended) {
      (r = (n = this.cbs).onerror) === null || r === void 0 || r.call(n, new Error(".end() after done!"));
      return;
    }
    t && this.write(t), this.ended = true, this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    for (this.tokenizer.resume(); this.tokenizer.running && this.writeIndex < this.buffers.length; )
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    this.ended && this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(t) {
    this.write(t);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(t) {
    this.end(t);
  }
};
function R5(e10, t) {
  const n = new _4(void 0, t);
  return new q5(n, t).end(e10), n.root;
}
var P5 = I5(Q6(R5), B0);
var H5 = {
  "div,p": ({ $node: e10 }) => ({
    queue: e10.children()
  }),
  "h1,h2,h3,h4,h5,h6": ({ $node: e10, getContent: t }) => ({
    ...t(e10.contents())
  }),
  "ul,ol": ({ $node: e10 }) => ({
    queue: e10.children(),
    nesting: true
  }),
  li: ({ $node: e10, getContent: t }) => {
    const n = e10.children().filter("ul,ol");
    let r;
    if (e10.contents().first().is("div,p"))
      r = t(e10.children().first());
    else {
      let i = e10.contents();
      const s = i.index(n);
      s >= 0 && (i = i.slice(0, s)), r = t(i);
    }
    return {
      queue: n,
      nesting: true,
      ...r
    };
  },
  "table,pre,p>img:only-child": ({ $node: e10, getContent: t }) => ({
    ...t(e10)
  })
};
var j5 = {
  selector: "h1,h2,h3,h4,h5,h6,ul,ol,li,table,pre,p>img:only-child",
  selectorRules: H5
};
var kf = "markmap: ";
var U5 = /^h[1-6]$/;
var V5 = /^[uo]l$/;
var G5 = /^li$/;
function W5(e10) {
  return U5.test(e10) ? +e10[1] : V5.test(e10) ? 8 : G5.test(e10) ? 9 : 7;
}
function K5(e10, t) {
  const n = {
    ...j5,
    ...t
  }, r = P5(e10);
  let i = r("body");
  i.length || (i = r.root());
  let s = 0;
  const o = {
    id: s,
    tag: "",
    html: "",
    level: 0,
    parent: 0,
    childrenLevel: 0,
    children: []
  }, l = [];
  let f = 0;
  return k(i.children()), o;
  function h2(w) {
    var A;
    const { parent: T } = w, D = {
      id: ++s,
      tag: w.tagName,
      level: w.level,
      html: w.html,
      childrenLevel: 0,
      children: w.nesting ? [] : void 0,
      parent: T.id
    };
    return (A = w.comments) != null && A.length && (D.comments = w.comments), Object.keys(w.data || {}).length && (D.data = w.data), T.children && ((T.childrenLevel === 0 || T.childrenLevel > D.level) && (T.children = [], T.childrenLevel = D.level), T.childrenLevel === D.level && T.children.push(D)), D;
  }
  function p(w) {
    let A;
    for (; (A = l[l.length - 1]) && A.level >= w; )
      l.pop();
    return A || o;
  }
  function b(w) {
    var A;
    const T = v(w), D = (A = r.html(T.$node)) == null ? void 0 : A.trimEnd();
    return { comments: T.comments, html: D };
  }
  function v(w) {
    const A = [];
    return w = w.filter((T, D) => {
      if (D.type === "comment") {
        const N = D.data.trim();
        if (N.startsWith(kf))
          return A.push(N.slice(kf.length).trim()), false;
      }
      return true;
    }), { $node: w, comments: A };
  }
  function k(w, A) {
    w.each((T, D) => {
      var N;
      const O = r(D), q = (N = Object.entries(n.selectorRules).find(
        ([Z]) => O.is(Z)
      )) == null ? void 0 : N[1], z = q == null ? void 0 : q({ $node: O, $: r, getContent: b });
      if ((z == null ? void 0 : z.queue) && !z.nesting) {
        k(z.queue, A);
        return;
      }
      const R = W5(D.tagName);
      if (!z) {
        R <= 6 && (f = R);
        return;
      }
      if (f > 0 && R > f || !O.is(n.selector)) return;
      f = 0;
      const J = R <= 6;
      let K = {
        // If the child is an inline element and expected to be a separate node,
        // data from the closest `<p>` should be included, e.g. `<p data-lines><img /></p>`
        ...O.closest("p").data(),
        ...O.data()
      }, V = z.html || "";
      if (O.is("ol>li") && (A == null ? void 0 : A.children)) {
        const se = +(O.parent().attr("start") || 1) + A.children.length;
        V = `${se}. ${V}`, K = {
          ...K,
          listIndex: se
        };
      }
      const te = h2({
        parent: A || p(R),
        nesting: !!z.queue || J,
        tagName: D.tagName,
        level: R,
        html: V,
        comments: z.comments,
        data: K
      });
      J && l.push(te), z.queue && k(z.queue, te);
    });
  }
}
function X5(e10) {
  return Ci(e10, (t, n) => {
    const r = {
      content: t.html,
      children: n() || []
    };
    return t.data && (r.payload = {
      tag: t.tag,
      ...t.data
    }), t.comments && (t.comments.includes("foldAll") ? r.payload = { ...r.payload, fold: 2 } : t.comments.includes("fold") && (r.payload = { ...r.payload, fold: 1 })), r;
  });
}
function Y5(e10, t) {
  const n = K5(e10, t);
  return X5(n);
}
var _f = {};
function Z5(e10) {
  let t = _f[e10];
  if (t)
    return t;
  t = _f[e10] = [];
  for (let n = 0; n < 128; n++) {
    const r = String.fromCharCode(n);
    t.push(r);
  }
  for (let n = 0; n < e10.length; n++) {
    const r = e10.charCodeAt(n);
    t[r] = "%" + ("0" + r.toString(16).toUpperCase()).slice(-2);
  }
  return t;
}
function Xr(e10, t) {
  typeof t != "string" && (t = Xr.defaultChars);
  const n = Z5(t);
  return e10.replace(/(%[a-f0-9]{2})+/gi, function(r) {
    let i = "";
    for (let s = 0, o = r.length; s < o; s += 3) {
      const l = parseInt(r.slice(s + 1, s + 3), 16);
      if (l < 128) {
        i += n[l];
        continue;
      }
      if ((l & 224) === 192 && s + 3 < o) {
        const f = parseInt(r.slice(s + 4, s + 6), 16);
        if ((f & 192) === 128) {
          const h2 = l << 6 & 1984 | f & 63;
          h2 < 128 ? i += "ï¿½ï¿½" : i += String.fromCharCode(h2), s += 3;
          continue;
        }
      }
      if ((l & 240) === 224 && s + 6 < o) {
        const f = parseInt(r.slice(s + 4, s + 6), 16), h2 = parseInt(r.slice(s + 7, s + 9), 16);
        if ((f & 192) === 128 && (h2 & 192) === 128) {
          const p = l << 12 & 61440 | f << 6 & 4032 | h2 & 63;
          p < 2048 || p >= 55296 && p <= 57343 ? i += "ï¿½ï¿½ï¿½" : i += String.fromCharCode(p), s += 6;
          continue;
        }
      }
      if ((l & 248) === 240 && s + 9 < o) {
        const f = parseInt(r.slice(s + 4, s + 6), 16), h2 = parseInt(r.slice(s + 7, s + 9), 16), p = parseInt(r.slice(s + 10, s + 12), 16);
        if ((f & 192) === 128 && (h2 & 192) === 128 && (p & 192) === 128) {
          let b = l << 18 & 1835008 | f << 12 & 258048 | h2 << 6 & 4032 | p & 63;
          b < 65536 || b > 1114111 ? i += "ï¿½ï¿½ï¿½ï¿½" : (b -= 65536, i += String.fromCharCode(55296 + (b >> 10), 56320 + (b & 1023))), s += 9;
          continue;
        }
      }
      i += "ï¿½";
    }
    return i;
  });
}
Xr.defaultChars = ";/?:@&=+$,#";
Xr.componentChars = "";
var Sf = {};
function J5(e10) {
  let t = Sf[e10];
  if (t)
    return t;
  t = Sf[e10] = [];
  for (let n = 0; n < 128; n++) {
    const r = String.fromCharCode(n);
    /^[0-9a-z]$/i.test(r) ? t.push(r) : t.push("%" + ("0" + n.toString(16).toUpperCase()).slice(-2));
  }
  for (let n = 0; n < e10.length; n++)
    t[e10.charCodeAt(n)] = e10[n];
  return t;
}
function ns(e10, t, n) {
  typeof t != "string" && (n = t, t = ns.defaultChars), typeof n > "u" && (n = true);
  const r = J5(t);
  let i = "";
  for (let s = 0, o = e10.length; s < o; s++) {
    const l = e10.charCodeAt(s);
    if (n && l === 37 && s + 2 < o && /^[0-9a-f]{2}$/i.test(e10.slice(s + 1, s + 3))) {
      i += e10.slice(s, s + 3), s += 2;
      continue;
    }
    if (l < 128) {
      i += r[l];
      continue;
    }
    if (l >= 55296 && l <= 57343) {
      if (l >= 55296 && l <= 56319 && s + 1 < o) {
        const f = e10.charCodeAt(s + 1);
        if (f >= 56320 && f <= 57343) {
          i += encodeURIComponent(e10[s] + e10[s + 1]), s++;
          continue;
        }
      }
      i += "%EF%BF%BD";
      continue;
    }
    i += encodeURIComponent(e10[s]);
  }
  return i;
}
ns.defaultChars = ";/?:@&=+$,-_.!~*'()#";
ns.componentChars = "-_.!~*'()";
function Oa(e10) {
  let t = "";
  return t += e10.protocol || "", t += e10.slashes ? "//" : "", t += e10.auth ? e10.auth + "@" : "", e10.hostname && e10.hostname.indexOf(":") !== -1 ? t += "[" + e10.hostname + "]" : t += e10.hostname || "", t += e10.port ? ":" + e10.port : "", t += e10.pathname || "", t += e10.search || "", t += e10.hash || "", t;
}
function x0() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
var Q5 = /^([a-z0-9.+-]+:)/i;
var eg = /:[0-9]*$/;
var tg = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
var ng = ["<", ">", '"', "`", " ", "\r", `
`, "	"];
var rg = ["{", "}", "|", "\\", "^", "`"].concat(ng);
var ig = ["'"].concat(rg);
var Af = ["%", "/", "?", ";", "#"].concat(ig);
var Ef = ["/", "?", "#"];
var sg = 255;
var Cf = /^[+a-z0-9A-Z_-]{0,63}$/;
var ug = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
var Tf = {
  javascript: true,
  "javascript:": true
};
var Df = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function za(e10, t) {
  if (e10 && e10 instanceof x0) return e10;
  const n = new x0();
  return n.parse(e10, t), n;
}
x0.prototype.parse = function(e10, t) {
  let n, r, i, s = e10;
  if (s = s.trim(), !t && e10.split("#").length === 1) {
    const h2 = tg.exec(s);
    if (h2)
      return this.pathname = h2[1], h2[2] && (this.search = h2[2]), this;
  }
  let o = Q5.exec(s);
  if (o && (o = o[0], n = o.toLowerCase(), this.protocol = o, s = s.substr(o.length)), (t || o || s.match(/^\/\/[^@\/]+@[^@\/]+/)) && (i = s.substr(0, 2) === "//", i && !(o && Tf[o]) && (s = s.substr(2), this.slashes = true)), !Tf[o] && (i || o && !Df[o])) {
    let h2 = -1;
    for (let w = 0; w < Ef.length; w++)
      r = s.indexOf(Ef[w]), r !== -1 && (h2 === -1 || r < h2) && (h2 = r);
    let p, b;
    h2 === -1 ? b = s.lastIndexOf("@") : b = s.lastIndexOf("@", h2), b !== -1 && (p = s.slice(0, b), s = s.slice(b + 1), this.auth = p), h2 = -1;
    for (let w = 0; w < Af.length; w++)
      r = s.indexOf(Af[w]), r !== -1 && (h2 === -1 || r < h2) && (h2 = r);
    h2 === -1 && (h2 = s.length), s[h2 - 1] === ":" && h2--;
    const v = s.slice(0, h2);
    s = s.slice(h2), this.parseHost(v), this.hostname = this.hostname || "";
    const k = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!k) {
      const w = this.hostname.split(/\./);
      for (let A = 0, T = w.length; A < T; A++) {
        const D = w[A];
        if (D && !D.match(Cf)) {
          let N = "";
          for (let O = 0, q = D.length; O < q; O++)
            D.charCodeAt(O) > 127 ? N += "x" : N += D[O];
          if (!N.match(Cf)) {
            const O = w.slice(0, A), q = w.slice(A + 1), z = D.match(ug);
            z && (O.push(z[1]), q.unshift(z[2])), q.length && (s = q.join(".") + s), this.hostname = O.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > sg && (this.hostname = ""), k && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  const l = s.indexOf("#");
  l !== -1 && (this.hash = s.substr(l), s = s.slice(0, l));
  const f = s.indexOf("?");
  return f !== -1 && (this.search = s.substr(f), s = s.slice(0, f)), s && (this.pathname = s), Df[n] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
x0.prototype.parseHost = function(e10) {
  let t = eg.exec(e10);
  t && (t = t[0], t !== ":" && (this.port = t.substr(1)), e10 = e10.substr(0, e10.length - t.length)), e10 && (this.hostname = e10);
};
var og = Object.freeze(Object.defineProperty({
  __proto__: null,
  decode: Xr,
  encode: ns,
  format: Oa,
  parse: za
}, Symbol.toStringTag, { value: "Module" }));
var G1 = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var W1 = /[\0-\x1F\x7F-\x9F]/;
var ag = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
var $a = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
var K1 = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/;
var X1 = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
var lg = Object.freeze(Object.defineProperty({
  __proto__: null,
  Any: G1,
  Cc: W1,
  Cf: ag,
  P: $a,
  S: K1,
  Z: X1
}, Symbol.toStringTag, { value: "Module" }));
var cg = new Uint16Array(
  // prettier-ignore
  'áµ<Ã•Ä±ÊŠÒÕ»×ÙµÛŞ¢ß–à à©Šàª‘à¶¡à¹­à¼‰à¼¦áƒŠáˆ¨á‹¡á•á’á“ƒá“Ÿá”¥\0\0\0\0\0\0á•«á›á¦á°’á·á½¾â â†°âŠâ€â»â‘‚â ¤â¤’â´ˆâ¹ˆâ¿ã€–ãŠºã˜¹ã¬ã£¾ã¨¨ã©±ã« ã¬®à €EMabcfglmnoprstu\\bfmsÂ„Â‹ÂÂ•Â˜Â¦Â³Â¹ÃˆÃligè€»Ã†äƒ†Pè€»&ä€¦cuteè€»Ãäƒreve;ä„‚Ä€iyx}rcè€»Ã‚äƒ‚;är;ì€€ğ”„raveè€»Ã€äƒ€pha;ä‘acr;ä„€d;æ©“Ä€gpÂÂ¡on;ä„„f;ì€€ğ”¸plyFunction;æ¡ingè€»Ã…äƒ…Ä€csÂ¾Ãƒr;ì€€ğ’œign;æ‰”ildeè€»Ãƒäƒƒmlè€»Ã„äƒ„Ğ€aceforsuÃ¥Ã»Ã¾Ä—ÄœÄ¢Ä§ÄªÄ€crÃªÃ²kslash;æˆ–Å¶Ã¶Ã¸;æ«§ed;æŒ†y;ä‘Æ€crtÄ…Ä‹Ä”ause;æˆµnoullis;æ„¬a;ä’r;ì€€ğ”…pf;ì€€ğ”¹eve;ä‹˜cÃ²Ä“mpeq;æ‰Ü€HOacdefhilorsuÅÅ‘Å–Æ€ÆÆ¢ÆµÆ·ÆºÇœÈ•É³É¸É¾cy;ä§PYè€»Â©ä‚©Æ€cpyÅÅ¢Åºute;ä„†Ä€;iÅ§Å¨æ‹’talDifferentialD;æ……leys;æ„­È€aeioÆ‰ÆÆ”Æ˜ron;ä„Œdilè€»Ã‡äƒ‡rc;ä„ˆnint;æˆ°ot;ä„ŠÄ€dnÆ§Æ­illa;ä‚¸terDot;ä‚·Ã²Å¿i;ä§rcleÈ€DMPTÇ‡Ç‹Ç‘Ç–ot;æŠ™inus;æŠ–lus;æŠ•imes;æŠ—oÄ€csÇ¢Ç¸kwiseContourIntegral;æˆ²eCurlyÄ€DQÈƒÈoubleQuote;æ€uote;æ€™È€lnpuÈÈ¨É‡É•onÄ€;eÈ¥È¦æˆ·;æ©´Æ€gitÈ¯È¶Èºruent;æ‰¡nt;æˆ¯ourIntegral;æˆ®Ä€frÉŒÉ;æ„‚oduct;æˆnterClockwiseContourIntegral;æˆ³oss;æ¨¯cr;ì€€ğ’pÄ€;CÊ„Ê…æ‹“ap;æ‰Ö€DJSZacefiosÊ Ê¬Ê°Ê´Ê¸Ë‹Ë—Ë¡Ë¦Ì³ÒÄ€;oÅ¹Ê¥trahd;æ¤‘cy;ä‚cy;ä…cy;äÆ€grsÊ¿Ë„Ë‡ger;æ€¡r;æ†¡hv;æ«¤Ä€ayËË•ron;ä„;ä”lÄ€;tËËæˆ‡a;ä”r;ì€€ğ”‡Ä€afË«Ì§Ä€cmË°Ì¢riticalÈ€ADGTÌ€Ì†Ì–Ìœcute;ä‚´oÅ´Ì‹Ì;ä‹™bleAcute;ä‹rave;ä ilde;ä‹œond;æ‹„ferentialD;æ…†Ñ°Ì½\0\0\0Í‚Í”\0Ğ…f;ì€€ğ”»Æ€;DEÍˆÍ‰Íä‚¨ot;æƒœqual;æ‰bleÌ€CDLRUVÍ£Í²Î‚ÏÏ¢Ï¸ontourIntegraÃ¬È¹oÉ´Í¹\0\0Í»Â»Í‰nArrow;æ‡“Ä€eoÎ‡Î¤ftÆ€ARTÎÎ–Î¡rrow;æ‡ightArrow;æ‡”eÃ¥ËŠngÄ€LRÎ«Ï„eftÄ€ARÎ³Î¹rrow;æŸ¸ightArrow;æŸºightArrow;æŸ¹ightÄ€ATÏ˜Ïrrow;æ‡’ee;æŠ¨pÉÏ©\0\0Ï¯rrow;æ‡‘ownArrow;æ‡•erticalBar;æˆ¥nÌ€ABLRTaĞ’ĞªĞ°ÑÑ¿Í¼rrowÆ€;BUĞĞĞ¢æ†“ar;æ¤“pArrow;æ‡µreve;äŒ‘eftË’Ğº\0Ñ†\0ÑightVector;æ¥eeVector;æ¥ectorÄ€;BÑ™Ñšæ†½ar;æ¥–ightÇ”Ñ§\0Ñ±eeVector;æ¥ŸectorÄ€;BÑºÑ»æ‡ar;æ¥—eeÄ€;AÒ†Ò‡æŠ¤rrow;æ†§Ä€ctÒ’Ò—r;ì€€ğ’Ÿrok;ä„à €NTacdfglmopqstuxÒ½Ó€Ó„Ó‹ÓÓ¢Ó§Ó®ÓµÔ¡Ô¯Ô¶Õ’ÕÕ Õ¥G;ä…ŠHè€»Ãäƒcuteè€»Ã‰äƒ‰Æ€aiyÓ’Ó—Óœron;ä„šrcè€»ÃŠäƒŠ;ä­ot;ä„–r;ì€€ğ”ˆraveè€»Ãˆäƒˆement;æˆˆÄ€apÓºÓ¾cr;ä„’tyÉ“Ô†\0\0Ô’mallSquare;æ—»erySmallSquare;æ–«Ä€gpÔ¦Ôªon;ä„˜f;ì€€ğ”¼silon;ä•uÄ€aiÔ¼Õ‰lÄ€;TÕ‚Õƒæ©µilde;æ‰‚librium;æ‡ŒÄ€ciÕ—Õšr;æ„°m;æ©³a;ä—mlè€»Ã‹äƒ‹Ä€ipÕªÕ¯sts;æˆƒonentialE;æ…‡Ê€cfiosÖ…ÖˆÖÖ²×Œy;ä¤r;ì€€ğ”‰lledÉ“Ö—\0\0Ö£mallSquare;æ—¼erySmallSquare;æ–ªÍ°Öº\0Ö¿\0\0×„f;ì€€ğ”½All;æˆ€riertrf;æ„±cÃ²×‹Ø€JTabcdfgorst×¨×¬×¯×ºØ€Ø’Ø–Ø›ØØ£Ù¬Ù²cy;äƒè€»>ä€¾mmaÄ€;d×·×¸ä“;äœreve;ä„Æ€eiyØ‡ØŒØdil;ä„¢rc;ä„œ;ä“ot;ä„ r;ì€€ğ”Š;æ‹™pf;ì€€ğ”¾eaterÌ€EFGLSTØµÙ„ÙÙ–Ù›Ù¦qualÄ€;LØ¾Ø¿æ‰¥ess;æ‹›ullEqual;æ‰§reater;æª¢ess;æ‰·lantEqual;æ©¾ilde;æ‰³cr;ì€€ğ’¢;æ‰«Ğ€AacfiosuÚ…Ú‹Ú–Ú›ÚÚªÚ¾ÛŠRDcy;äªÄ€ctÚÚ”ek;ä‹‡;äirc;ä„¤r;æ„ŒlbertSpace;æ„‹Ç°Ú¯\0Ú²f;æ„izontalLine;æ”€Ä€ctÛƒÛ…Ã²Ú©rok;ä„¦mpÅ„ÛÛ˜ownHumÃ°Ä¯qual;æ‰Ü€EJOacdfgmnostuÛºÛ¾ÜƒÜ‡ÜÜšÜÜ¡Ü¨İ„İ¸Ş‹ŞŞ•cy;ä•lig;ä„²cy;äcuteè€»ÃäƒÄ€iyÜ“Ü˜rcè€»Ãäƒ;ä˜ot;ä„°r;æ„‘raveè€»ÃŒäƒŒÆ€;apÜ Ü¯Ü¿Ä€cgÜ´Ü·r;ä„ªinaryI;æ…ˆlieÃ³ÏÇ´İ‰\0İ¢Ä€;eİİæˆ¬Ä€grİ“İ˜ral;æˆ«section;æ‹‚isibleÄ€CTİ¬İ²omma;æ£imes;æ¢Æ€gptİ¿ŞƒŞˆon;ä„®f;ì€€ğ•€a;ä™cr;æ„ilde;ä„¨Ç«Şš\0Şcy;ä†lè€»ÃäƒÊ€cfosuŞ¬Ş·Ş¼ß‚ßÄ€iyŞ±Şµrc;ä„´;ä™r;ì€€ğ”pf;ì€€ğ•Ç£ß‡\0ßŒr;ì€€ğ’¥rcy;äˆkcy;ä„Î€HJacfosß¤ß¨ß¬ß±ß½à ‚à ˆcy;ä¥cy;äŒppa;äšÄ€eyß¶ß»dil;ä„¶;äšr;ì€€ğ”pf;ì€€ğ•‚cr;ì€€ğ’¦Ö€JTaceflmostà ¥à ©à ¬à¡à¡£à¦³à¦¸à§‡à§à¨·à©‡cy;ä‰è€»<ä€¼Ê€cmnprà ·à ¼à¡à¡„à¡ute;ä„¹bda;ä›g;æŸªlacetrf;æ„’r;æ†Æ€aeyà¡—à¡œà¡¡ron;ä„½dil;ä„»;ä›Ä€fsà¡¨à¥°tÔ€ACDFRTUVarà¡¾à¢©à¢±à£ à£¦à£¼à¤¯à¥›Îà¥ªÄ€nrà¢ƒà¢gleBracket;æŸ¨rowÆ€;BRà¢™à¢šà¢æ†ar;æ‡¤ightArrow;æ‡†eiling;æŒˆoÇµà¢·\0à£ƒbleBracket;æŸ¦nÇ”à£ˆ\0à£’eeVector;æ¥¡ectorÄ€;Bà£›à£œæ‡ƒar;æ¥™loor;æŒŠightÄ€AVà£¯à£µrrow;æ†”ector;æ¥Ä€erà¤à¤—eÆ€;AVà¤‰à¤Šà¤æŠ£rrow;æ†¤ector;æ¥šiangleÆ€;BEà¤¤à¤¥à¤©æŠ²ar;æ§qual;æŠ´pÆ€DTVà¤·à¥‚à¥ŒownVector;æ¥‘eeVector;æ¥ ectorÄ€;Bà¥–à¥—æ†¿ar;æ¥˜ectorÄ€;Bà¥¥à¥¦æ†¼ar;æ¥’ightÃ¡ÎœsÌ€EFGLSTà¥¾à¦‹à¦•à¦à¦¢à¦­qualGreater;æ‹šullEqual;æ‰¦reater;æ‰¶ess;æª¡lantEqual;æ©½ilde;æ‰²r;ì€€ğ”Ä€;eà¦½à¦¾æ‹˜ftarrow;æ‡šidot;ä„¿Æ€npwà§”à¨–à¨›gÈ€LRlrà§à§·à¨‚à¨eftÄ€ARà§¦à§¬rrow;æŸµightArrow;æŸ·ightArrow;æŸ¶eftÄ€arÎ³à¨ŠightÃ¡Î¿ightÃ¡ÏŠf;ì€€ğ•ƒerÄ€LRà¨¢à¨¬eftArrow;æ†™ightArrow;æ†˜Æ€chtà¨¾à©€à©‚Ã²à¡Œ;æ†°rok;ä…;æ‰ªĞ€acefiosuà©šà©à© à©·à©¼àª…àª‹àªp;æ¤…y;äœÄ€dlà©¥à©¯iumSpace;æŸlintrf;æ„³r;ì€€ğ”nusPlus;æˆ“pf;ì€€ğ•„cÃ²à©¶;äœÒ€Jacefostuàª£àª§àª­à«€à¬”à¬™à¶‘à¶—à¶cy;äŠcute;ä…ƒÆ€aeyàª´àª¹àª¾ron;ä…‡dil;ä……;äÆ€gswà«‡à«°à¬ativeÆ€MTVà«“à«Ÿà«¨ediumSpace;æ€‹hiÄ€cnà«¦à«˜Ã«à«™eryThiÃ®à«™tedÄ€GLà«¸à¬†reaterGreateÃ²Ù³essLesÃ³à©ˆLine;ä€Šr;ì€€ğ”‘È€Bnptà¬¢à¬¨à¬·à¬ºreak;æ BreakingSpace;ä‚ f;æ„•Ú€;CDEGHLNPRSTVà­•à­–à­ªà­¼à®¡à¯«à°„à±à²„à²¦à³˜àµ¡à¶…æ«¬Ä€ouà­›à­¤ngruent;æ‰¢pCap;æ‰­oubleVerticalBar;æˆ¦Æ€lqxà®ƒà®Šà®›ement;æˆ‰ualÄ€;Tà®’à®“æ‰ ilde;ì€€â‰‚Ì¸ists;æˆ„reaterÎ€;EFGLSTà®¶à®·à®½à¯‰à¯“à¯˜à¯¥æ‰¯qual;æ‰±ullEqual;ì€€â‰§Ì¸reater;ì€€â‰«Ì¸ess;æ‰¹lantEqual;ì€€â©¾Ì¸ilde;æ‰µumpÅ„à¯²à¯½ownHump;ì€€â‰Ì¸qual;ì€€â‰Ì¸eÄ€fsà°Šà°§tTriangleÆ€;BEà°šà°›à°¡æ‹ªar;ì€€â§Ì¸qual;æ‹¬sÌ€;EGLSTà°µà°¶à°¼à±„à±‹à±˜æ‰®qual;æ‰°reater;æ‰¸ess;ì€€â‰ªÌ¸lantEqual;ì€€â©½Ì¸ilde;æ‰´estedÄ€GLà±¨à±¹reaterGreater;ì€€âª¢Ì¸essLess;ì€€âª¡Ì¸recedesÆ€;ESà²’à²“à²›æŠ€qual;ì€€âª¯Ì¸lantEqual;æ‹ Ä€eià²«à²¹verseElement;æˆŒghtTriangleÆ€;BEà³‹à³Œà³’æ‹«ar;ì€€â§Ì¸qual;æ‹­Ä€quà³à´ŒuareSuÄ€bpà³¨à³¹setÄ€;Eà³°à³³ì€€âŠÌ¸qual;æ‹¢ersetÄ€;Eà´ƒà´†ì€€âŠÌ¸qual;æ‹£Æ€bcpà´“à´¤àµsetÄ€;Eà´›à´ì€€âŠ‚âƒ’qual;æŠˆceedsÈ€;ESTà´²à´³à´»àµ†æŠqual;ì€€âª°Ì¸lantEqual;æ‹¡ilde;ì€€â‰¿Ì¸ersetÄ€;Eàµ˜àµ›ì€€âŠƒâƒ’qual;æŠ‰ildeÈ€;EFTàµ®àµ¯àµµàµ¿æ‰qual;æ‰„ullEqual;æ‰‡ilde;æ‰‰erticalBar;æˆ¤cr;ì€€ğ’©ildeè€»Ã‘äƒ‘;äÜ€Eacdfgmoprstuvà¶½à·‚à·‰à·•à·›à· à·§à·¼à¸‚à¸ à¸¢à¸²à¸¿à¹„lig;ä…’cuteè€»Ã“äƒ“Ä€iyà·à·“rcè€»Ã”äƒ”;äblac;ä…r;ì€€ğ”’raveè€»Ã’äƒ’Æ€aeià·®à·²à·¶cr;ä…Œga;ä©cron;äŸpf;ì€€ğ•†enCurlyÄ€DQà¸à¸šoubleQuote;æ€œuote;æ€˜;æ©”Ä€clà¸§à¸¬r;ì€€ğ’ªashè€»Ã˜äƒ˜iÅ¬à¸·à¸¼deè€»Ã•äƒ•es;æ¨·mlè€»Ã–äƒ–erÄ€BPà¹‹à¹ Ä€arà¹à¹“r;æ€¾acÄ€ekà¹šà¹œ;æet;æ´arenthesis;æœÒ€acfhilorsà¹¿àº‡àºŠàºàº’àº”àºàº°à»¼rtialD;æˆ‚y;äŸr;ì€€ğ”“i;ä¦;ä usMinus;ä‚±Ä€ipàº¢àº­ncareplanÃ¥Úf;æ„™È€;eioàº¹àººà» à»¤æª»cedesÈ€;ESTà»ˆà»‰à»à»šæ‰ºqual;æª¯lantEqual;æ‰¼ilde;æ‰¾me;æ€³Ä€dpà»©à»®uct;æˆortionÄ€;aÈ¥à»¹l;æˆÄ€cià¼à¼†r;ì€€ğ’«;ä¨È€Ufosà¼‘à¼–à¼›à¼ŸOTè€»"ä€¢r;ì€€ğ””pf;æ„šcr;ì€€ğ’¬Ø€BEacefhiorsuà¼¾à½ƒà½‡à½ à½³à¾§à¾ªà¾­á‚–á‚©á‚´á‚¾arr;æ¤Gè€»Â®ä‚®Æ€cnrà½à½“à½–ute;ä…”g;æŸ«rÄ€;tà½œà½æ† l;æ¤–Æ€aeyà½§à½¬à½±ron;ä…˜dil;ä…–;ä Ä€;và½¸à½¹æ„œerseÄ€EUà¾‚à¾™Ä€lqà¾‡à¾ement;æˆ‹uilibrium;æ‡‹pEquilibrium;æ¥¯rÂ»à½¹o;ä¡ghtĞ€ACDFTUVaà¿à¿«à¿³á€¢á€¨á›á‚‡Ï˜Ä€nrà¿†à¿’gleBracket;æŸ©rowÆ€;BLà¿œà¿à¿¡æ†’ar;æ‡¥eftArrow;æ‡„eiling;æŒ‰oÇµà¿¹\0á€…bleBracket;æŸ§nÇ”á€Š\0á€”eeVector;æ¥ectorÄ€;Bá€á€æ‡‚ar;æ¥•loor;æŒ‹Ä€erá€­áƒeÆ€;AVá€µá€¶á€¼æŠ¢rrow;æ†¦ector;æ¥›iangleÆ€;BEáá‘á•æŠ³ar;æ§qual;æŠµpÆ€DTVá£á®á¸ownVector;æ¥eeVector;æ¥œectorÄ€;Bá‚‚á‚ƒæ†¾ar;æ¥”ectorÄ€;Bá‚‘á‚’æ‡€ar;æ¥“Ä€puá‚›á‚f;æ„ndImplies;æ¥°ightarrow;æ‡›Ä€chá‚¹á‚¼r;æ„›;æ†±leDelayed;æ§´Ú€HOacfhimoqstuáƒ¤áƒ±áƒ·áƒ½á„™á„á…‘á…–á…¡á…§á†µá†»á†¿Ä€Ccáƒ©áƒ®Hcy;ä©y;ä¨FTcy;ä¬cute;ä…šÊ€;aeiyá„ˆá„‰á„á„“á„—æª¼ron;ä… dil;ä…rc;ä…œ;ä¡r;ì€€ğ”–ortÈ€DLRUá„ªá„´á„¾á…‰ownArrowÂ»ĞeftArrowÂ»à¢šightArrowÂ»à¿pArrow;æ†‘gma;ä£allCircle;æˆ˜pf;ì€€ğ•ŠÉ²á…­\0\0á…°t;æˆšareÈ€;ISUá…»á…¼á†‰á†¯æ–¡ntersection;æŠ“uÄ€bpá†á†setÄ€;Eá†—á†˜æŠqual;æŠ‘ersetÄ€;Eá†¨á†©æŠqual;æŠ’nion;æŠ”cr;ì€€ğ’®ar;æ‹†È€bcmpá‡ˆá‡›áˆ‰áˆ‹Ä€;sá‡á‡æ‹etÄ€;Eá‡á‡•qual;æŠ†Ä€chá‡ áˆ…eedsÈ€;ESTá‡­á‡®á‡´á‡¿æ‰»qual;æª°lantEqual;æ‰½ilde;æ‰¿ThÃ¡à¾Œ;æˆ‘Æ€;esáˆ’áˆ“áˆ£æ‹‘rsetÄ€;EáˆœáˆæŠƒqual;æŠ‡etÂ»áˆ“Ö€HRSacfhiorsáˆ¾á‰„á‰‰á‰•á‰á‰±á‰¶áŠŸá‹‚á‹ˆá‹‘ORNè€»ÃäƒADE;æ„¢Ä€Hcá‰á‰’cy;ä‹y;ä¦Ä€buá‰šá‰œ;ä€‰;ä¤Æ€aeyá‰¥á‰ªá‰¯ron;ä…¤dil;ä…¢;ä¢r;ì€€ğ”—Ä€eiá‰»áŠ‰Ç²áŠ€\0áŠ‡efore;æˆ´a;ä˜Ä€cnáŠáŠ˜kSpace;ì€€âŸâ€ŠSpace;æ€‰ldeÈ€;EFTáŠ«áŠ¬áŠ²áŠ¼æˆ¼qual;æ‰ƒullEqual;æ‰…ilde;æ‰ˆpf;ì€€ğ•‹ipleDot;æƒ›Ä€ctá‹–á‹›r;ì€€ğ’¯rok;ä…¦à«¡á‹·áŒáŒšáŒ¦\0áŒ¬áŒ±\0\0\0\0\0áŒ¸áŒ½á·á…\0á¿á„áŠáÄ€crá‹»áŒuteè€»ÃšäƒšrÄ€;oáŒ‡áŒˆæ†Ÿcir;æ¥‰rÇ£áŒ“\0áŒ–y;äve;ä…¬Ä€iyáŒáŒ£rcè€»Ã›äƒ›;ä£blac;ä…°r;ì€€ğ”˜raveè€»Ã™äƒ™acr;ä…ªÄ€diáá©erÄ€BPáˆáÄ€aráár;äŸacÄ€eká—á™;æŸet;æµarenthesis;æonÄ€;Pá°á±æ‹ƒlus;æŠÄ€gpá»á¿on;ä…²f;ì€€ğ•ŒĞ€ADETadpsá•á®á¸á„Ï¨á’á—á³rrowÆ€;BDá…á á¤ar;æ¤’ownArrow;æ‡…ownArrow;æ†•quilibrium;æ¥®eeÄ€;Aá‹áŒæŠ¥rrow;æ†¥ownÃ¡Ï³erÄ€LRáá¨eftArrow;æ†–ightArrow;æ†—iÄ€;lá¹áºä’on;ä¥ing;ä…®cr;ì€€ğ’°ilde;ä…¨mlè€»ÃœäƒœÒ€Dbcdefosvá§á¬á°á³á¾á’…á’Šá’á’–ash;æŠ«ar;æ««y;ä’ashÄ€;lá»á¼æŠ©;æ«¦Ä€erá‘ƒá‘…;æ‹Æ€btyá‘Œá‘á‘ºar;æ€–Ä€;iá‘á‘•calÈ€BLSTá‘¡á‘¥á‘ªá‘´ar;æˆ£ine;ä¼eparator;æ˜ilde;æ‰€ThinSpace;æ€Šr;ì€€ğ”™pf;ì€€ğ•cr;ì€€ğ’±dash;æŠªÊ€cefosá’§á’¬á’±á’¶á’¼irc;ä…´dge;æ‹€r;ì€€ğ”špf;ì€€ğ•cr;ì€€ğ’²È€fiosá“‹á“á“’á“˜r;ì€€ğ”›;äpf;ì€€ğ•cr;ì€€ğ’³Ò€AIUacfosuá“±á“µá“¹á“½á”„á”á””á”šá” cy;ä¯cy;ä‡cy;ä®cuteè€»ÃäƒÄ€iyá”‰á”rc;ä…¶;ä«r;ì€€ğ”œpf;ì€€ğ•cr;ì€€ğ’´ml;ä…¸Ğ€Hacdefosá”µá”¹á”¿á•‹á•á•á• á•¤cy;ä–cute;ä…¹Ä€ayá•„á•‰ron;ä…½;ä—ot;ä…»Ç²á•”\0á•›oWidtÃ¨à«™a;ä–r;æ„¨pf;æ„¤cr;ì€€ğ’µà¯¡á–ƒá–Šá–\0á–°á–¶á–¿\0\0\0\0á—†á—›á—«á™Ÿá™­\0áš•áš›áš²áš¹\0áš¾cuteè€»Ã¡äƒ¡reve;ä„ƒÌ€;Ediuyá–œá–á–¡á–£á–¨á–­æˆ¾;ì€€âˆ¾Ì³;æˆ¿rcè€»Ã¢äƒ¢teè‚»Â´Ì†;ä°ligè€»Ã¦äƒ¦Ä€;rÂ²á–º;ì€€ğ”raveè€»Ã äƒ Ä€epá—Šá—–Ä€fpá—á—”sym;æ„µÃ¨á—“ha;ä±Ä€apá—ŸcÄ€clá—¤á—§r;ä„g;æ¨¿É¤á—°\0\0á˜ŠÊ€;adsvá—ºá—»á—¿á˜á˜‡æˆ§nd;æ©•;æ©œlope;æ©˜;æ©šÎ€;elmrszá˜˜á˜™á˜›á˜á˜¿á™á™™æˆ ;æ¦¤eÂ»á˜™sdÄ€;aá˜¥á˜¦æˆ¡Ñ¡á˜°á˜²á˜´á˜¶á˜¸á˜ºá˜¼á˜¾;æ¦¨;æ¦©;æ¦ª;æ¦«;æ¦¬;æ¦­;æ¦®;æ¦¯tÄ€;vá™…á™†æˆŸbÄ€;dá™Œá™æŠ¾;æ¦Ä€ptá™”á™—h;æˆ¢Â»Â¹arr;æ¼Ä€gpá™£á™§on;ä„…f;ì€€ğ•’Î€;Eaeiopá‹á™»á™½áš‚áš„áš‡ášŠ;æ©°cir;æ©¯;æ‰Šd;æ‰‹s;ä€§roxÄ€;eá‹áš’Ã±ášƒingè€»Ã¥äƒ¥Æ€ctyáš¡áš¦áš¨r;ì€€ğ’¶;ä€ªmpÄ€;eá‹áš¯Ã±Êˆildeè€»Ã£äƒ£mlè€»Ã¤äƒ¤Ä€ciá›‚á›ˆoninÃ´É²nt;æ¨‘à €Nabcdefiklnoprsuá›­á›±áœ°áœ¼áƒáˆá¸á½áŸ áŸ¦á ¹á¡áœá¤½á¥ˆá¥°ot;æ«­Ä€crá›¶áœkÈ€cepsáœ€áœ…áœáœ“ong;æ‰Œpsilon;ä¶rime;æ€µimÄ€;eáœšáœ›æˆ½q;æ‹Å¶áœ¢áœ¦ee;æŠ½edÄ€;gáœ¬áœ­æŒ…eÂ»áœ­rkÄ€;táœáœ·brk;æ¶Ä€oyáœá;ä±quo;æ€Ê€cmprtá“á›á¡á¤á¨ausÄ€;eÄŠÄ‰ptyv;æ¦°sÃ©áœŒnoÃµÄ“Æ€ahwá¯á±á³;ä²;æ„¶een;æ‰¬r;ì€€ğ”ŸgÎ€costuvwááá³áŸáŸ•áŸ›áŸÆ€aiuá”á–ášÃ°İ rc;æ—¯pÂ»á±Æ€dptá¤á¨á­ot;æ¨€lus;æ¨imes;æ¨‚É±á¹\0\0á¾cup;æ¨†ar;æ˜…riangleÄ€duáŸáŸ’own;æ–½p;æ–³plus;æ¨„eÃ¥á‘„Ã¥á’­arow;æ¤Æ€akoáŸ­á ¦á µÄ€cnáŸ²á £kÆ€lstáŸºÖ«á ‚ozenge;æ§«riangleÈ€;dlrá ’á “á ˜á æ–´own;æ–¾eft;æ—‚ight;æ–¸k;æ£Æ±á «\0á ³Æ²á ¯\0á ±;æ–’;æ–‘4;æ–“ck;æ–ˆÄ€eoá ¾á¡Ä€;qá¡ƒá¡†ì€€=âƒ¥uiv;ì€€â‰¡âƒ¥t;æŒÈ€ptwxá¡™á¡á¡§á¡¬f;ì€€ğ•“Ä€;tá‹á¡£omÂ»áŒtie;æ‹ˆØ€DHUVbdhmptuvá¢…á¢–á¢ªá¢»á£—á£›á£¬á£¿á¤…á¤Šá¤á¤¡È€LRlrá¢á¢á¢’á¢”;æ•—;æ•”;æ•–;æ•“Ê€;DUduá¢¡á¢¢á¢¤á¢¦á¢¨æ•;æ•¦;æ•©;æ•¤;æ•§È€LRlrá¢³á¢µá¢·á¢¹;æ•;æ•š;æ•œ;æ•™Î€;HLRhlrá£Šá£‹á£á£á£‘á£“á£•æ•‘;æ•¬;æ•£;æ• ;æ•«;æ•¢;æ•Ÿox;æ§‰È€LRlrá£¤á£¦á£¨á£ª;æ••;æ•’;æ”;æ”ŒÊ€;DUduÚ½á£·á£¹á£»á£½;æ•¥;æ•¨;æ”¬;æ”´inus;æŠŸlus;æŠimes;æŠ È€LRlrá¤™á¤›á¤á¤Ÿ;æ•›;æ•˜;æ”˜;æ””Î€;HLRhlrá¤°á¤±á¤³á¤µá¤·á¤¹á¤»æ”‚;æ•ª;æ•¡;æ•;æ”¼;æ”¤;æ”œÄ€evÄ£á¥‚barè€»Â¦ä‚¦È€ceioá¥‘á¥–á¥šá¥ r;ì€€ğ’·mi;æmÄ€;eáœšáœœlÆ€;bhá¥¨á¥©á¥«äœ;æ§…sub;æŸˆÅ¬á¥´á¥¾lÄ€;eá¥¹á¥ºæ€¢tÂ»á¥ºpÆ€;EeÄ¯á¦…á¦‡;æª®Ä€;qÛœÛ›à³¡á¦§\0á§¨á¨‘á¨•á¨²\0á¨·á©\0\0áª´\0\0á«\0\0á¬¡á¬®á­á­’\0á¯½\0á°ŒÆ€cprá¦­á¦²á§ute;ä„‡Ì€;abcdsá¦¿á§€á§„á§Šá§•á§™æˆ©nd;æ©„rcup;æ©‰Ä€auá§á§’p;æ©‹p;æ©‡ot;æ©€;ì€€âˆ©ï¸€Ä€eoá§¢á§¥t;æÃ®Ú“È€aeiuá§°á§»á¨á¨…Ç°á§µ\0á§¸s;æ©on;ä„dilè€»Ã§äƒ§rc;ä„‰psÄ€;sá¨Œá¨æ©Œm;æ©ot;ä„‹Æ€dmná¨›á¨ á¨¦ilè‚»Â¸Æ­ptyv;æ¦²tè„€Â¢;eá¨­á¨®ä‚¢rÃ¤Æ²r;ì€€ğ” Æ€ceiá¨½á©€á©y;ä‘‡ckÄ€;má©‡á©ˆæœ“arkÂ»á©ˆ;ä‡rÎ€;Ecefmsá©Ÿá© á©¢á©«áª¤áªªáª®æ—‹;æ§ƒÆ€;elá©©á©ªá©­ä‹†q;æ‰—eÉ¡á©´\0\0áªˆrrowÄ€lrá©¼áªeft;æ†ºight;æ†»Ê€RSacdáª’áª”áª–áªšáªŸÂ»à½‡;æ“ˆst;æŠ›irc;æŠšash;æŠnint;æ¨id;æ«¯cir;æ§‚ubsÄ€;uáª»áª¼æ™£itÂ»áª¼Ë¬á«‡á«”á«º\0á¬ŠonÄ€;eá«á«ä€ºÄ€;qÃ‡Ã†É­á«™\0\0á«¢aÄ€;tá«á«Ÿä€¬;ä€Æ€;flá«¨á«©á««æˆÃ®á… eÄ€mxá«±á«¶entÂ»á«©eÃ³ÉÇ§á«¾\0á¬‡Ä€;dáŠ»á¬‚ot;æ©­nÃ´É†Æ€fryá¬á¬”á¬—;ì€€ğ•”oÃ¤É”è„€Â©;sÅ•á¬r;æ„—Ä€aoá¬¥á¬©rr;æ†µss;æœ—Ä€cuá¬²á¬·r;ì€€ğ’¸Ä€bpá¬¼á­„Ä€;eá­á­‚æ«;æ«‘Ä€;eá­‰á­Šæ«;æ«’dot;æ‹¯Î€delprvwá­ á­¬á­·á®‚á®¬á¯”á¯¹arrÄ€lrá­¨á­ª;æ¤¸;æ¤µÉ°á­²\0\0á­µr;æ‹c;æ‹ŸarrÄ€;pá­¿á®€æ†¶;æ¤½Ì€;bcdosá®á®á®–á®¡á®¥á®¨æˆªrcap;æ©ˆÄ€auá®›á®p;æ©†p;æ©Šot;æŠr;æ©…;ì€€âˆªï¸€È€alrvá®µá®¿á¯á¯£rrÄ€;má®¼á®½æ†·;æ¤¼yÆ€evwá¯‡á¯”á¯˜qÉ°á¯\0\0á¯’reÃ£á­³uÃ£á­µee;æ‹edge;æ‹enè€»Â¤ä‚¤earrowÄ€lrá¯®á¯³eftÂ»á®€ightÂ»á®½eÃ¤á¯Ä€ciá°á°‡oninÃ´Ç·nt;æˆ±lcty;æŒ­à¦€AHabcdefhijlorstuwzá°¸á°»á°¿á±á±©á±µá²Šá²á²¬á²·á³»á³¿á´áµ»á¶‘á¶«á¶»á·†á·rÃ²Îar;æ¥¥È€glrsá±ˆá±á±’á±”ger;æ€ eth;æ„¸Ã²á„³hÄ€;vá±šá±›æ€Â»à¤ŠÅ«á±¡á±§arow;æ¤aÃ£Ì•Ä€ayá±®á±³ron;ä„;ä´Æ€;aoÌ²á±¼á²„Ä€grÊ¿á²r;æ‡Štseq;æ©·Æ€glmá²‘á²”á²˜è€»Â°ä‚°ta;ä´ptyv;æ¦±Ä€irá²£á²¨sht;æ¥¿;ì€€ğ”¡arÄ€lrá²³á²µÂ»à£œÂ»á€Ê€aegsvá³‚Í¸á³–á³œá³ mÆ€;osÌ¦á³Šá³”ndÄ€;sÌ¦á³‘uit;æ™¦amma;äin;æ‹²Æ€;ioá³§á³¨á³¸äƒ·deè„€Ã·;oá³§á³°ntimes;æ‹‡nÃ¸á³·cy;ä‘’cÉ¯á´†\0\0á´Šrn;æŒop;æŒÊ€lptuwá´˜á´á´¢áµ‰áµ•lar;ä€¤f;ì€€ğ••Ê€;empsÌ‹á´­á´·á´½áµ‚qÄ€;dÍ’á´³ot;æ‰‘inus;æˆ¸lus;æˆ”quare;æŠ¡blebarwedgÃ¥ÃºnÆ€adhá„®áµáµ§ownarrowÃ³á²ƒarpoonÄ€lráµ²áµ¶efÃ´á²´ighÃ´á²¶Å¢áµ¿á¶…karoÃ·à½‚É¯á¶Š\0\0á¶rn;æŒŸop;æŒŒÆ€cotá¶˜á¶£á¶¦Ä€ryá¶á¶¡;ì€€ğ’¹;ä‘•l;æ§¶rok;ä„‘Ä€drá¶°á¶´ot;æ‹±iÄ€;fá¶ºá –æ–¿Ä€ahá·€á·ƒrÃ²Ğ©aÃ²à¾¦angle;æ¦¦Ä€ciá·’á·•y;ä‘Ÿgrarr;æŸ¿à¤€Dacdefglmnopqrstuxá¸á¸‰á¸™á¸¸Õ¸á¸¼á¹‰á¹¡á¹¾áº¥áº¯áº½á»¡á¼ªá¼·á½„á½á½šÄ€Doá¸†á´´oÃ´á²‰Ä€csá¸á¸”uteè€»Ã©äƒ©ter;æ©®È€aioyá¸¢á¸§á¸±á¸¶ron;ä„›rÄ€;cá¸­á¸®æ‰–è€»Ãªäƒªlon;æ‰•;ä‘ot;ä„—Ä€Drá¹á¹…ot;æ‰’;ì€€ğ”¢Æ€;rsá¹á¹‘á¹—æªšaveè€»Ã¨äƒ¨Ä€;dá¹œá¹æª–ot;æª˜È€;ilsá¹ªá¹«á¹²á¹´æª™nters;æ§;æ„“Ä€;dá¹¹á¹ºæª•ot;æª—Æ€apsáº…áº‰áº—cr;ä„“tyÆ€;sváº’áº“áº•æˆ…etÂ»áº“pÄ€1;áºáº¤Ä³áº¡áº£;æ€„;æ€…æ€ƒÄ€gsáºªáº¬;ä…‹p;æ€‚Ä€gpáº´áº¸on;ä„™f;ì€€ğ•–Æ€alsá»„á»á»’rÄ€;sá»Šá»‹æ‹•l;æ§£us;æ©±iÆ€;lvá»šá»›á»ŸäµonÂ»á»›;äµÈ€csuvá»ªá»³á¼‹á¼£Ä€ioá»¯á¸±rcÂ»á¸®É©á»¹\0\0á»»Ã­ÕˆantÄ€glá¼‚á¼†trÂ»á¹essÂ»á¹ºÆ€aeiá¼’á¼–á¼šls;ä€½st;æ‰ŸvÄ€;DÈµá¼ D;æ©¸parsl;æ§¥Ä€Daá¼¯á¼³ot;æ‰“rr;æ¥±Æ€cdiá¼¾á½á»¸r;æ„¯oÃ´Í’Ä€ahá½‰á½‹;ä·è€»Ã°äƒ°Ä€mrá½“á½—lè€»Ã«äƒ«o;æ‚¬Æ€cipá½¡á½¤á½§l;ä€¡sÃ´Õ®Ä€eoá½¬á½´ctatioÃ®Õ™nentialÃ¥Õ¹à§¡á¾’\0á¾\0á¾¡á¾§\0\0á¿†á¿Œ\0á¿“\0á¿¦á¿ªâ€€\0â€ˆâšllingdotseÃ±á¹„y;ä‘„male;æ™€Æ€ilrá¾­á¾³á¿lig;è€€ï¬ƒÉ©á¾¹\0\0á¾½g;è€€ï¬€ig;è€€ï¬„;ì€€ğ”£lig;è€€ï¬lig;ì€€fjÆ€altá¿™á¿œá¿¡t;æ™­ig;è€€ï¬‚ns;æ–±of;ä†’Ç°á¿®\0á¿³f;ì€€ğ•—Ä€akÖ¿á¿·Ä€;vá¿¼á¿½æ‹”;æ«™artint;æ¨Ä€aoâ€Œâ•Ä€csâ€‘â’Î±â€šâ€°â€¸â…âˆ\0âÎ²â€¢â€¥â€§â€ªâ€¬\0â€®è€»Â½ä‚½;æ…“è€»Â¼ä‚¼;æ…•;æ…™;æ…›Æ³â€´\0â€¶;æ…”;æ…–Ê´â€¾â\0\0âƒè€»Â¾ä‚¾;æ…—;æ…œ5;æ…˜Æ¶âŒ\0â;æ…š;æ…8;æ…l;æ„wn;æŒ¢cr;ì€€ğ’»à¢€Eabcdefgijlnorstvâ‚‚â‚‰â‚Ÿâ‚¥â‚°â‚´âƒ°âƒµâƒºâƒ¿â„ƒâ„’â„¸Ì—â„¾â…’â†Ä€;lÙâ‚‡;æªŒÆ€cmpâ‚â‚•â‚ute;ä‡µmaÄ€;dâ‚œá³šä³;æª†reve;ä„ŸÄ€iyâ‚ªâ‚®rc;ä„;ä³ot;ä„¡È€;lqsØ¾Ù‚â‚½âƒ‰Æ€;qsØ¾ÙŒâƒ„lanÃ´Ù¥È€;cdlÙ¥âƒ’âƒ•âƒ¥c;æª©otÄ€;oâƒœâƒæª€Ä€;lâƒ¢âƒ£æª‚;æª„Ä€;eâƒªâƒ­ì€€â‹›ï¸€s;æª”r;ì€€ğ”¤Ä€;gÙ³Ø›mel;æ„·cy;ä‘“È€;EajÙšâ„Œâ„â„;æª’;æª¥;æª¤È€Eaesâ„›â„â„©â„´;æ‰©pÄ€;pâ„£â„¤æªŠroxÂ»â„¤Ä€;qâ„®â„¯æªˆÄ€;qâ„®â„›im;æ‹§pf;ì€€ğ•˜Ä€ciâ…ƒâ…†r;æ„ŠmÆ€;elÙ«â…â…;æª;æªèŒ€>;cdlqr×®â… â…ªâ…®â…³â…¹Ä€ciâ…¥â…§;æª§r;æ©ºot;æ‹—Par;æ¦•uest;æ©¼Ê€adelsâ†„â…ªâ†Ù–â†›Ç°â†‰\0â†proÃ¸â‚r;æ¥¸qÄ€lqØ¿â†–lesÃ³â‚ˆiÃ­Ù«Ä€enâ†£â†­rtneqq;ì€€â‰©ï¸€Ã…â†ªÔ€Aabcefkosyâ‡„â‡‡â‡±â‡µâ‡ºâˆ˜âˆâˆ¯â‰¨â‰½rÃ²Î È€ilmrâ‡â‡”â‡—â‡›rsÃ°á’„fÂ»â€¤ilÃ´Ú©Ä€drâ‡ â‡¤cy;ä‘ŠÆ€;cwà£´â‡«â‡¯ir;æ¥ˆ;æ†­ar;æ„irc;ä„¥Æ€alrâˆâˆâˆ“rtsÄ€;uâˆ‰âˆŠæ™¥itÂ»âˆŠlip;æ€¦con;æŠ¹r;ì€€ğ”¥sÄ€ewâˆ£âˆ©arow;æ¤¥arow;æ¤¦Ê€amoprâˆºâˆ¾â‰ƒâ‰â‰£rr;æ‡¿tht;æˆ»kÄ€lrâ‰‰â‰“eftarrow;æ†©ightarrow;æ†ªf;ì€€ğ•™bar;æ€•Æ€cltâ‰¯â‰´â‰¸r;ì€€ğ’½asÃ¨â‡´rok;ä„§Ä€bpâŠ‚âŠ‡ull;æƒhenÂ»á±›à«¡âŠ£\0âŠª\0âŠ¸â‹…â‹\0â‹•â‹³\0\0â‹¸âŒ¢â§â¢â¿\0â†âªâ´cuteè€»Ã­äƒ­Æ€;iyİ±âŠ°âŠµrcè€»Ã®äƒ®;ä¸Ä€cxâŠ¼âŠ¿y;äµclè€»Â¡ä‚¡Ä€frÎŸâ‹‰;ì€€ğ”¦raveè€»Ã¬äƒ¬È€;inoÜ¾â‹â‹©â‹®Ä€inâ‹¢â‹¦nt;æ¨Œt;æˆ­fin;æ§œta;æ„©lig;ä„³Æ€aopâ‹¾âŒšâŒÆ€cgtâŒ…âŒˆâŒ—r;ä„«Æ€elpÜŸâŒâŒ“inÃ¥ŞarÃ´Ü h;ä„±f;æŠ·ed;ä†µÊ€;cfotÓ´âŒ¬âŒ±âŒ½âare;æ„…inÄ€;tâŒ¸âŒ¹æˆie;æ§doÃ´âŒ™Ê€;celpİ—âŒââ›â¡al;æŠºÄ€grâ•â™erÃ³á•£Ã£âarhk;æ¨—rod;æ¨¼È€cgptâ¯â²â¶â»y;ä‘‘on;ä„¯f;ì€€ğ•ša;ä¹uestè€»Â¿ä‚¿Ä€ciâŠâr;ì€€ğ’¾nÊ€;EdsvÓ´â›ââ¡Ó³;æ‹¹ot;æ‹µÄ€;vâ¦â§æ‹´;æ‹³Ä€;iİ·â®lde;ä„©Ç«â¸\0â¼cy;ä‘–lè€»Ã¯äƒ¯Ì€cfmosuâŒâ—âœâ¡â§âµÄ€iyâ‘â•rc;ä„µ;ä¹r;ì€€ğ”§ath;äˆ·pf;ì€€ğ•›Ç£â¬\0â±r;ì€€ğ’¿rcy;ä‘˜kcy;ä‘”Ğ€acfghjosâ‹â–â¢â§â­â±âµâ»ppaÄ€;vâ“â”äº;ä°Ä€eyâ›â dil;ä„·;äºr;ì€€ğ”¨reen;ä„¸cy;ä‘…cy;ä‘œpf;ì€€ğ•œcr;ì€€ğ“€à®€ABEHabcdefghjlmnoprstuvâ‘°â’â’†â’â’‘â”â”½â•šâ–€â™â™â™¥â™¹â™½âššâš²â›˜ââ¨â‹âŸ€â â ’Æ€artâ‘·â‘ºâ‘¼rÃ²à§†Ã²Î•ail;æ¤›arr;æ¤Ä€;gà¦”â’‹;æª‹ar;æ¥¢à¥£â’¥\0â’ª\0â’±\0\0\0\0\0â’µâ’º\0â“†â“ˆâ“\0â“¹ute;ä„ºmptyv;æ¦´raÃ®à¡Œbda;ä»gÆ€;dlà¢â“â“ƒ;æ¦‘Ã¥à¢;æª…uoè€»Â«ä‚«rĞ€;bfhlpstà¢™â“â“¦â“©â“«â“®â“±â“µÄ€;fà¢â“£s;æ¤Ÿs;æ¤Ã«â‰’p;æ†«l;æ¤¹im;æ¥³l;æ†¢Æ€;aeâ“¿â”€â”„æª«il;æ¤™Ä€;sâ”‰â”Šæª­;ì€€âª­ï¸€Æ€abrâ”•â”™â”rr;æ¤Œrk;æ²Ä€akâ”¢â”¬cÄ€ekâ”¨â”ª;ä»;ä›Ä€esâ”±â”³;æ¦‹lÄ€duâ”¹â”»;æ¦;æ¦È€aeuyâ•†â•‹â•–â•˜ron;ä„¾Ä€diâ•â•”il;ä„¼Ã¬à¢°Ã¢â”©;ä»È€cqrsâ•£â•¦â•­â•½a;æ¤¶uoÄ€;rà¸™á†Ä€duâ•²â•·har;æ¥§shar;æ¥‹h;æ†²Ê€;fgqsâ–‹â–Œà¦‰â—³â—¿æ‰¤tÊ€ahlrtâ–˜â–¤â–·â—‚â—¨rrowÄ€;tà¢™â–¡aÃ©â“¶arpoonÄ€duâ–¯â–´ownÂ»ÑšpÂ»à¥¦eftarrows;æ‡‡ightÆ€ahsâ—â—–â—rrowÄ€;sà£´à¢§arpoonÃ³à¾˜quigarroÃ·â‡°hreetimes;æ‹‹Æ€;qsâ–‹à¦“â—ºlanÃ´à¦¬Ê€;cdgsà¦¬â˜Šâ˜â˜â˜¨c;æª¨otÄ€;oâ˜”â˜•æ©¿Ä€;râ˜šâ˜›æª;æªƒÄ€;eâ˜¢â˜¥ì€€â‹šï¸€s;æª“Ê€adegsâ˜³â˜¹â˜½â™‰â™‹pproÃ¸â“†ot;æ‹–qÄ€gqâ™ƒâ™…Ã´à¦‰gtÃ²â’ŒÃ´à¦›iÃ­à¦²Æ€ilrâ™•à£¡â™šsht;æ¥¼;ì€€ğ”©Ä€;Eà¦œâ™£;æª‘Å¡â™©â™¶rÄ€duâ–²â™®Ä€;là¥¥â™³;æ¥ªlk;æ–„cy;ä‘™Ê€;achtà©ˆâšˆâš‹âš‘âš–rÃ²â—orneÃ²á´ˆard;æ¥«ri;æ—ºÄ€ioâšŸâš¤dot;ä…€ustÄ€;aâš¬âš­æ°cheÂ»âš­È€Eaesâš»âš½â›‰â›”;æ‰¨pÄ€;pâ›ƒâ›„æª‰roxÂ»â›„Ä€;qâ›â›æª‡Ä€;qâ›âš»im;æ‹¦Ğ€abnoptwzâ›©â›´â›·âœšâœ¯ââ‡âÄ€nrâ›®â›±g;æŸ¬r;æ‡½rÃ«à£gÆ€lmrâ›¿âœâœ”eftÄ€arà§¦âœ‡ightÃ¡à§²apsto;æŸ¼ightÃ¡à§½parrowÄ€lrâœ¥âœ©efÃ´â“­ight;æ†¬Æ€aflâœ¶âœ¹âœ½r;æ¦…;ì€€ğ•us;æ¨­imes;æ¨´Å¡â‹âst;æˆ—Ã¡áÆ€;efâ—â˜á €æ—ŠngeÂ»â˜arÄ€;lâ¤â¥ä€¨t;æ¦“Ê€achmtâ³â¶â¼â…â‡rÃ²à¢¨orneÃ²á¶ŒarÄ€;dà¾˜âƒ;æ¥­;æ€ri;æŠ¿Ì€achiqtâ˜âà©€â¢â®â»quo;æ€¹r;ì€€ğ“mÆ€;egà¦²âªâ¬;æª;æªÄ€buâ”ªâ³oÄ€;rà¸Ÿâ¹;æ€šrok;ä…‚è€<;cdhilqrà «âŸ’â˜¹âŸœâŸ âŸ¥âŸªâŸ°Ä€ciâŸ—âŸ™;æª¦r;æ©¹reÃ¥â—²mes;æ‹‰arr;æ¥¶uest;æ©»Ä€PiâŸµâŸ¹ar;æ¦–Æ€;efâ €à¤­á ›æ—ƒrÄ€duâ ‡â shar;æ¥Šhar;æ¥¦Ä€enâ —â ¡rtneqq;ì€€â‰¨ï¸€Ã…â Ü€Dacdefhilnopsuâ¡€â¡…â¢‚â¢â¢“â¢ â¢¥â¢¨â£šâ£¢â£¤àªƒâ£³â¤‚Dot;æˆºÈ€clprâ¡â¡’â¡£â¡½rè€»Â¯ä‚¯Ä€etâ¡—â¡™;æ™‚Ä€;eâ¡â¡Ÿæœ seÂ»â¡ŸÄ€;sá€»â¡¨toÈ€;dluá€»â¡³â¡·â¡»owÃ®ÒŒefÃ´à¤Ã°á‘ker;æ–®Ä€oyâ¢‡â¢Œmma;æ¨©;ä¼ash;æ€”asuredangleÂ»á˜¦r;ì€€ğ”ªo;æ„§Æ€cdnâ¢¯â¢´â£‰roè€»Âµä‚µÈ€;acdá‘¤â¢½â£€â£„sÃ´áš§ir;æ«°otè‚»Â·ÆµusÆ€;bdâ£’á¤ƒâ£“æˆ’Ä€;uá´¼â£˜;æ¨ªÅ£â£â£¡p;æ«›Ã²âˆ’Ã°àªÄ€dpâ£©â£®els;æŠ§f;ì€€ğ•Ä€ctâ£¸â£½r;ì€€ğ“‚posÂ»á–Æ€;lmâ¤‰â¤Šâ¤ä¼timap;æŠ¸à°€GLRVabcdefghijlmoprstuvwâ¥‚â¥“â¥¾â¦‰â¦˜â§šâ§©â¨•â¨šâ©˜â©âªƒâª•âª¤âª¨â¬„â¬‡â­„â­¿â®®â°´â±§â±¼â³©Ä€gtâ¥‡â¥‹;ì€€â‹™Ì¸Ä€;vâ¥à¯ì€€â‰«âƒ’Æ€eltâ¥šâ¥²â¥¶ftÄ€arâ¥¡â¥§rrow;æ‡ightarrow;æ‡;ì€€â‹˜Ì¸Ä€;vâ¥»à±‡ì€€â‰ªâƒ’ightarrow;æ‡Ä€Ddâ¦â¦“ash;æŠ¯ash;æŠ®Ê€bcnptâ¦£â¦§â¦¬â¦±â§ŒlaÂ»Ëute;ä…„g;ì€€âˆ âƒ’Ê€;Eiopà¶„â¦¼â§€â§…â§ˆ;ì€€â©°Ì¸d;ì€€â‰‹Ì¸s;ä…‰roÃ¸à¶„urÄ€;aâ§“â§”æ™®lÄ€;sâ§“à¬¸Ç³â§Ÿ\0â§£pè‚»Â à¬·mpÄ€;eà¯¹à°€Ê€aeouyâ§´â§¾â¨ƒâ¨â¨“Ç°â§¹\0â§»;æ©ƒon;ä…ˆdil;ä…†ngÄ€;dàµ¾â¨Šot;ì€€â©­Ì¸p;æ©‚;ä½ash;æ€“Î€;Aadqsxà®’â¨©â¨­â¨»â©â©…â©rr;æ‡—rÄ€hrâ¨³â¨¶k;æ¤¤Ä€;oá²á°ot;ì€€â‰Ì¸uiÃ¶à­£Ä€eiâ©Šâ©ar;æ¤¨Ã­à®˜istÄ€;sà® à®Ÿr;ì€€ğ”«È€Eestà¯…â©¦â©¹â©¼Æ€;qsà®¼â©­à¯¡Æ€;qsà®¼à¯…â©´lanÃ´à¯¢iÃ­à¯ªÄ€;rà®¶âªÂ»à®·Æ€AapâªŠâªâª‘rÃ²â¥±rr;æ†®ar;æ«²Æ€;svà¾âªœà¾ŒÄ€;dâª¡âª¢æ‹¼;æ‹ºcy;ä‘šÎ€AEadestâª·âªºâª¾â«‚â«…â«¶â«¹rÃ²â¥¦;ì€€â‰¦Ì¸rr;æ†šr;æ€¥È€;fqsà°»â«â«£â«¯tÄ€arâ«”â«™rroÃ·â«ightarroÃ·âªÆ€;qsà°»âªºâ«ªlanÃ´à±•Ä€;sà±•â«´Â»à°¶iÃ­à±Ä€;rà°µâ«¾iÄ€;eà°šà°¥iÃ¤à¶Ä€ptâ¬Œâ¬‘f;ì€€ğ•Ÿè†€Â¬;inâ¬™â¬šâ¬¶ä‚¬nÈ€;Edvà®‰â¬¤â¬¨â¬®;ì€€â‹¹Ì¸ot;ì€€â‹µÌ¸Ç¡à®‰â¬³â¬µ;æ‹·;æ‹¶iÄ€;và²¸â¬¼Ç¡à²¸â­â­ƒ;æ‹¾;æ‹½Æ€aorâ­‹â­£â­©rÈ€;astà­»â­•â­šâ­ŸlleÃ¬à­»l;ì€€â«½âƒ¥;ì€€âˆ‚Ì¸lint;æ¨”Æ€;ceà²’â­°â­³uÃ¥à²¥Ä€;cà²˜â­¸Ä€;eà²’â­½Ã±à²˜È€Aaitâ®ˆâ®‹â®â®§rÃ²â¦ˆrrÆ€;cwâ®”â®•â®™æ†›;ì€€â¤³Ì¸;ì€€â†Ì¸ghtarrowÂ»â®•riÄ€;eà³‹à³–Î€chimpquâ®½â¯â¯™â¬„à­¸â¯¤â¯¯È€;cerà´²â¯†à´·â¯‰uÃ¥àµ…;ì€€ğ“ƒortÉ­â¬…\0\0â¯–arÃ¡â­–mÄ€;eàµ®â¯ŸÄ€;qàµ´àµ³suÄ€bpâ¯«â¯­Ã¥à³¸Ã¥à´‹Æ€bcpâ¯¶â°‘â°™È€;Eesâ¯¿â°€à´¢â°„æŠ„;ì€€â«…Ì¸etÄ€;eà´›â°‹qÄ€;qà´£â°€cÄ€;eà´²â°—Ã±à´¸È€;Eesâ°¢â°£àµŸâ°§æŠ…;ì€€â«†Ì¸etÄ€;eàµ˜â°®qÄ€;qàµ â°£È€gilrâ°½â°¿â±…â±‡Ã¬à¯—ldeè€»Ã±äƒ±Ã§à±ƒiangleÄ€lrâ±’â±œeftÄ€;eà°šâ±šÃ±à°¦ightÄ€;eà³‹â±¥Ã±à³—Ä€;mâ±¬â±­ä½Æ€;esâ±´â±µâ±¹ä€£ro;æ„–p;æ€‡Ò€DHadgilrsâ²â²”â²™â²â²£â²°â²¶â³“â³£ash;æŠ­arr;æ¤„p;ì€€â‰âƒ’ash;æŠ¬Ä€etâ²¨â²¬;ì€€â‰¥âƒ’;ì€€>âƒ’nfin;æ§Æ€Aetâ²½â³â³…rr;æ¤‚;ì€€â‰¤âƒ’Ä€;râ³Šâ³ì€€<âƒ’ie;ì€€âŠ´âƒ’Ä€Atâ³˜â³œrr;æ¤ƒrie;ì€€âŠµâƒ’im;ì€€âˆ¼âƒ’Æ€Aanâ³°â³´â´‚rr;æ‡–rÄ€hrâ³ºâ³½k;æ¤£Ä€;oá§á¥ear;æ¤§á‰“áª•\0\0\0\0\0\0\0\0\0\0\0\0\0â´­\0â´¸âµˆâµ âµ¥âµ²â¶„á¬‡\0\0â¶â¶«\0â·ˆâ·\0â·œâ¸™â¸«â¸¾â¹ƒÄ€csâ´±áª—uteè€»Ã³äƒ³Ä€iyâ´¼âµ…rÄ€;cáªâµ‚è€»Ã´äƒ´;ä¾Ê€abiosáª âµ’âµ—Çˆâµšlac;ä…‘v;æ¨¸old;æ¦¼lig;ä…“Ä€crâµ©âµ­ir;æ¦¿;ì€€ğ”¬Í¯âµ¹\0\0âµ¼\0â¶‚n;ä‹›aveè€»Ã²äƒ²;æ§Ä€bmâ¶ˆà·´ar;æ¦µÈ€acitâ¶•â¶˜â¶¥â¶¨rÃ²áª€Ä€irâ¶â¶ r;æ¦¾oss;æ¦»nÃ¥à¹’;æ§€Æ€aeiâ¶±â¶µâ¶¹cr;ä…ga;ä‰Æ€cdnâ·€â·…Çron;ä¿;æ¦¶pf;ì€€ğ• Æ€aelâ·”â·—Ç’r;æ¦·rp;æ¦¹Î€;adiosvâ·ªâ·«â·®â¸ˆâ¸â¸â¸–æˆ¨rÃ²áª†È€;efmâ··â·¸â¸‚â¸…æ©rÄ€;oâ·¾â·¿æ„´fÂ»â·¿è€»Âªä‚ªè€»Âºä‚ºgof;æŠ¶r;æ©–lope;æ©—;æ©›Æ€cloâ¸Ÿâ¸¡â¸§Ã²â¸ashè€»Ã¸äƒ¸l;æŠ˜iÅ¬â¸¯â¸´deè€»ÃµäƒµesÄ€;aÇ›â¸ºs;æ¨¶mlè€»Ã¶äƒ¶bar;æŒ½à«¡â¹\0â¹½\0âº€âº\0âº¢âº¹\0\0â»‹àºœ\0â¼“\0\0â¼«â¾¼\0â¿ˆrÈ€;astĞƒâ¹§â¹²àº…è„€Â¶;lâ¹­â¹®ä‚¶leÃ¬ĞƒÉ©â¹¸\0\0â¹»m;æ«³;æ«½y;ä¿rÊ€cimptâº‹âºâº“á¡¥âº—nt;ä€¥od;ä€®il;æ€°enk;æ€±r;ì€€ğ”­Æ€imoâº¨âº°âº´Ä€;vâº­âº®ä†;ä•maÃ´à©¶ne;æ˜Æ€;tvâº¿â»€â»ˆä€chforkÂ»á¿½;ä–Ä€auâ»â»ŸnÄ€ckâ»•â»kÄ€;hâ‡´â»›;æ„Ã¶â‡´sÒ€;abcdemstâ»³â»´á¤ˆâ»¹â»½â¼„â¼†â¼Šâ¼ä€«cir;æ¨£ir;æ¨¢Ä€ouáµ€â¼‚;æ¨¥;æ©²nè‚»Â±àºim;æ¨¦wo;æ¨§Æ€ipuâ¼™â¼ â¼¥ntint;æ¨•f;ì€€ğ•¡ndè€»Â£ä‚£Ô€;Eaceinosuà»ˆâ¼¿â½â½„â½‡â¾â¾‰â¾’â½¾â¾¶;æª³p;æª·uÃ¥à»™Ä€;cà»â½ŒÌ€;acensà»ˆâ½™â½Ÿâ½¦â½¨â½¾pproÃ¸â½ƒurlyeÃ±à»™Ã±à»Æ€aesâ½¯â½¶â½ºpprox;æª¹qq;æªµim;æ‹¨iÃ­à»ŸmeÄ€;sâ¾ˆàº®æ€²Æ€Easâ½¸â¾â½ºÃ°â½µÆ€dfpà»¬â¾™â¾¯Æ€alsâ¾ â¾¥â¾ªlar;æŒ®ine;æŒ’urf;æŒ“Ä€;tà»»â¾´Ã¯à»»rel;æŠ°Ä€ciâ¿€â¿…r;ì€€ğ“…;äˆncsp;æ€ˆÌ€fiopsuâ¿šâ‹¢â¿Ÿâ¿¥â¿«â¿±r;ì€€ğ”®pf;ì€€ğ•¢rime;æ—cr;ì€€ğ“†Æ€aeoâ¿¸ã€‰ã€“tÄ€eiâ¿¾ã€…rnionÃ³Ú°nt;æ¨–stÄ€;eã€ã€‘ä€¿Ã±á¼™Ã´à¼”àª€ABHabcdefhilmnoprstuxã€ã‘ã•ã™ãƒ ã„ã„«ã…‡ã…¢ã…²ã†ãˆ†ãˆ•ãˆ¤ãˆ©ã‰˜ã‰®ã‰²ãŠãŠ°ãŠ·Æ€artã‡ãŠãŒrÃ²á‚³Ã²Ïail;æ¤œarÃ²á±¥ar;æ¥¤Î€cdenqrtã¨ãµã¸ã¿ã‚ã‚”ãƒŒÄ€euã­ã±;ì€€âˆ½Ì±te;ä…•iÃ£á…®mptyv;æ¦³gÈ€;delà¿‘ã‚‰ã‚‹ã‚;æ¦’;æ¦¥Ã¥à¿‘uoè€»Â»ä‚»rÖ€;abcfhlpstwà¿œã‚¬ã‚¯ã‚·ã‚¹ã‚¼ã‚¾ãƒ€ãƒƒãƒ‡ãƒŠp;æ¥µÄ€;fà¿ ã‚´s;æ¤ ;æ¤³s;æ¤Ã«â‰Ã°âœ®l;æ¥…im;æ¥´l;æ†£;æ†Ä€aiãƒ‘ãƒ•il;æ¤šoÄ€;nãƒ›ãƒœæˆ¶alÃ³à¼Æ€abrãƒ§ãƒªãƒ®rÃ²áŸ¥rk;æ³Ä€akãƒ³ãƒ½cÄ€ekãƒ¹ãƒ»;ä½;äÄ€esã„‚ã„„;æ¦ŒlÄ€duã„Šã„Œ;æ¦;æ¦È€aeuyã„—ã„œã„§ã„©ron;ä…™Ä€diã„¡ã„¥il;ä…—Ã¬à¿²Ã¢ãƒº;ä‘€È€clqsã„´ã„·ã„½ã…„a;æ¤·dhar;æ¥©uoÄ€;rÈÈh;æ†³Æ€acgã…ã…Ÿà½„lÈ€;ipsà½¸ã…˜ã…›á‚œnÃ¥á‚»arÃ´à¾©t;æ–­Æ€ilrã…©á€£ã…®sht;æ¥½;ì€€ğ”¯Ä€aoã…·ã††rÄ€duã…½ã…¿Â»Ñ»Ä€;lá‚‘ã†„;æ¥¬Ä€;vã†‹ã†Œä;ä±Æ€gnsã†•ã‡¹ã‡¼htÌ€ahlrstã†¤ã†°ã‡‚ã‡˜ã‡¤ã‡®rrowÄ€;tà¿œã†­aÃ©ãƒˆarpoonÄ€duã†»ã†¿owÃ®ã…¾pÂ»á‚’eftÄ€ahã‡Šã‡rrowÃ³à¿ªarpoonÃ³Õ‘ightarrows;æ‡‰quigarroÃ·ãƒ‹hreetimes;æ‹Œg;ä‹šingdotseÃ±á¼²Æ€ahmãˆãˆãˆ“rÃ²à¿ªaÃ²Õ‘;æ€oustÄ€;aãˆãˆŸæ±cheÂ»ãˆŸmid;æ«®È€abptãˆ²ãˆ½ã‰€ã‰’Ä€nrãˆ·ãˆºg;æŸ­r;æ‡¾rÃ«á€ƒÆ€aflã‰‡ã‰Šã‰r;æ¦†;ì€€ğ•£us;æ¨®imes;æ¨µÄ€apã‰ã‰§rÄ€;gã‰£ã‰¤ä€©t;æ¦”olint;æ¨’arÃ²ã‡£È€achqã‰»ãŠ€á‚¼ãŠ…quo;æ€ºr;ì€€ğ“‡Ä€buãƒ»ãŠŠoÄ€;rÈ”È“Æ€hirãŠ—ãŠ›ãŠ reÃ¥ã‡¸mes;æ‹ŠiÈ€;eflãŠªá™á ¡ãŠ«æ–¹tri;æ§luhar;æ¥¨;æ„àµ¡ã‹•ã‹›ã‹ŸãŒ¬ãŒ¸ã±\0ãºã¤\0\0ã¬ã°\0ã¨ã‘ˆã‘šã’­ã’±ã“Šã“±\0ã˜–\0\0ã˜³cute;ä…›quÃ¯âºÔ€;Eaceinpsyá‡­ã‹³ã‹µã‹¿ãŒ‚ãŒ‹ãŒãŒŸãŒ¦ãŒ©;æª´Ç°ã‹º\0ã‹¼;æª¸on;ä…¡uÃ¥á‡¾Ä€;dá‡³ãŒ‡il;ä…Ÿrc;ä…Æ€EasãŒ–ãŒ˜ãŒ›;æª¶p;æªºim;æ‹©olint;æ¨“iÃ­áˆ„;ä‘otÆ€;beãŒ´áµ‡ãŒµæ‹…;æ©¦Î€Aacmstxã†ãŠã—ã›ãã£ã­rr;æ‡˜rÄ€hrãã’Ã«âˆ¨Ä€;oà¨¶à¨´tè€»Â§ä‚§i;ä€»war;æ¤©mÄ€inã©Ã°nuÃ³Ã±t;æœ¶rÄ€;oã¶â•ì€€ğ”°È€acoyã‚ã†ã‘ã rp;æ™¯Ä€hyã‹ãcy;ä‘‰;ä‘ˆrtÉ­ã™\0\0ãœiÃ¤á‘¤araÃ¬â¹¯è€»Â­ä‚­Ä€gmã¨ã´maÆ€;fvã±ã²ã²äƒ;ä‚Ğ€;deglnpráŠ«ã…ã‰ãã–ãã¡ã¦ot;æ©ªÄ€;qáŠ±áŠ°Ä€;Eã“ã”æª;æª Ä€;Eã›ãœæª;æªŸe;æ‰†lus;æ¨¤arr;æ¥²arÃ²á„½È€aeitã¸ãˆãã—Ä€lsã½ã„lsetmÃ©ãªhp;æ¨³parsl;æ§¤Ä€dlá‘£ã”e;æŒ£Ä€;eãœãæªªÄ€;sã¢ã£æª¬;ì€€âª¬ï¸€Æ€flpã®ã³ã‘‚tcy;ä‘ŒÄ€;bã¸ã¹ä€¯Ä€;aã¾ã¿æ§„r;æŒ¿f;ì€€ğ•¤aÄ€drã‘Ğ‚esÄ€;uã‘”ã‘•æ™ itÂ»ã‘•Æ€csuã‘ ã‘¹ã’ŸÄ€auã‘¥ã‘¯pÄ€;sá†ˆã‘«;ì€€âŠ“ï¸€pÄ€;sá†´ã‘µ;ì€€âŠ”ï¸€uÄ€bpã‘¿ã’Æ€;esá†—á†œã’†etÄ€;eá†—ã’Ã±á†Æ€;esá†¨á†­ã’–etÄ€;eá†¨ã’Ã±á†®Æ€;afá…»ã’¦Ö°rÅ¥ã’«Ö±Â»á…¼arÃ²á…ˆÈ€cemtã’¹ã’¾ã“‚ã“…r;ì€€ğ“ˆtmÃ®Ã±iÃ¬ã•arÃ¦á†¾Ä€arã“ã“•rÄ€;fã“”á¿æ˜†Ä€anã“šã“­ightÄ€epã“£ã“ªpsiloÃ®á» hÃ©âº¯sÂ»â¡’Ê€bcmnpã“»ã•áˆ‰ã–‹ã–Ò€;Edemnprsã”ã”ã”‘ã”•ã”ã”£ã”¬ã”±ã”¶æŠ‚;æ«…ot;æª½Ä€;dá‡šã”šot;æ«ƒult;æ«Ä€Eeã”¨ã”ª;æ«‹;æŠŠlus;æª¿arr;æ¥¹Æ€eiuã”½ã•’ã••tÆ€;enã”ã•…ã•‹qÄ€;qá‡šã”eqÄ€;qã”«ã”¨m;æ«‡Ä€bpã•šã•œ;æ«•;æ«“cÌ€;acensá‡­ã•¬ã•²ã•¹ã•»ãŒ¦pproÃ¸ã‹ºurlyeÃ±á‡¾Ã±á‡³Æ€aesã–‚ã–ˆãŒ›pproÃ¸ãŒšqÃ±ãŒ—g;æ™ªÚ€123;Edehlmnpsã–©ã–¬ã–¯áˆœã–²ã–´ã—€ã—‰ã—•ã—šã—Ÿã—¨ã—­è€»Â¹ä‚¹è€»Â²ä‚²è€»Â³ä‚³;æ«†Ä€osã–¹ã–¼t;æª¾ub;æ«˜Ä€;dáˆ¢ã—…ot;æ«„sÄ€ouã—ã—’l;æŸ‰b;æ«—arr;æ¥»ult;æ«‚Ä€Eeã—¤ã—¦;æ«Œ;æŠ‹lus;æ«€Æ€eiuã—´ã˜‰ã˜ŒtÆ€;enáˆœã—¼ã˜‚qÄ€;qáˆ¢ã–²eqÄ€;qã—§ã—¤m;æ«ˆÄ€bpã˜‘ã˜“;æ«”;æ«–Æ€Aanã˜œã˜ ã˜­rr;æ‡™rÄ€hrã˜¦ã˜¨Ã«âˆ®Ä€;oà¨«à¨©war;æ¤ªligè€»ÃŸäƒŸà¯¡ã™‘ã™ã™ á‹ã™³ã™¹\0ã™¾ã›‚\0\0\0\0\0ã››ãœƒ\0ãœ‰ã¬\0\0\0ã‡É²ã™–\0\0ã™›get;æŒ–;ä„rÃ«à¹ŸÆ€aeyã™¦ã™«ã™°ron;ä…¥dil;ä…£;ä‘‚lrec;æŒ•r;ì€€ğ”±È€eikoãš†ãšãšµãš¼Ç²ãš‹\0ãš‘eÄ€4fáŠ„áŠaÆ€;svãš˜ãš™ãš›ä¸ym;ä‘Ä€cnãš¢ãš²kÄ€asãš¨ãš®pproÃ¸á‹imÂ»áŠ¬sÃ°áŠÄ€asãšºãš®Ã°á‹rnè€»Ã¾äƒ¾Ç¬ÌŸã›†â‹§esè†€Ã—;bdã›ã›ã›˜äƒ—Ä€;aá¤ã›•r;æ¨±;æ¨°Æ€epsã›¡ã›£ãœ€Ã¡â©È€;bcfÒ†ã›¬ã›°ã›´ot;æŒ¶ir;æ«±Ä€;oã›¹ã›¼ì€€ğ•¥rk;æ«šÃ¡ã¢rime;æ€´Æ€aipãœãœ’ã¤dÃ¥á‰ˆÎ€adempstãœ¡ãã€ã‘ã—ãœãŸngleÊ€;dlqrãœ°ãœ±ãœ¶ã€ã‚æ–µownÂ»á¶»eftÄ€;eâ €ãœ¾Ã±à¤®;æ‰œightÄ€;eãŠªã‹Ã±ášot;æ—¬inus;æ¨ºlus;æ¨¹b;æ§ime;æ¨»ezium;æ¢Æ€chtã²ã½ãÄ€ryã·ã»;ì€€ğ“‰;ä‘†cy;ä‘›rok;ä…§Ä€ioã‹ãxÃ´á·headÄ€lrã—ã eftarroÃ·à¡ightarrowÂ»à½à¤€AHabcdfghlmoprstuwãŸãŸ“ãŸ—ãŸ¤ãŸ°ãŸ¼ã ã œã £ã ´ã¡‘ã¡ã¡«ã¢©ã£Œã£’ã£ªã£¶rÃ²Ï­ar;æ¥£Ä€crãŸœãŸ¢uteè€»ÃºäƒºÃ²á…rÇ£ãŸª\0ãŸ­y;ä‘ve;ä…­Ä€iyãŸµãŸºrcè€»Ã»äƒ»;ä‘ƒÆ€abhã ƒã †ã ‹rÃ²á­lac;ä…±aÃ²áƒÄ€irã “ã ˜sht;æ¥¾;ì€€ğ”²raveè€»Ã¹äƒ¹Å¡ã §ã ±rÄ€lrã ¬ã ®Â»à¥—Â»á‚ƒlk;æ–€Ä€ctã ¹ã¡É¯ã ¿\0\0ã¡ŠrnÄ€;eã¡…ã¡†æŒœrÂ»ã¡†op;æŒri;æ—¸Ä€alã¡–ã¡šcr;ä…«è‚»Â¨Í‰Ä€gpã¡¢ã¡¦on;ä…³f;ì€€ğ•¦Ì€adhlsuá…‹ã¡¸ã¡½á²ã¢‘ã¢ ownÃ¡á³arpoonÄ€lrã¢ˆã¢ŒefÃ´ã ­ighÃ´ã ¯iÆ€;hlã¢™ã¢šã¢œä…Â»áºonÂ»ã¢šparrows;æ‡ˆÆ€citã¢°ã£„ã£ˆÉ¯ã¢¶\0\0ã£rnÄ€;eã¢¼ã¢½æŒrÂ»ã¢½op;æŒng;ä…¯ri;æ—¹cr;ì€€ğ“ŠÆ€dirã£™ã£ã£¢ot;æ‹°lde;ä…©iÄ€;fãœ°ã£¨Â»á “Ä€amã£¯ã£²rÃ²ã¢¨lè€»Ã¼äƒ¼angle;æ¦§Ş€ABDacdeflnoprszã¤œã¤Ÿã¤©ã¤­ã¦µã¦¸ã¦½ã§Ÿã§¤ã§¨ã§³ã§¹ã§½ã¨ã¨ rÃ²Ï·arÄ€;vã¤¦ã¤§æ«¨;æ«©asÃ¨Ï¡Ä€nrã¤²ã¤·grt;æ¦œÎ€eknprstã“£ã¥†ã¥‹ã¥’ã¥ã¥¤ã¦–appÃ¡â•othinÃ§áº–Æ€hirã“«â»ˆã¥™opÃ´â¾µÄ€;há·ã¥¢Ã¯ã†Ä€iuã¥©ã¥­gmÃ¡ã³Ä€bpã¥²ã¦„setneqÄ€;qã¥½ã¦€ì€€âŠŠï¸€;ì€€â«‹ï¸€setneqÄ€;qã¦ã¦’ì€€âŠ‹ï¸€;ì€€â«Œï¸€Ä€hrã¦›ã¦ŸetÃ¡ãšœiangleÄ€lrã¦ªã¦¯eftÂ»à¤¥ightÂ»á‘y;ä²ashÂ»á€¶Æ€elrã§„ã§’ã§—Æ€;beâ·ªã§‹ã§ar;æŠ»q;æ‰šlip;æ‹®Ä€btã§œá‘¨aÃ²á‘©r;ì€€ğ”³trÃ©ã¦®suÄ€bpã§¯ã§±Â»à´œÂ»àµ™pf;ì€€ğ•§roÃ°à»»trÃ©ã¦´Ä€cuã¨†ã¨‹r;ì€€ğ“‹Ä€bpã¨ã¨˜nÄ€Eeã¦€ã¨–Â»ã¥¾nÄ€Eeã¦’ã¨Â»ã¦igzag;æ¦šÎ€cefoprsã¨¶ã¨»ã©–ã©›ã©”ã©¡ã©ªirc;ä…µÄ€diã©€ã©‘Ä€bgã©…ã©‰ar;æ©ŸeÄ€;qá—ºã©;æ‰™erp;æ„˜r;ì€€ğ”´pf;ì€€ğ•¨Ä€;eá‘¹ã©¦atÃ¨á‘¹cr;ì€€ğ“Œà«£áãª‡\0ãª‹\0ãªãª›\0\0ãªãª¨ãª«ãª¯\0\0ã«ƒã«\0ã«˜áŸœáŸŸtrÃ©áŸ‘r;ì€€ğ”µÄ€Aaãª”ãª—rÃ²ÏƒrÃ²à§¶;ä¾Ä€Aaãª¡ãª¤rÃ²Î¸rÃ²à§«aÃ°âœ“is;æ‹»Æ€dptá¤ãªµãª¾Ä€flãªºá©;ì€€ğ•©imÃ¥á²Ä€Aaã«‡ã«ŠrÃ²ÏrÃ²à¨Ä€cqã«’á¸r;ì€€ğ“Ä€ptáŸ–ã«œrÃ©áŸ”Ğ€acefiosuã«°ã«½ã¬ˆã¬Œã¬‘ã¬•ã¬›ã¬¡cÄ€uyã«¶ã«»teè€»Ã½äƒ½;ä‘Ä€iyã¬‚ã¬†rc;ä…·;ä‘‹nè€»Â¥ä‚¥r;ì€€ğ”¶cy;ä‘—pf;ì€€ğ•ªcr;ì€€ğ“Ä€cmã¬¦ã¬©y;ä‘lè€»Ã¿äƒ¿Ô€acdefhioswã­‚ã­ˆã­”ã­˜ã­¤ã­©ã­­ã­´ã­ºã®€cute;ä…ºÄ€ayã­ã­’ron;ä…¾;ä·ot;ä…¼Ä€etã­ã­¡trÃ¦á•Ÿa;ä¶r;ì€€ğ”·cy;ä¶grarr;æ‡pf;ì€€ğ•«cr;ì€€ğ“Ä€jnã®…ã®‡;æ€j;æ€Œ'.split("").map((e10) => e10.charCodeAt(0))
);
var fg = new Uint16Array(
  // prettier-ignore
  "È€aglq	\x1BÉ­\0\0p;ä€¦os;ä€§t;ä€¾t;ä€¼uot;ä€¢".split("").map((e10) => e10.charCodeAt(0))
);
var to;
var hg = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var dg = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (to = String.fromCodePoint) !== null && to !== void 0 ? to : function(e10) {
    let t = "";
    return e10 > 65535 && (e10 -= 65536, t += String.fromCharCode(e10 >>> 10 & 1023 | 55296), e10 = 56320 | e10 & 1023), t += String.fromCharCode(e10), t;
  }
);
function pg(e10) {
  var t;
  return e10 >= 55296 && e10 <= 57343 || e10 > 1114111 ? 65533 : (t = hg.get(e10)) !== null && t !== void 0 ? t : e10;
}
var yt;
(function(e10) {
  e10[e10.NUM = 35] = "NUM", e10[e10.SEMI = 59] = "SEMI", e10[e10.EQUALS = 61] = "EQUALS", e10[e10.ZERO = 48] = "ZERO", e10[e10.NINE = 57] = "NINE", e10[e10.LOWER_A = 97] = "LOWER_A", e10[e10.LOWER_F = 102] = "LOWER_F", e10[e10.LOWER_X = 120] = "LOWER_X", e10[e10.LOWER_Z = 122] = "LOWER_Z", e10[e10.UPPER_A = 65] = "UPPER_A", e10[e10.UPPER_F = 70] = "UPPER_F", e10[e10.UPPER_Z = 90] = "UPPER_Z";
})(yt || (yt = {}));
var mg = 32;
var Qn;
(function(e10) {
  e10[e10.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e10[e10.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e10[e10.JUMP_TABLE = 127] = "JUMP_TABLE";
})(Qn || (Qn = {}));
function jo(e10) {
  return e10 >= yt.ZERO && e10 <= yt.NINE;
}
function gg(e10) {
  return e10 >= yt.UPPER_A && e10 <= yt.UPPER_F || e10 >= yt.LOWER_A && e10 <= yt.LOWER_F;
}
function bg(e10) {
  return e10 >= yt.UPPER_A && e10 <= yt.UPPER_Z || e10 >= yt.LOWER_A && e10 <= yt.LOWER_Z || jo(e10);
}
function yg(e10) {
  return e10 === yt.EQUALS || bg(e10);
}
var mt;
(function(e10) {
  e10[e10.EntityStart = 0] = "EntityStart", e10[e10.NumericStart = 1] = "NumericStart", e10[e10.NumericDecimal = 2] = "NumericDecimal", e10[e10.NumericHex = 3] = "NumericHex", e10[e10.NamedEntity = 4] = "NamedEntity";
})(mt || (mt = {}));
var Xn;
(function(e10) {
  e10[e10.Legacy = 0] = "Legacy", e10[e10.Strict = 1] = "Strict", e10[e10.Attribute = 2] = "Attribute";
})(Xn || (Xn = {}));
var xg = class {
  constructor(t, n, r) {
    this.decodeTree = t, this.emitCodePoint = n, this.errors = r, this.state = mt.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Xn.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(t) {
    this.decodeMode = t, this.state = mt.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(t, n) {
    switch (this.state) {
      case mt.EntityStart:
        return t.charCodeAt(n) === yt.NUM ? (this.state = mt.NumericStart, this.consumed += 1, this.stateNumericStart(t, n + 1)) : (this.state = mt.NamedEntity, this.stateNamedEntity(t, n));
      case mt.NumericStart:
        return this.stateNumericStart(t, n);
      case mt.NumericDecimal:
        return this.stateNumericDecimal(t, n);
      case mt.NumericHex:
        return this.stateNumericHex(t, n);
      case mt.NamedEntity:
        return this.stateNamedEntity(t, n);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(t, n) {
    return n >= t.length ? -1 : (t.charCodeAt(n) | mg) === yt.LOWER_X ? (this.state = mt.NumericHex, this.consumed += 1, this.stateNumericHex(t, n + 1)) : (this.state = mt.NumericDecimal, this.stateNumericDecimal(t, n));
  }
  addToNumericResult(t, n, r, i) {
    if (n !== r) {
      const s = r - n;
      this.result = this.result * Math.pow(i, s) + parseInt(t.substr(n, s), i), this.consumed += s;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const i = t.charCodeAt(n);
      if (jo(i) || gg(i))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 16), this.emitNumericEntity(i, 3);
    }
    return this.addToNumericResult(t, r, n, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const i = t.charCodeAt(n);
      if (jo(i))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 10), this.emitNumericEntity(i, 2);
    }
    return this.addToNumericResult(t, r, n, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(t, n) {
    var r;
    if (this.consumed <= n)
      return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (t === yt.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === Xn.Strict)
      return 0;
    return this.emitCodePoint(pg(this.result), this.consumed), this.errors && (t !== yt.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(t, n) {
    const { decodeTree: r } = this;
    let i = r[this.treeIndex], s = (i & Qn.VALUE_LENGTH) >> 14;
    for (; n < t.length; n++, this.excess++) {
      const o = t.charCodeAt(n);
      if (this.treeIndex = wg(r, i, this.treeIndex + Math.max(1, s), o), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === Xn.Attribute && // We shouldn't have consumed any characters after the entity,
        (s === 0 || // And there should be no invalid characters.
        yg(o)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (i = r[this.treeIndex], s = (i & Qn.VALUE_LENGTH) >> 14, s !== 0) {
        if (o === yt.SEMI)
          return this.emitNamedEntityData(this.treeIndex, s, this.consumed + this.excess);
        this.decodeMode !== Xn.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var t;
    const { result: n, decodeTree: r } = this, i = (r[n] & Qn.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(n, i, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(t, n, r) {
    const { decodeTree: i } = this;
    return this.emitCodePoint(n === 1 ? i[t] & ~Qn.VALUE_LENGTH : i[t + 1], r), n === 3 && this.emitCodePoint(i[t + 2], r), r;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var t;
    switch (this.state) {
      case mt.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== Xn.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case mt.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case mt.NumericHex:
        return this.emitNumericEntity(0, 3);
      case mt.NumericStart:
        return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case mt.EntityStart:
        return 0;
    }
  }
};
function Y1(e10) {
  let t = "";
  const n = new xg(e10, (r) => t += dg(r));
  return function(i, s) {
    let o = 0, l = 0;
    for (; (l = i.indexOf("&", l)) >= 0; ) {
      t += i.slice(o, l), n.startEntity(s);
      const h2 = n.write(
        i,
        // Skip the "&"
        l + 1
      );
      if (h2 < 0) {
        o = l + n.end();
        break;
      }
      o = l + h2, l = h2 === 0 ? o + 1 : o;
    }
    const f = t + i.slice(o);
    return t = "", f;
  };
}
function wg(e10, t, n, r) {
  const i = (t & Qn.BRANCH_LENGTH) >> 7, s = t & Qn.JUMP_TABLE;
  if (i === 0)
    return s !== 0 && r === s ? n : -1;
  if (s) {
    const f = r - s;
    return f < 0 || f >= i ? -1 : e10[n + f] - 1;
  }
  let o = n, l = o + i - 1;
  for (; o <= l; ) {
    const f = o + l >>> 1, h2 = e10[f];
    if (h2 < r)
      o = f + 1;
    else if (h2 > r)
      l = f - 1;
    else
      return e10[f + i];
  }
  return -1;
}
var vg = Y1(cg);
Y1(fg);
function Z1(e10, t = Xn.Legacy) {
  return vg(e10, t);
}
function kg(e10) {
  return Object.prototype.toString.call(e10);
}
function La(e10) {
  return kg(e10) === "[object String]";
}
var _g = Object.prototype.hasOwnProperty;
function Sg(e10, t) {
  return _g.call(e10, t);
}
function q0(e10) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(n) {
    if (n) {
      if (typeof n != "object")
        throw new TypeError(n + "must be object");
      Object.keys(n).forEach(function(r) {
        e10[r] = n[r];
      });
    }
  }), e10;
}
function J1(e10, t, n) {
  return [].concat(e10.slice(0, t), n, e10.slice(t + 1));
}
function qa(e10) {
  return !(e10 >= 55296 && e10 <= 57343 || e10 >= 64976 && e10 <= 65007 || (e10 & 65535) === 65535 || (e10 & 65535) === 65534 || e10 >= 0 && e10 <= 8 || e10 === 11 || e10 >= 14 && e10 <= 31 || e10 >= 127 && e10 <= 159 || e10 > 1114111);
}
function w0(e10) {
  if (e10 > 65535) {
    e10 -= 65536;
    const t = 55296 + (e10 >> 10), n = 56320 + (e10 & 1023);
    return String.fromCharCode(t, n);
  }
  return String.fromCharCode(e10);
}
var Q1 = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g;
var Ag = /&([a-z#][a-z0-9]{1,31});/gi;
var Eg = new RegExp(Q1.source + "|" + Ag.source, "gi");
var Cg = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function Tg(e10, t) {
  if (t.charCodeAt(0) === 35 && Cg.test(t)) {
    const r = t[1].toLowerCase() === "x" ? parseInt(t.slice(2), 16) : parseInt(t.slice(1), 10);
    return qa(r) ? w0(r) : e10;
  }
  const n = Z1(e10);
  return n !== e10 ? n : e10;
}
function Dg(e10) {
  return e10.indexOf("\\") < 0 ? e10 : e10.replace(Q1, "$1");
}
function Yr(e10) {
  return e10.indexOf("\\") < 0 && e10.indexOf("&") < 0 ? e10 : e10.replace(Eg, function(t, n, r) {
    return n || Tg(t, r);
  });
}
var Mg = /[&<>"]/;
var Ng = /[&<>"]/g;
var Ig = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function Fg(e10) {
  return Ig[e10];
}
function tr(e10) {
  return Mg.test(e10) ? e10.replace(Ng, Fg) : e10;
}
var Bg = /[.?*+^$[\]\\(){}|-]/g;
function Og(e10) {
  return e10.replace(Bg, "\\$&");
}
function Ge(e10) {
  switch (e10) {
    case 9:
    case 32:
      return true;
  }
  return false;
}
function Hi(e10) {
  if (e10 >= 8192 && e10 <= 8202)
    return true;
  switch (e10) {
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return true;
  }
  return false;
}
function ji(e10) {
  return $a.test(e10) || K1.test(e10);
}
function Ui(e10) {
  switch (e10) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function R0(e10) {
  return e10 = e10.trim().replace(/\s+/g, " "), "áº".toLowerCase() === "á¹¾" && (e10 = e10.replace(/áº/g, "ÃŸ")), e10.toLowerCase().toUpperCase();
}
var zg = { mdurl: og, ucmicro: lg };
var $g = Object.freeze(Object.defineProperty({
  __proto__: null,
  arrayReplaceAt: J1,
  assign: q0,
  escapeHtml: tr,
  escapeRE: Og,
  fromCodePoint: w0,
  has: Sg,
  isMdAsciiPunct: Ui,
  isPunctChar: ji,
  isSpace: Ge,
  isString: La,
  isValidEntityCode: qa,
  isWhiteSpace: Hi,
  lib: zg,
  normalizeReference: R0,
  unescapeAll: Yr,
  unescapeMd: Dg
}, Symbol.toStringTag, { value: "Module" }));
function Lg(e10, t, n) {
  let r, i, s, o;
  const l = e10.posMax, f = e10.pos;
  for (e10.pos = t + 1, r = 1; e10.pos < l; ) {
    if (s = e10.src.charCodeAt(e10.pos), s === 93 && (r--, r === 0)) {
      i = true;
      break;
    }
    if (o = e10.pos, e10.md.inline.skipToken(e10), s === 91) {
      if (o === e10.pos - 1)
        r++;
      else if (n)
        return e10.pos = f, -1;
    }
  }
  let h2 = -1;
  return i && (h2 = e10.pos), e10.pos = f, h2;
}
function qg(e10, t, n) {
  let r, i = t;
  const s = {
    ok: false,
    pos: 0,
    str: ""
  };
  if (e10.charCodeAt(i) === 60) {
    for (i++; i < n; ) {
      if (r = e10.charCodeAt(i), r === 10 || r === 60)
        return s;
      if (r === 62)
        return s.pos = i + 1, s.str = Yr(e10.slice(t + 1, i)), s.ok = true, s;
      if (r === 92 && i + 1 < n) {
        i += 2;
        continue;
      }
      i++;
    }
    return s;
  }
  let o = 0;
  for (; i < n && (r = e10.charCodeAt(i), !(r === 32 || r < 32 || r === 127)); ) {
    if (r === 92 && i + 1 < n) {
      if (e10.charCodeAt(i + 1) === 32)
        break;
      i += 2;
      continue;
    }
    if (r === 40 && (o++, o > 32))
      return s;
    if (r === 41) {
      if (o === 0)
        break;
      o--;
    }
    i++;
  }
  return t === i || o !== 0 || (s.str = Yr(e10.slice(t, i)), s.pos = i, s.ok = true), s;
}
function Rg(e10, t, n, r) {
  let i, s = t;
  const o = {
    // if `true`, this is a valid link title
    ok: false,
    // if `true`, this link can be continued on the next line
    can_continue: false,
    // if `ok`, it's the position of the first character after the closing marker
    pos: 0,
    // if `ok`, it's the unescaped title
    str: "",
    // expected closing marker character code
    marker: 0
  };
  if (r)
    o.str = r.str, o.marker = r.marker;
  else {
    if (s >= n)
      return o;
    let l = e10.charCodeAt(s);
    if (l !== 34 && l !== 39 && l !== 40)
      return o;
    t++, s++, l === 40 && (l = 41), o.marker = l;
  }
  for (; s < n; ) {
    if (i = e10.charCodeAt(s), i === o.marker)
      return o.pos = s + 1, o.str += Yr(e10.slice(t, s)), o.ok = true, o;
    if (i === 40 && o.marker === 41)
      return o;
    i === 92 && s + 1 < n && s++, s++;
  }
  return o.can_continue = true, o.str += Yr(e10.slice(t, s)), o;
}
var Pg = Object.freeze(Object.defineProperty({
  __proto__: null,
  parseLinkDestination: qg,
  parseLinkLabel: Lg,
  parseLinkTitle: Rg
}, Symbol.toStringTag, { value: "Module" }));
var gn = {};
gn.code_inline = function(e10, t, n, r, i) {
  const s = e10[t];
  return "<code" + i.renderAttrs(s) + ">" + tr(s.content) + "</code>";
};
gn.code_block = function(e10, t, n, r, i) {
  const s = e10[t];
  return "<pre" + i.renderAttrs(s) + "><code>" + tr(e10[t].content) + `</code></pre>
`;
};
gn.fence = function(e10, t, n, r, i) {
  const s = e10[t], o = s.info ? Yr(s.info).trim() : "";
  let l = "", f = "";
  if (o) {
    const p = o.split(/(\s+)/g);
    l = p[0], f = p.slice(2).join("");
  }
  let h2;
  if (n.highlight ? h2 = n.highlight(s.content, l, f) || tr(s.content) : h2 = tr(s.content), h2.indexOf("<pre") === 0)
    return h2 + `
`;
  if (o) {
    const p = s.attrIndex("class"), b = s.attrs ? s.attrs.slice() : [];
    p < 0 ? b.push(["class", n.langPrefix + l]) : (b[p] = b[p].slice(), b[p][1] += " " + n.langPrefix + l);
    const v = {
      attrs: b
    };
    return `<pre><code${i.renderAttrs(v)}>${h2}</code></pre>
`;
  }
  return `<pre><code${i.renderAttrs(s)}>${h2}</code></pre>
`;
};
gn.image = function(e10, t, n, r, i) {
  const s = e10[t];
  return s.attrs[s.attrIndex("alt")][1] = i.renderInlineAsText(s.children, n, r), i.renderToken(e10, t, n);
};
gn.hardbreak = function(e10, t, n) {
  return n.xhtmlOut ? `<br />
` : `<br>
`;
};
gn.softbreak = function(e10, t, n) {
  return n.breaks ? n.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
gn.text = function(e10, t) {
  return tr(e10[t].content);
};
gn.html_block = function(e10, t) {
  return e10[t].content;
};
gn.html_inline = function(e10, t) {
  return e10[t].content;
};
function ui() {
  this.rules = q0({}, gn);
}
ui.prototype.renderAttrs = function(t) {
  let n, r, i;
  if (!t.attrs)
    return "";
  for (i = "", n = 0, r = t.attrs.length; n < r; n++)
    i += " " + tr(t.attrs[n][0]) + '="' + tr(t.attrs[n][1]) + '"';
  return i;
};
ui.prototype.renderToken = function(t, n, r) {
  const i = t[n];
  let s = "";
  if (i.hidden)
    return "";
  i.block && i.nesting !== -1 && n && t[n - 1].hidden && (s += `
`), s += (i.nesting === -1 ? "</" : "<") + i.tag, s += this.renderAttrs(i), i.nesting === 0 && r.xhtmlOut && (s += " /");
  let o = false;
  if (i.block && (o = true, i.nesting === 1 && n + 1 < t.length)) {
    const l = t[n + 1];
    (l.type === "inline" || l.hidden || l.nesting === -1 && l.tag === i.tag) && (o = false);
  }
  return s += o ? `>
` : ">", s;
};
ui.prototype.renderInline = function(e10, t, n) {
  let r = "";
  const i = this.rules;
  for (let s = 0, o = e10.length; s < o; s++) {
    const l = e10[s].type;
    typeof i[l] < "u" ? r += i[l](e10, s, t, n, this) : r += this.renderToken(e10, s, t);
  }
  return r;
};
ui.prototype.renderInlineAsText = function(e10, t, n) {
  let r = "";
  for (let i = 0, s = e10.length; i < s; i++)
    switch (e10[i].type) {
      case "text":
        r += e10[i].content;
        break;
      case "image":
        r += this.renderInlineAsText(e10[i].children, t, n);
        break;
      case "html_inline":
      case "html_block":
        r += e10[i].content;
        break;
      case "softbreak":
      case "hardbreak":
        r += `
`;
        break;
    }
  return r;
};
ui.prototype.render = function(e10, t, n) {
  let r = "";
  const i = this.rules;
  for (let s = 0, o = e10.length; s < o; s++) {
    const l = e10[s].type;
    l === "inline" ? r += this.renderInline(e10[s].children, t, n) : typeof i[l] < "u" ? r += i[l](e10, s, t, n, this) : r += this.renderToken(e10, s, t, n);
  }
  return r;
};
function It() {
  this.__rules__ = [], this.__cache__ = null;
}
It.prototype.__find__ = function(e10) {
  for (let t = 0; t < this.__rules__.length; t++)
    if (this.__rules__[t].name === e10)
      return t;
  return -1;
};
It.prototype.__compile__ = function() {
  const e10 = this, t = [""];
  e10.__rules__.forEach(function(n) {
    n.enabled && n.alt.forEach(function(r) {
      t.indexOf(r) < 0 && t.push(r);
    });
  }), e10.__cache__ = {}, t.forEach(function(n) {
    e10.__cache__[n] = [], e10.__rules__.forEach(function(r) {
      r.enabled && (n && r.alt.indexOf(n) < 0 || e10.__cache__[n].push(r.fn));
    });
  });
};
It.prototype.at = function(e10, t, n) {
  const r = this.__find__(e10), i = n || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + e10);
  this.__rules__[r].fn = t, this.__rules__[r].alt = i.alt || [], this.__cache__ = null;
};
It.prototype.before = function(e10, t, n, r) {
  const i = this.__find__(e10), s = r || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + e10);
  this.__rules__.splice(i, 0, {
    name: t,
    enabled: true,
    fn: n,
    alt: s.alt || []
  }), this.__cache__ = null;
};
It.prototype.after = function(e10, t, n, r) {
  const i = this.__find__(e10), s = r || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + e10);
  this.__rules__.splice(i + 1, 0, {
    name: t,
    enabled: true,
    fn: n,
    alt: s.alt || []
  }), this.__cache__ = null;
};
It.prototype.push = function(e10, t, n) {
  const r = n || {};
  this.__rules__.push({
    name: e10,
    enabled: true,
    fn: t,
    alt: r.alt || []
  }), this.__cache__ = null;
};
It.prototype.enable = function(e10, t) {
  Array.isArray(e10) || (e10 = [e10]);
  const n = [];
  return e10.forEach(function(r) {
    const i = this.__find__(r);
    if (i < 0) {
      if (t)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[i].enabled = true, n.push(r);
  }, this), this.__cache__ = null, n;
};
It.prototype.enableOnly = function(e10, t) {
  Array.isArray(e10) || (e10 = [e10]), this.__rules__.forEach(function(n) {
    n.enabled = false;
  }), this.enable(e10, t);
};
It.prototype.disable = function(e10, t) {
  Array.isArray(e10) || (e10 = [e10]);
  const n = [];
  return e10.forEach(function(r) {
    const i = this.__find__(r);
    if (i < 0) {
      if (t)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[i].enabled = false, n.push(r);
  }, this), this.__cache__ = null, n;
};
It.prototype.getRules = function(e10) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[e10] || [];
};
function tn(e10, t, n) {
  this.type = e10, this.tag = t, this.attrs = null, this.map = null, this.nesting = n, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = false, this.hidden = false;
}
tn.prototype.attrIndex = function(t) {
  if (!this.attrs)
    return -1;
  const n = this.attrs;
  for (let r = 0, i = n.length; r < i; r++)
    if (n[r][0] === t)
      return r;
  return -1;
};
tn.prototype.attrPush = function(t) {
  this.attrs ? this.attrs.push(t) : this.attrs = [t];
};
tn.prototype.attrSet = function(t, n) {
  const r = this.attrIndex(t), i = [t, n];
  r < 0 ? this.attrPush(i) : this.attrs[r] = i;
};
tn.prototype.attrGet = function(t) {
  const n = this.attrIndex(t);
  let r = null;
  return n >= 0 && (r = this.attrs[n][1]), r;
};
tn.prototype.attrJoin = function(t, n) {
  const r = this.attrIndex(t);
  r < 0 ? this.attrPush([t, n]) : this.attrs[r][1] = this.attrs[r][1] + " " + n;
};
function ed(e10, t, n) {
  this.src = e10, this.env = n, this.tokens = [], this.inlineMode = false, this.md = t;
}
ed.prototype.Token = tn;
var Hg = /\r\n?|\n/g;
var jg = /\0/g;
function Ug(e10) {
  let t;
  t = e10.src.replace(Hg, `
`), t = t.replace(jg, "ï¿½"), e10.src = t;
}
function Vg(e10) {
  let t;
  e10.inlineMode ? (t = new e10.Token("inline", "", 0), t.content = e10.src, t.map = [0, 1], t.children = [], e10.tokens.push(t)) : e10.md.block.parse(e10.src, e10.md, e10.env, e10.tokens);
}
function Gg(e10) {
  const t = e10.tokens;
  for (let n = 0, r = t.length; n < r; n++) {
    const i = t[n];
    i.type === "inline" && e10.md.inline.parse(i.content, e10.md, e10.env, i.children);
  }
}
function Wg(e10) {
  return /^<a[>\s]/i.test(e10);
}
function Kg(e10) {
  return /^<\/a\s*>/i.test(e10);
}
function Xg(e10) {
  const t = e10.tokens;
  if (e10.md.options.linkify)
    for (let n = 0, r = t.length; n < r; n++) {
      if (t[n].type !== "inline" || !e10.md.linkify.pretest(t[n].content))
        continue;
      let i = t[n].children, s = 0;
      for (let o = i.length - 1; o >= 0; o--) {
        const l = i[o];
        if (l.type === "link_close") {
          for (o--; i[o].level !== l.level && i[o].type !== "link_open"; )
            o--;
          continue;
        }
        if (l.type === "html_inline" && (Wg(l.content) && s > 0 && s--, Kg(l.content) && s++), !(s > 0) && l.type === "text" && e10.md.linkify.test(l.content)) {
          const f = l.content;
          let h2 = e10.md.linkify.match(f);
          const p = [];
          let b = l.level, v = 0;
          h2.length > 0 && h2[0].index === 0 && o > 0 && i[o - 1].type === "text_special" && (h2 = h2.slice(1));
          for (let k = 0; k < h2.length; k++) {
            const w = h2[k].url, A = e10.md.normalizeLink(w);
            if (!e10.md.validateLink(A))
              continue;
            let T = h2[k].text;
            h2[k].schema ? h2[k].schema === "mailto:" && !/^mailto:/i.test(T) ? T = e10.md.normalizeLinkText("mailto:" + T).replace(/^mailto:/, "") : T = e10.md.normalizeLinkText(T) : T = e10.md.normalizeLinkText("http://" + T).replace(/^http:\/\//, "");
            const D = h2[k].index;
            if (D > v) {
              const z = new e10.Token("text", "", 0);
              z.content = f.slice(v, D), z.level = b, p.push(z);
            }
            const N = new e10.Token("link_open", "a", 1);
            N.attrs = [["href", A]], N.level = b++, N.markup = "linkify", N.info = "auto", p.push(N);
            const O = new e10.Token("text", "", 0);
            O.content = T, O.level = b, p.push(O);
            const q = new e10.Token("link_close", "a", -1);
            q.level = --b, q.markup = "linkify", q.info = "auto", p.push(q), v = h2[k].lastIndex;
          }
          if (v < f.length) {
            const k = new e10.Token("text", "", 0);
            k.content = f.slice(v), k.level = b, p.push(k);
          }
          t[n].children = i = J1(i, o, p);
        }
      }
    }
}
var td = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
var Yg = /\((c|tm|r)\)/i;
var Zg = /\((c|tm|r)\)/ig;
var Jg = {
  c: "Â©",
  r: "Â®",
  tm: "â„¢"
};
function Qg(e10, t) {
  return Jg[t.toLowerCase()];
}
function e8(e10) {
  let t = 0;
  for (let n = e10.length - 1; n >= 0; n--) {
    const r = e10[n];
    r.type === "text" && !t && (r.content = r.content.replace(Zg, Qg)), r.type === "link_open" && r.info === "auto" && t--, r.type === "link_close" && r.info === "auto" && t++;
  }
}
function t8(e10) {
  let t = 0;
  for (let n = e10.length - 1; n >= 0; n--) {
    const r = e10[n];
    r.type === "text" && !t && td.test(r.content) && (r.content = r.content.replace(/\+-/g, "Â±").replace(/\.{2,}/g, "â€¦").replace(/([?!])â€¦/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1â€”").replace(/(^|\s)--(?=\s|$)/mg, "$1â€“").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1â€“")), r.type === "link_open" && r.info === "auto" && t--, r.type === "link_close" && r.info === "auto" && t++;
  }
}
function n8(e10) {
  let t;
  if (e10.md.options.typographer)
    for (t = e10.tokens.length - 1; t >= 0; t--)
      e10.tokens[t].type === "inline" && (Yg.test(e10.tokens[t].content) && e8(e10.tokens[t].children), td.test(e10.tokens[t].content) && t8(e10.tokens[t].children));
}
var r8 = /['"]/;
var Mf = /['"]/g;
var Nf = "â€™";
function zs(e10, t, n) {
  return e10.slice(0, t) + n + e10.slice(t + 1);
}
function i8(e10, t) {
  let n;
  const r = [];
  for (let i = 0; i < e10.length; i++) {
    const s = e10[i], o = e10[i].level;
    for (n = r.length - 1; n >= 0 && !(r[n].level <= o); n--)
      ;
    if (r.length = n + 1, s.type !== "text")
      continue;
    let l = s.content, f = 0, h2 = l.length;
    e:
      for (; f < h2; ) {
        Mf.lastIndex = f;
        const p = Mf.exec(l);
        if (!p)
          break;
        let b = true, v = true;
        f = p.index + 1;
        const k = p[0] === "'";
        let w = 32;
        if (p.index - 1 >= 0)
          w = l.charCodeAt(p.index - 1);
        else
          for (n = i - 1; n >= 0 && !(e10[n].type === "softbreak" || e10[n].type === "hardbreak"); n--)
            if (e10[n].content) {
              w = e10[n].content.charCodeAt(e10[n].content.length - 1);
              break;
            }
        let A = 32;
        if (f < h2)
          A = l.charCodeAt(f);
        else
          for (n = i + 1; n < e10.length && !(e10[n].type === "softbreak" || e10[n].type === "hardbreak"); n++)
            if (e10[n].content) {
              A = e10[n].content.charCodeAt(0);
              break;
            }
        const T = Ui(w) || ji(String.fromCharCode(w)), D = Ui(A) || ji(String.fromCharCode(A)), N = Hi(w), O = Hi(A);
        if (O ? b = false : D && (N || T || (b = false)), N ? v = false : T && (O || D || (v = false)), A === 34 && p[0] === '"' && w >= 48 && w <= 57 && (v = b = false), b && v && (b = T, v = D), !b && !v) {
          k && (s.content = zs(s.content, p.index, Nf));
          continue;
        }
        if (v)
          for (n = r.length - 1; n >= 0; n--) {
            let q = r[n];
            if (r[n].level < o)
              break;
            if (q.single === k && r[n].level === o) {
              q = r[n];
              let z, R;
              k ? (z = t.md.options.quotes[2], R = t.md.options.quotes[3]) : (z = t.md.options.quotes[0], R = t.md.options.quotes[1]), s.content = zs(s.content, p.index, R), e10[q.token].content = zs(
                e10[q.token].content,
                q.pos,
                z
              ), f += R.length - 1, q.token === i && (f += z.length - 1), l = s.content, h2 = l.length, r.length = n;
              continue e;
            }
          }
        b ? r.push({
          token: i,
          pos: p.index,
          single: k,
          level: o
        }) : v && k && (s.content = zs(s.content, p.index, Nf));
      }
  }
}
function s8(e10) {
  if (e10.md.options.typographer)
    for (let t = e10.tokens.length - 1; t >= 0; t--)
      e10.tokens[t].type !== "inline" || !r8.test(e10.tokens[t].content) || i8(e10.tokens[t].children, e10);
}
function u8(e10) {
  let t, n;
  const r = e10.tokens, i = r.length;
  for (let s = 0; s < i; s++) {
    if (r[s].type !== "inline") continue;
    const o = r[s].children, l = o.length;
    for (t = 0; t < l; t++)
      o[t].type === "text_special" && (o[t].type = "text");
    for (t = n = 0; t < l; t++)
      o[t].type === "text" && t + 1 < l && o[t + 1].type === "text" ? o[t + 1].content = o[t].content + o[t + 1].content : (t !== n && (o[n] = o[t]), n++);
    t !== n && (o.length = n);
  }
}
var no = [
  ["normalize", Ug],
  ["block", Vg],
  ["inline", Gg],
  ["linkify", Xg],
  ["replacements", n8],
  ["smartquotes", s8],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", u8]
];
function Ra() {
  this.ruler = new It();
  for (let e10 = 0; e10 < no.length; e10++)
    this.ruler.push(no[e10][0], no[e10][1]);
}
Ra.prototype.process = function(e10) {
  const t = this.ruler.getRules("");
  for (let n = 0, r = t.length; n < r; n++)
    t[n](e10);
};
Ra.prototype.State = ed;
function bn(e10, t, n, r) {
  this.src = e10, this.md = t, this.env = n, this.tokens = r, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = false, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0;
  const i = this.src;
  for (let s = 0, o = 0, l = 0, f = 0, h2 = i.length, p = false; o < h2; o++) {
    const b = i.charCodeAt(o);
    if (!p)
      if (Ge(b)) {
        l++, b === 9 ? f += 4 - f % 4 : f++;
        continue;
      } else
        p = true;
    (b === 10 || o === h2 - 1) && (b !== 10 && o++, this.bMarks.push(s), this.eMarks.push(o), this.tShift.push(l), this.sCount.push(f), this.bsCount.push(0), p = false, l = 0, f = 0, s = o + 1);
  }
  this.bMarks.push(i.length), this.eMarks.push(i.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
bn.prototype.push = function(e10, t, n) {
  const r = new tn(e10, t, n);
  return r.block = true, n < 0 && this.level--, r.level = this.level, n > 0 && this.level++, this.tokens.push(r), r;
};
bn.prototype.isEmpty = function(t) {
  return this.bMarks[t] + this.tShift[t] >= this.eMarks[t];
};
bn.prototype.skipEmptyLines = function(t) {
  for (let n = this.lineMax; t < n && !(this.bMarks[t] + this.tShift[t] < this.eMarks[t]); t++)
    ;
  return t;
};
bn.prototype.skipSpaces = function(t) {
  for (let n = this.src.length; t < n; t++) {
    const r = this.src.charCodeAt(t);
    if (!Ge(r))
      break;
  }
  return t;
};
bn.prototype.skipSpacesBack = function(t, n) {
  if (t <= n)
    return t;
  for (; t > n; )
    if (!Ge(this.src.charCodeAt(--t)))
      return t + 1;
  return t;
};
bn.prototype.skipChars = function(t, n) {
  for (let r = this.src.length; t < r && this.src.charCodeAt(t) === n; t++)
    ;
  return t;
};
bn.prototype.skipCharsBack = function(t, n, r) {
  if (t <= r)
    return t;
  for (; t > r; )
    if (n !== this.src.charCodeAt(--t))
      return t + 1;
  return t;
};
bn.prototype.getLines = function(t, n, r, i) {
  if (t >= n)
    return "";
  const s = new Array(n - t);
  for (let o = 0, l = t; l < n; l++, o++) {
    let f = 0;
    const h2 = this.bMarks[l];
    let p = h2, b;
    for (l + 1 < n || i ? b = this.eMarks[l] + 1 : b = this.eMarks[l]; p < b && f < r; ) {
      const v = this.src.charCodeAt(p);
      if (Ge(v))
        v === 9 ? f += 4 - (f + this.bsCount[l]) % 4 : f++;
      else if (p - h2 < this.tShift[l])
        f++;
      else
        break;
      p++;
    }
    f > r ? s[o] = new Array(f - r + 1).join(" ") + this.src.slice(p, b) : s[o] = this.src.slice(p, b);
  }
  return s.join("");
};
bn.prototype.Token = tn;
var o8 = 65536;
function ro(e10, t) {
  const n = e10.bMarks[t] + e10.tShift[t], r = e10.eMarks[t];
  return e10.src.slice(n, r);
}
function If(e10) {
  const t = [], n = e10.length;
  let r = 0, i = e10.charCodeAt(r), s = false, o = 0, l = "";
  for (; r < n; )
    i === 124 && (s ? (l += e10.substring(o, r - 1), o = r) : (t.push(l + e10.substring(o, r)), l = "", o = r + 1)), s = i === 92, r++, i = e10.charCodeAt(r);
  return t.push(l + e10.substring(o)), t;
}
function a8(e10, t, n, r) {
  if (t + 2 > n)
    return false;
  let i = t + 1;
  if (e10.sCount[i] < e10.blkIndent || e10.sCount[i] - e10.blkIndent >= 4)
    return false;
  let s = e10.bMarks[i] + e10.tShift[i];
  if (s >= e10.eMarks[i])
    return false;
  const o = e10.src.charCodeAt(s++);
  if (o !== 124 && o !== 45 && o !== 58 || s >= e10.eMarks[i])
    return false;
  const l = e10.src.charCodeAt(s++);
  if (l !== 124 && l !== 45 && l !== 58 && !Ge(l) || o === 45 && Ge(l))
    return false;
  for (; s < e10.eMarks[i]; ) {
    const q = e10.src.charCodeAt(s);
    if (q !== 124 && q !== 45 && q !== 58 && !Ge(q))
      return false;
    s++;
  }
  let f = ro(e10, t + 1), h2 = f.split("|");
  const p = [];
  for (let q = 0; q < h2.length; q++) {
    const z = h2[q].trim();
    if (!z) {
      if (q === 0 || q === h2.length - 1)
        continue;
      return false;
    }
    if (!/^:?-+:?$/.test(z))
      return false;
    z.charCodeAt(z.length - 1) === 58 ? p.push(z.charCodeAt(0) === 58 ? "center" : "right") : z.charCodeAt(0) === 58 ? p.push("left") : p.push("");
  }
  if (f = ro(e10, t).trim(), f.indexOf("|") === -1 || e10.sCount[t] - e10.blkIndent >= 4)
    return false;
  h2 = If(f), h2.length && h2[0] === "" && h2.shift(), h2.length && h2[h2.length - 1] === "" && h2.pop();
  const b = h2.length;
  if (b === 0 || b !== p.length)
    return false;
  if (r)
    return true;
  const v = e10.parentType;
  e10.parentType = "table";
  const k = e10.md.block.ruler.getRules("blockquote"), w = e10.push("table_open", "table", 1), A = [t, 0];
  w.map = A;
  const T = e10.push("thead_open", "thead", 1);
  T.map = [t, t + 1];
  const D = e10.push("tr_open", "tr", 1);
  D.map = [t, t + 1];
  for (let q = 0; q < h2.length; q++) {
    const z = e10.push("th_open", "th", 1);
    p[q] && (z.attrs = [["style", "text-align:" + p[q]]]);
    const R = e10.push("inline", "", 0);
    R.content = h2[q].trim(), R.children = [], e10.push("th_close", "th", -1);
  }
  e10.push("tr_close", "tr", -1), e10.push("thead_close", "thead", -1);
  let N, O = 0;
  for (i = t + 2; i < n && !(e10.sCount[i] < e10.blkIndent); i++) {
    let q = false;
    for (let R = 0, J = k.length; R < J; R++)
      if (k[R](e10, i, n, true)) {
        q = true;
        break;
      }
    if (q || (f = ro(e10, i).trim(), !f) || e10.sCount[i] - e10.blkIndent >= 4 || (h2 = If(f), h2.length && h2[0] === "" && h2.shift(), h2.length && h2[h2.length - 1] === "" && h2.pop(), O += b - h2.length, O > o8))
      break;
    if (i === t + 2) {
      const R = e10.push("tbody_open", "tbody", 1);
      R.map = N = [t + 2, 0];
    }
    const z = e10.push("tr_open", "tr", 1);
    z.map = [i, i + 1];
    for (let R = 0; R < b; R++) {
      const J = e10.push("td_open", "td", 1);
      p[R] && (J.attrs = [["style", "text-align:" + p[R]]]);
      const K = e10.push("inline", "", 0);
      K.content = h2[R] ? h2[R].trim() : "", K.children = [], e10.push("td_close", "td", -1);
    }
    e10.push("tr_close", "tr", -1);
  }
  return N && (e10.push("tbody_close", "tbody", -1), N[1] = i), e10.push("table_close", "table", -1), A[1] = i, e10.parentType = v, e10.line = i, true;
}
function l8(e10, t, n) {
  if (e10.sCount[t] - e10.blkIndent < 4)
    return false;
  let r = t + 1, i = r;
  for (; r < n; ) {
    if (e10.isEmpty(r)) {
      r++;
      continue;
    }
    if (e10.sCount[r] - e10.blkIndent >= 4) {
      r++, i = r;
      continue;
    }
    break;
  }
  e10.line = i;
  const s = e10.push("code_block", "code", 0);
  return s.content = e10.getLines(t, i, 4 + e10.blkIndent, false) + `
`, s.map = [t, e10.line], true;
}
function c8(e10, t, n, r) {
  let i = e10.bMarks[t] + e10.tShift[t], s = e10.eMarks[t];
  if (e10.sCount[t] - e10.blkIndent >= 4 || i + 3 > s)
    return false;
  const o = e10.src.charCodeAt(i);
  if (o !== 126 && o !== 96)
    return false;
  let l = i;
  i = e10.skipChars(i, o);
  let f = i - l;
  if (f < 3)
    return false;
  const h2 = e10.src.slice(l, i), p = e10.src.slice(i, s);
  if (o === 96 && p.indexOf(String.fromCharCode(o)) >= 0)
    return false;
  if (r)
    return true;
  let b = t, v = false;
  for (; b++, !(b >= n || (i = l = e10.bMarks[b] + e10.tShift[b], s = e10.eMarks[b], i < s && e10.sCount[b] < e10.blkIndent)); )
    if (e10.src.charCodeAt(i) === o && !(e10.sCount[b] - e10.blkIndent >= 4) && (i = e10.skipChars(i, o), !(i - l < f) && (i = e10.skipSpaces(i), !(i < s)))) {
      v = true;
      break;
    }
  f = e10.sCount[t], e10.line = b + (v ? 1 : 0);
  const k = e10.push("fence", "code", 0);
  return k.info = p, k.content = e10.getLines(t + 1, b, f, true), k.markup = h2, k.map = [t, e10.line], true;
}
function f8(e10, t, n, r) {
  let i = e10.bMarks[t] + e10.tShift[t], s = e10.eMarks[t];
  const o = e10.lineMax;
  if (e10.sCount[t] - e10.blkIndent >= 4 || e10.src.charCodeAt(i) !== 62)
    return false;
  if (r)
    return true;
  const l = [], f = [], h2 = [], p = [], b = e10.md.block.ruler.getRules("blockquote"), v = e10.parentType;
  e10.parentType = "blockquote";
  let k = false, w;
  for (w = t; w < n; w++) {
    const O = e10.sCount[w] < e10.blkIndent;
    if (i = e10.bMarks[w] + e10.tShift[w], s = e10.eMarks[w], i >= s)
      break;
    if (e10.src.charCodeAt(i++) === 62 && !O) {
      let z = e10.sCount[w] + 1, R, J;
      e10.src.charCodeAt(i) === 32 ? (i++, z++, J = false, R = true) : e10.src.charCodeAt(i) === 9 ? (R = true, (e10.bsCount[w] + z) % 4 === 3 ? (i++, z++, J = false) : J = true) : R = false;
      let K = z;
      for (l.push(e10.bMarks[w]), e10.bMarks[w] = i; i < s; ) {
        const V = e10.src.charCodeAt(i);
        if (Ge(V))
          V === 9 ? K += 4 - (K + e10.bsCount[w] + (J ? 1 : 0)) % 4 : K++;
        else
          break;
        i++;
      }
      k = i >= s, f.push(e10.bsCount[w]), e10.bsCount[w] = e10.sCount[w] + 1 + (R ? 1 : 0), h2.push(e10.sCount[w]), e10.sCount[w] = K - z, p.push(e10.tShift[w]), e10.tShift[w] = i - e10.bMarks[w];
      continue;
    }
    if (k)
      break;
    let q = false;
    for (let z = 0, R = b.length; z < R; z++)
      if (b[z](e10, w, n, true)) {
        q = true;
        break;
      }
    if (q) {
      e10.lineMax = w, e10.blkIndent !== 0 && (l.push(e10.bMarks[w]), f.push(e10.bsCount[w]), p.push(e10.tShift[w]), h2.push(e10.sCount[w]), e10.sCount[w] -= e10.blkIndent);
      break;
    }
    l.push(e10.bMarks[w]), f.push(e10.bsCount[w]), p.push(e10.tShift[w]), h2.push(e10.sCount[w]), e10.sCount[w] = -1;
  }
  const A = e10.blkIndent;
  e10.blkIndent = 0;
  const T = e10.push("blockquote_open", "blockquote", 1);
  T.markup = ">";
  const D = [t, 0];
  T.map = D, e10.md.block.tokenize(e10, t, w);
  const N = e10.push("blockquote_close", "blockquote", -1);
  N.markup = ">", e10.lineMax = o, e10.parentType = v, D[1] = e10.line;
  for (let O = 0; O < p.length; O++)
    e10.bMarks[O + t] = l[O], e10.tShift[O + t] = p[O], e10.sCount[O + t] = h2[O], e10.bsCount[O + t] = f[O];
  return e10.blkIndent = A, true;
}
function h8(e10, t, n, r) {
  const i = e10.eMarks[t];
  if (e10.sCount[t] - e10.blkIndent >= 4)
    return false;
  let s = e10.bMarks[t] + e10.tShift[t];
  const o = e10.src.charCodeAt(s++);
  if (o !== 42 && o !== 45 && o !== 95)
    return false;
  let l = 1;
  for (; s < i; ) {
    const h2 = e10.src.charCodeAt(s++);
    if (h2 !== o && !Ge(h2))
      return false;
    h2 === o && l++;
  }
  if (l < 3)
    return false;
  if (r)
    return true;
  e10.line = t + 1;
  const f = e10.push("hr", "hr", 0);
  return f.map = [t, e10.line], f.markup = Array(l + 1).join(String.fromCharCode(o)), true;
}
function Ff(e10, t) {
  const n = e10.eMarks[t];
  let r = e10.bMarks[t] + e10.tShift[t];
  const i = e10.src.charCodeAt(r++);
  if (i !== 42 && i !== 45 && i !== 43)
    return -1;
  if (r < n) {
    const s = e10.src.charCodeAt(r);
    if (!Ge(s))
      return -1;
  }
  return r;
}
function Bf(e10, t) {
  const n = e10.bMarks[t] + e10.tShift[t], r = e10.eMarks[t];
  let i = n;
  if (i + 1 >= r)
    return -1;
  let s = e10.src.charCodeAt(i++);
  if (s < 48 || s > 57)
    return -1;
  for (; ; ) {
    if (i >= r)
      return -1;
    if (s = e10.src.charCodeAt(i++), s >= 48 && s <= 57) {
      if (i - n >= 10)
        return -1;
      continue;
    }
    if (s === 41 || s === 46)
      break;
    return -1;
  }
  return i < r && (s = e10.src.charCodeAt(i), !Ge(s)) ? -1 : i;
}
function d8(e10, t) {
  const n = e10.level + 2;
  for (let r = t + 2, i = e10.tokens.length - 2; r < i; r++)
    e10.tokens[r].level === n && e10.tokens[r].type === "paragraph_open" && (e10.tokens[r + 2].hidden = true, e10.tokens[r].hidden = true, r += 2);
}
function p8(e10, t, n, r) {
  let i, s, o, l, f = t, h2 = true;
  if (e10.sCount[f] - e10.blkIndent >= 4 || e10.listIndent >= 0 && e10.sCount[f] - e10.listIndent >= 4 && e10.sCount[f] < e10.blkIndent)
    return false;
  let p = false;
  r && e10.parentType === "paragraph" && e10.sCount[f] >= e10.blkIndent && (p = true);
  let b, v, k;
  if ((k = Bf(e10, f)) >= 0) {
    if (b = true, o = e10.bMarks[f] + e10.tShift[f], v = Number(e10.src.slice(o, k - 1)), p && v !== 1) return false;
  } else if ((k = Ff(e10, f)) >= 0)
    b = false;
  else
    return false;
  if (p && e10.skipSpaces(k) >= e10.eMarks[f])
    return false;
  if (r)
    return true;
  const w = e10.src.charCodeAt(k - 1), A = e10.tokens.length;
  b ? (l = e10.push("ordered_list_open", "ol", 1), v !== 1 && (l.attrs = [["start", v]])) : l = e10.push("bullet_list_open", "ul", 1);
  const T = [f, 0];
  l.map = T, l.markup = String.fromCharCode(w);
  let D = false;
  const N = e10.md.block.ruler.getRules("list"), O = e10.parentType;
  for (e10.parentType = "list"; f < n; ) {
    s = k, i = e10.eMarks[f];
    const q = e10.sCount[f] + k - (e10.bMarks[f] + e10.tShift[f]);
    let z = q;
    for (; s < i; ) {
      const X = e10.src.charCodeAt(s);
      if (X === 9)
        z += 4 - (z + e10.bsCount[f]) % 4;
      else if (X === 32)
        z++;
      else
        break;
      s++;
    }
    const R = s;
    let J;
    R >= i ? J = 1 : J = z - q, J > 4 && (J = 1);
    const K = q + J;
    l = e10.push("list_item_open", "li", 1), l.markup = String.fromCharCode(w);
    const V = [f, 0];
    l.map = V, b && (l.info = e10.src.slice(o, k - 1));
    const te = e10.tight, Z = e10.tShift[f], se = e10.sCount[f], fe = e10.listIndent;
    if (e10.listIndent = e10.blkIndent, e10.blkIndent = K, e10.tight = true, e10.tShift[f] = R - e10.bMarks[f], e10.sCount[f] = z, R >= i && e10.isEmpty(f + 1) ? e10.line = Math.min(e10.line + 2, n) : e10.md.block.tokenize(e10, f, n, true), (!e10.tight || D) && (h2 = false), D = e10.line - f > 1 && e10.isEmpty(e10.line - 1), e10.blkIndent = e10.listIndent, e10.listIndent = fe, e10.tShift[f] = Z, e10.sCount[f] = se, e10.tight = te, l = e10.push("list_item_close", "li", -1), l.markup = String.fromCharCode(w), f = e10.line, V[1] = f, f >= n || e10.sCount[f] < e10.blkIndent || e10.sCount[f] - e10.blkIndent >= 4)
      break;
    let $ = false;
    for (let X = 0, j = N.length; X < j; X++)
      if (N[X](e10, f, n, true)) {
        $ = true;
        break;
      }
    if ($)
      break;
    if (b) {
      if (k = Bf(e10, f), k < 0)
        break;
      o = e10.bMarks[f] + e10.tShift[f];
    } else if (k = Ff(e10, f), k < 0)
      break;
    if (w !== e10.src.charCodeAt(k - 1))
      break;
  }
  return b ? l = e10.push("ordered_list_close", "ol", -1) : l = e10.push("bullet_list_close", "ul", -1), l.markup = String.fromCharCode(w), T[1] = f, e10.line = f, e10.parentType = O, h2 && d8(e10, A), true;
}
function m8(e10, t, n, r) {
  let i = e10.bMarks[t] + e10.tShift[t], s = e10.eMarks[t], o = t + 1;
  if (e10.sCount[t] - e10.blkIndent >= 4 || e10.src.charCodeAt(i) !== 91)
    return false;
  function l(N) {
    const O = e10.lineMax;
    if (N >= O || e10.isEmpty(N))
      return null;
    let q = false;
    if (e10.sCount[N] - e10.blkIndent > 3 && (q = true), e10.sCount[N] < 0 && (q = true), !q) {
      const J = e10.md.block.ruler.getRules("reference"), K = e10.parentType;
      e10.parentType = "reference";
      let V = false;
      for (let te = 0, Z = J.length; te < Z; te++)
        if (J[te](e10, N, O, true)) {
          V = true;
          break;
        }
      if (e10.parentType = K, V)
        return null;
    }
    const z = e10.bMarks[N] + e10.tShift[N], R = e10.eMarks[N];
    return e10.src.slice(z, R + 1);
  }
  let f = e10.src.slice(i, s + 1);
  s = f.length;
  let h2 = -1;
  for (i = 1; i < s; i++) {
    const N = f.charCodeAt(i);
    if (N === 91)
      return false;
    if (N === 93) {
      h2 = i;
      break;
    } else if (N === 10) {
      const O = l(o);
      O !== null && (f += O, s = f.length, o++);
    } else if (N === 92 && (i++, i < s && f.charCodeAt(i) === 10)) {
      const O = l(o);
      O !== null && (f += O, s = f.length, o++);
    }
  }
  if (h2 < 0 || f.charCodeAt(h2 + 1) !== 58)
    return false;
  for (i = h2 + 2; i < s; i++) {
    const N = f.charCodeAt(i);
    if (N === 10) {
      const O = l(o);
      O !== null && (f += O, s = f.length, o++);
    } else if (!Ge(N)) break;
  }
  const p = e10.md.helpers.parseLinkDestination(f, i, s);
  if (!p.ok)
    return false;
  const b = e10.md.normalizeLink(p.str);
  if (!e10.md.validateLink(b))
    return false;
  i = p.pos;
  const v = i, k = o, w = i;
  for (; i < s; i++) {
    const N = f.charCodeAt(i);
    if (N === 10) {
      const O = l(o);
      O !== null && (f += O, s = f.length, o++);
    } else if (!Ge(N)) break;
  }
  let A = e10.md.helpers.parseLinkTitle(f, i, s);
  for (; A.can_continue; ) {
    const N = l(o);
    if (N === null) break;
    f += N, i = s, s = f.length, o++, A = e10.md.helpers.parseLinkTitle(f, i, s, A);
  }
  let T;
  for (i < s && w !== i && A.ok ? (T = A.str, i = A.pos) : (T = "", i = v, o = k); i < s; ) {
    const N = f.charCodeAt(i);
    if (!Ge(N))
      break;
    i++;
  }
  if (i < s && f.charCodeAt(i) !== 10 && T)
    for (T = "", i = v, o = k; i < s; ) {
      const N = f.charCodeAt(i);
      if (!Ge(N))
        break;
      i++;
    }
  if (i < s && f.charCodeAt(i) !== 10)
    return false;
  const D = R0(f.slice(1, h2));
  return D ? (r || (typeof e10.env.references > "u" && (e10.env.references = {}), typeof e10.env.references[D] > "u" && (e10.env.references[D] = { title: T, href: b }), e10.line = o), true) : false;
}
var g8 = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var b8 = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var y8 = "[^\"'=<>`\\x00-\\x20]+";
var x8 = "'[^']*'";
var w8 = '"[^"]*"';
var v8 = "(?:" + y8 + "|" + x8 + "|" + w8 + ")";
var k8 = "(?:\\s+" + b8 + "(?:\\s*=\\s*" + v8 + ")?)";
var nd = "<[A-Za-z][A-Za-z0-9\\-]*" + k8 + "*\\s*\\/?>";
var rd = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var _8 = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->";
var S8 = "<[?][\\s\\S]*?[?]>";
var A8 = "<![A-Za-z][^>]*>";
var E8 = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var C8 = new RegExp("^(?:" + nd + "|" + rd + "|" + _8 + "|" + S8 + "|" + A8 + "|" + E8 + ")");
var T8 = new RegExp("^(?:" + nd + "|" + rd + ")");
var Mr = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
  [/^<!--/, /-->/, true],
  [/^<\?/, /\?>/, true],
  [/^<![A-Z]/, />/, true],
  [/^<!\[CDATA\[/, /\]\]>/, true],
  [new RegExp("^</?(" + g8.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
  [new RegExp(T8.source + "\\s*$"), /^$/, false]
];
function D8(e10, t, n, r) {
  let i = e10.bMarks[t] + e10.tShift[t], s = e10.eMarks[t];
  if (e10.sCount[t] - e10.blkIndent >= 4 || !e10.md.options.html || e10.src.charCodeAt(i) !== 60)
    return false;
  let o = e10.src.slice(i, s), l = 0;
  for (; l < Mr.length && !Mr[l][0].test(o); l++)
    ;
  if (l === Mr.length)
    return false;
  if (r)
    return Mr[l][2];
  let f = t + 1;
  if (!Mr[l][1].test(o)) {
    for (; f < n && !(e10.sCount[f] < e10.blkIndent); f++)
      if (i = e10.bMarks[f] + e10.tShift[f], s = e10.eMarks[f], o = e10.src.slice(i, s), Mr[l][1].test(o)) {
        o.length !== 0 && f++;
        break;
      }
  }
  e10.line = f;
  const h2 = e10.push("html_block", "", 0);
  return h2.map = [t, f], h2.content = e10.getLines(t, f, e10.blkIndent, true), true;
}
function M8(e10, t, n, r) {
  let i = e10.bMarks[t] + e10.tShift[t], s = e10.eMarks[t];
  if (e10.sCount[t] - e10.blkIndent >= 4)
    return false;
  let o = e10.src.charCodeAt(i);
  if (o !== 35 || i >= s)
    return false;
  let l = 1;
  for (o = e10.src.charCodeAt(++i); o === 35 && i < s && l <= 6; )
    l++, o = e10.src.charCodeAt(++i);
  if (l > 6 || i < s && !Ge(o))
    return false;
  if (r)
    return true;
  s = e10.skipSpacesBack(s, i);
  const f = e10.skipCharsBack(s, 35, i);
  f > i && Ge(e10.src.charCodeAt(f - 1)) && (s = f), e10.line = t + 1;
  const h2 = e10.push("heading_open", "h" + String(l), 1);
  h2.markup = "########".slice(0, l), h2.map = [t, e10.line];
  const p = e10.push("inline", "", 0);
  p.content = e10.src.slice(i, s).trim(), p.map = [t, e10.line], p.children = [];
  const b = e10.push("heading_close", "h" + String(l), -1);
  return b.markup = "########".slice(0, l), true;
}
function N8(e10, t, n) {
  const r = e10.md.block.ruler.getRules("paragraph");
  if (e10.sCount[t] - e10.blkIndent >= 4)
    return false;
  const i = e10.parentType;
  e10.parentType = "paragraph";
  let s = 0, o, l = t + 1;
  for (; l < n && !e10.isEmpty(l); l++) {
    if (e10.sCount[l] - e10.blkIndent > 3)
      continue;
    if (e10.sCount[l] >= e10.blkIndent) {
      let k = e10.bMarks[l] + e10.tShift[l];
      const w = e10.eMarks[l];
      if (k < w && (o = e10.src.charCodeAt(k), (o === 45 || o === 61) && (k = e10.skipChars(k, o), k = e10.skipSpaces(k), k >= w))) {
        s = o === 61 ? 1 : 2;
        break;
      }
    }
    if (e10.sCount[l] < 0)
      continue;
    let v = false;
    for (let k = 0, w = r.length; k < w; k++)
      if (r[k](e10, l, n, true)) {
        v = true;
        break;
      }
    if (v)
      break;
  }
  if (!s)
    return false;
  const f = e10.getLines(t, l, e10.blkIndent, false).trim();
  e10.line = l + 1;
  const h2 = e10.push("heading_open", "h" + String(s), 1);
  h2.markup = String.fromCharCode(o), h2.map = [t, e10.line];
  const p = e10.push("inline", "", 0);
  p.content = f, p.map = [t, e10.line - 1], p.children = [];
  const b = e10.push("heading_close", "h" + String(s), -1);
  return b.markup = String.fromCharCode(o), e10.parentType = i, true;
}
function I8(e10, t, n) {
  const r = e10.md.block.ruler.getRules("paragraph"), i = e10.parentType;
  let s = t + 1;
  for (e10.parentType = "paragraph"; s < n && !e10.isEmpty(s); s++) {
    if (e10.sCount[s] - e10.blkIndent > 3 || e10.sCount[s] < 0)
      continue;
    let h2 = false;
    for (let p = 0, b = r.length; p < b; p++)
      if (r[p](e10, s, n, true)) {
        h2 = true;
        break;
      }
    if (h2)
      break;
  }
  const o = e10.getLines(t, s, e10.blkIndent, false).trim();
  e10.line = s;
  const l = e10.push("paragraph_open", "p", 1);
  l.map = [t, e10.line];
  const f = e10.push("inline", "", 0);
  return f.content = o, f.map = [t, e10.line], f.children = [], e10.push("paragraph_close", "p", -1), e10.parentType = i, true;
}
var $s = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", a8, ["paragraph", "reference"]],
  ["code", l8],
  ["fence", c8, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", f8, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", h8, ["paragraph", "reference", "blockquote", "list"]],
  ["list", p8, ["paragraph", "reference", "blockquote"]],
  ["reference", m8],
  ["html_block", D8, ["paragraph", "reference", "blockquote"]],
  ["heading", M8, ["paragraph", "reference", "blockquote"]],
  ["lheading", N8],
  ["paragraph", I8]
];
function P0() {
  this.ruler = new It();
  for (let e10 = 0; e10 < $s.length; e10++)
    this.ruler.push($s[e10][0], $s[e10][1], { alt: ($s[e10][2] || []).slice() });
}
P0.prototype.tokenize = function(e10, t, n) {
  const r = this.ruler.getRules(""), i = r.length, s = e10.md.options.maxNesting;
  let o = t, l = false;
  for (; o < n && (e10.line = o = e10.skipEmptyLines(o), !(o >= n || e10.sCount[o] < e10.blkIndent)); ) {
    if (e10.level >= s) {
      e10.line = n;
      break;
    }
    const f = e10.line;
    let h2 = false;
    for (let p = 0; p < i; p++)
      if (h2 = r[p](e10, o, n, false), h2) {
        if (f >= e10.line)
          throw new Error("block rule didn't increment state.line");
        break;
      }
    if (!h2) throw new Error("none of the block rules matched");
    e10.tight = !l, e10.isEmpty(e10.line - 1) && (l = true), o = e10.line, o < n && e10.isEmpty(o) && (l = true, o++, e10.line = o);
  }
};
P0.prototype.parse = function(e10, t, n, r) {
  if (!e10)
    return;
  const i = new this.State(e10, t, n, r);
  this.tokenize(i, i.line, i.lineMax);
};
P0.prototype.State = bn;
function rs(e10, t, n, r) {
  this.src = e10, this.env = n, this.md = t, this.tokens = r, this.tokens_meta = Array(r.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = false, this.linkLevel = 0;
}
rs.prototype.pushPending = function() {
  const e10 = new tn("text", "", 0);
  return e10.content = this.pending, e10.level = this.pendingLevel, this.tokens.push(e10), this.pending = "", e10;
};
rs.prototype.push = function(e10, t, n) {
  this.pending && this.pushPending();
  const r = new tn(e10, t, n);
  let i = null;
  return n < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), r.level = this.level, n > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], i = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(r), this.tokens_meta.push(i), r;
};
rs.prototype.scanDelims = function(e10, t) {
  const n = this.posMax, r = this.src.charCodeAt(e10), i = e10 > 0 ? this.src.charCodeAt(e10 - 1) : 32;
  let s = e10;
  for (; s < n && this.src.charCodeAt(s) === r; )
    s++;
  const o = s - e10, l = s < n ? this.src.charCodeAt(s) : 32, f = Ui(i) || ji(String.fromCharCode(i)), h2 = Ui(l) || ji(String.fromCharCode(l)), p = Hi(i), b = Hi(l), v = !b && (!h2 || p || f), k = !p && (!f || b || h2);
  return { can_open: v && (t || !k || f), can_close: k && (t || !v || h2), length: o };
};
rs.prototype.Token = tn;
function F8(e10) {
  switch (e10) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function B8(e10, t) {
  let n = e10.pos;
  for (; n < e10.posMax && !F8(e10.src.charCodeAt(n)); )
    n++;
  return n === e10.pos ? false : (t || (e10.pending += e10.src.slice(e10.pos, n)), e10.pos = n, true);
}
var O8 = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function z8(e10, t) {
  if (!e10.md.options.linkify || e10.linkLevel > 0) return false;
  const n = e10.pos, r = e10.posMax;
  if (n + 3 > r || e10.src.charCodeAt(n) !== 58 || e10.src.charCodeAt(n + 1) !== 47 || e10.src.charCodeAt(n + 2) !== 47) return false;
  const i = e10.pending.match(O8);
  if (!i) return false;
  const s = i[1], o = e10.md.linkify.matchAtStart(e10.src.slice(n - s.length));
  if (!o) return false;
  let l = o.url;
  if (l.length <= s.length) return false;
  l = l.replace(/\*+$/, "");
  const f = e10.md.normalizeLink(l);
  if (!e10.md.validateLink(f)) return false;
  if (!t) {
    e10.pending = e10.pending.slice(0, -s.length);
    const h2 = e10.push("link_open", "a", 1);
    h2.attrs = [["href", f]], h2.markup = "linkify", h2.info = "auto";
    const p = e10.push("text", "", 0);
    p.content = e10.md.normalizeLinkText(l);
    const b = e10.push("link_close", "a", -1);
    b.markup = "linkify", b.info = "auto";
  }
  return e10.pos += l.length - s.length, true;
}
function $8(e10, t) {
  let n = e10.pos;
  if (e10.src.charCodeAt(n) !== 10)
    return false;
  const r = e10.pending.length - 1, i = e10.posMax;
  if (!t)
    if (r >= 0 && e10.pending.charCodeAt(r) === 32)
      if (r >= 1 && e10.pending.charCodeAt(r - 1) === 32) {
        let s = r - 1;
        for (; s >= 1 && e10.pending.charCodeAt(s - 1) === 32; ) s--;
        e10.pending = e10.pending.slice(0, s), e10.push("hardbreak", "br", 0);
      } else
        e10.pending = e10.pending.slice(0, -1), e10.push("softbreak", "br", 0);
    else
      e10.push("softbreak", "br", 0);
  for (n++; n < i && Ge(e10.src.charCodeAt(n)); )
    n++;
  return e10.pos = n, true;
}
var Pa = [];
for (let e10 = 0; e10 < 256; e10++)
  Pa.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(e10) {
  Pa[e10.charCodeAt(0)] = 1;
});
function L8(e10, t) {
  let n = e10.pos;
  const r = e10.posMax;
  if (e10.src.charCodeAt(n) !== 92 || (n++, n >= r)) return false;
  let i = e10.src.charCodeAt(n);
  if (i === 10) {
    for (t || e10.push("hardbreak", "br", 0), n++; n < r && (i = e10.src.charCodeAt(n), !!Ge(i)); )
      n++;
    return e10.pos = n, true;
  }
  let s = e10.src[n];
  if (i >= 55296 && i <= 56319 && n + 1 < r) {
    const l = e10.src.charCodeAt(n + 1);
    l >= 56320 && l <= 57343 && (s += e10.src[n + 1], n++);
  }
  const o = "\\" + s;
  if (!t) {
    const l = e10.push("text_special", "", 0);
    i < 256 && Pa[i] !== 0 ? l.content = s : l.content = o, l.markup = o, l.info = "escape";
  }
  return e10.pos = n + 1, true;
}
function q8(e10, t) {
  let n = e10.pos;
  if (e10.src.charCodeAt(n) !== 96)
    return false;
  const i = n;
  n++;
  const s = e10.posMax;
  for (; n < s && e10.src.charCodeAt(n) === 96; )
    n++;
  const o = e10.src.slice(i, n), l = o.length;
  if (e10.backticksScanned && (e10.backticks[l] || 0) <= i)
    return t || (e10.pending += o), e10.pos += l, true;
  let f = n, h2;
  for (; (h2 = e10.src.indexOf("`", f)) !== -1; ) {
    for (f = h2 + 1; f < s && e10.src.charCodeAt(f) === 96; )
      f++;
    const p = f - h2;
    if (p === l) {
      if (!t) {
        const b = e10.push("code_inline", "code", 0);
        b.markup = o, b.content = e10.src.slice(n, h2).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      return e10.pos = f, true;
    }
    e10.backticks[p] = h2;
  }
  return e10.backticksScanned = true, t || (e10.pending += o), e10.pos += l, true;
}
function R8(e10, t) {
  const n = e10.pos, r = e10.src.charCodeAt(n);
  if (t || r !== 126)
    return false;
  const i = e10.scanDelims(e10.pos, true);
  let s = i.length;
  const o = String.fromCharCode(r);
  if (s < 2)
    return false;
  let l;
  s % 2 && (l = e10.push("text", "", 0), l.content = o, s--);
  for (let f = 0; f < s; f += 2)
    l = e10.push("text", "", 0), l.content = o + o, e10.delimiters.push({
      marker: r,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: e10.tokens.length - 1,
      end: -1,
      open: i.can_open,
      close: i.can_close
    });
  return e10.pos += i.length, true;
}
function Of(e10, t) {
  let n;
  const r = [], i = t.length;
  for (let s = 0; s < i; s++) {
    const o = t[s];
    if (o.marker !== 126 || o.end === -1)
      continue;
    const l = t[o.end];
    n = e10.tokens[o.token], n.type = "s_open", n.tag = "s", n.nesting = 1, n.markup = "~~", n.content = "", n = e10.tokens[l.token], n.type = "s_close", n.tag = "s", n.nesting = -1, n.markup = "~~", n.content = "", e10.tokens[l.token - 1].type === "text" && e10.tokens[l.token - 1].content === "~" && r.push(l.token - 1);
  }
  for (; r.length; ) {
    const s = r.pop();
    let o = s + 1;
    for (; o < e10.tokens.length && e10.tokens[o].type === "s_close"; )
      o++;
    o--, s !== o && (n = e10.tokens[o], e10.tokens[o] = e10.tokens[s], e10.tokens[s] = n);
  }
}
function P8(e10) {
  const t = e10.tokens_meta, n = e10.tokens_meta.length;
  Of(e10, e10.delimiters);
  for (let r = 0; r < n; r++)
    t[r] && t[r].delimiters && Of(e10, t[r].delimiters);
}
var id = {
  tokenize: R8,
  postProcess: P8
};
function H8(e10, t) {
  const n = e10.pos, r = e10.src.charCodeAt(n);
  if (t || r !== 95 && r !== 42)
    return false;
  const i = e10.scanDelims(e10.pos, r === 42);
  for (let s = 0; s < i.length; s++) {
    const o = e10.push("text", "", 0);
    o.content = String.fromCharCode(r), e10.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: r,
      // Total length of these series of delimiters.
      //
      length: i.length,
      // A position of the token this delimiter corresponds to.
      //
      token: e10.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: i.can_open,
      close: i.can_close
    });
  }
  return e10.pos += i.length, true;
}
function zf(e10, t) {
  const n = t.length;
  for (let r = n - 1; r >= 0; r--) {
    const i = t[r];
    if (i.marker !== 95 && i.marker !== 42 || i.end === -1)
      continue;
    const s = t[i.end], o = r > 0 && t[r - 1].end === i.end + 1 && // check that first two markers match and adjacent
    t[r - 1].marker === i.marker && t[r - 1].token === i.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    t[i.end + 1].token === s.token + 1, l = String.fromCharCode(i.marker), f = e10.tokens[i.token];
    f.type = o ? "strong_open" : "em_open", f.tag = o ? "strong" : "em", f.nesting = 1, f.markup = o ? l + l : l, f.content = "";
    const h2 = e10.tokens[s.token];
    h2.type = o ? "strong_close" : "em_close", h2.tag = o ? "strong" : "em", h2.nesting = -1, h2.markup = o ? l + l : l, h2.content = "", o && (e10.tokens[t[r - 1].token].content = "", e10.tokens[t[i.end + 1].token].content = "", r--);
  }
}
function j8(e10) {
  const t = e10.tokens_meta, n = e10.tokens_meta.length;
  zf(e10, e10.delimiters);
  for (let r = 0; r < n; r++)
    t[r] && t[r].delimiters && zf(e10, t[r].delimiters);
}
var sd = {
  tokenize: H8,
  postProcess: j8
};
function U8(e10, t) {
  let n, r, i, s, o = "", l = "", f = e10.pos, h2 = true;
  if (e10.src.charCodeAt(e10.pos) !== 91)
    return false;
  const p = e10.pos, b = e10.posMax, v = e10.pos + 1, k = e10.md.helpers.parseLinkLabel(e10, e10.pos, true);
  if (k < 0)
    return false;
  let w = k + 1;
  if (w < b && e10.src.charCodeAt(w) === 40) {
    for (h2 = false, w++; w < b && (n = e10.src.charCodeAt(w), !(!Ge(n) && n !== 10)); w++)
      ;
    if (w >= b)
      return false;
    if (f = w, i = e10.md.helpers.parseLinkDestination(e10.src, w, e10.posMax), i.ok) {
      for (o = e10.md.normalizeLink(i.str), e10.md.validateLink(o) ? w = i.pos : o = "", f = w; w < b && (n = e10.src.charCodeAt(w), !(!Ge(n) && n !== 10)); w++)
        ;
      if (i = e10.md.helpers.parseLinkTitle(e10.src, w, e10.posMax), w < b && f !== w && i.ok)
        for (l = i.str, w = i.pos; w < b && (n = e10.src.charCodeAt(w), !(!Ge(n) && n !== 10)); w++)
          ;
    }
    (w >= b || e10.src.charCodeAt(w) !== 41) && (h2 = true), w++;
  }
  if (h2) {
    if (typeof e10.env.references > "u")
      return false;
    if (w < b && e10.src.charCodeAt(w) === 91 ? (f = w + 1, w = e10.md.helpers.parseLinkLabel(e10, w), w >= 0 ? r = e10.src.slice(f, w++) : w = k + 1) : w = k + 1, r || (r = e10.src.slice(v, k)), s = e10.env.references[R0(r)], !s)
      return e10.pos = p, false;
    o = s.href, l = s.title;
  }
  if (!t) {
    e10.pos = v, e10.posMax = k;
    const A = e10.push("link_open", "a", 1), T = [["href", o]];
    A.attrs = T, l && T.push(["title", l]), e10.linkLevel++, e10.md.inline.tokenize(e10), e10.linkLevel--, e10.push("link_close", "a", -1);
  }
  return e10.pos = w, e10.posMax = b, true;
}
function V8(e10, t) {
  let n, r, i, s, o, l, f, h2, p = "";
  const b = e10.pos, v = e10.posMax;
  if (e10.src.charCodeAt(e10.pos) !== 33 || e10.src.charCodeAt(e10.pos + 1) !== 91)
    return false;
  const k = e10.pos + 2, w = e10.md.helpers.parseLinkLabel(e10, e10.pos + 1, false);
  if (w < 0)
    return false;
  if (s = w + 1, s < v && e10.src.charCodeAt(s) === 40) {
    for (s++; s < v && (n = e10.src.charCodeAt(s), !(!Ge(n) && n !== 10)); s++)
      ;
    if (s >= v)
      return false;
    for (h2 = s, l = e10.md.helpers.parseLinkDestination(e10.src, s, e10.posMax), l.ok && (p = e10.md.normalizeLink(l.str), e10.md.validateLink(p) ? s = l.pos : p = ""), h2 = s; s < v && (n = e10.src.charCodeAt(s), !(!Ge(n) && n !== 10)); s++)
      ;
    if (l = e10.md.helpers.parseLinkTitle(e10.src, s, e10.posMax), s < v && h2 !== s && l.ok)
      for (f = l.str, s = l.pos; s < v && (n = e10.src.charCodeAt(s), !(!Ge(n) && n !== 10)); s++)
        ;
    else
      f = "";
    if (s >= v || e10.src.charCodeAt(s) !== 41)
      return e10.pos = b, false;
    s++;
  } else {
    if (typeof e10.env.references > "u")
      return false;
    if (s < v && e10.src.charCodeAt(s) === 91 ? (h2 = s + 1, s = e10.md.helpers.parseLinkLabel(e10, s), s >= 0 ? i = e10.src.slice(h2, s++) : s = w + 1) : s = w + 1, i || (i = e10.src.slice(k, w)), o = e10.env.references[R0(i)], !o)
      return e10.pos = b, false;
    p = o.href, f = o.title;
  }
  if (!t) {
    r = e10.src.slice(k, w);
    const A = [];
    e10.md.inline.parse(
      r,
      e10.md,
      e10.env,
      A
    );
    const T = e10.push("image", "img", 0), D = [["src", p], ["alt", ""]];
    T.attrs = D, T.children = A, T.content = r, f && D.push(["title", f]);
  }
  return e10.pos = s, e10.posMax = v, true;
}
var G8 = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var W8 = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function K8(e10, t) {
  let n = e10.pos;
  if (e10.src.charCodeAt(n) !== 60)
    return false;
  const r = e10.pos, i = e10.posMax;
  for (; ; ) {
    if (++n >= i) return false;
    const o = e10.src.charCodeAt(n);
    if (o === 60) return false;
    if (o === 62) break;
  }
  const s = e10.src.slice(r + 1, n);
  if (W8.test(s)) {
    const o = e10.md.normalizeLink(s);
    if (!e10.md.validateLink(o))
      return false;
    if (!t) {
      const l = e10.push("link_open", "a", 1);
      l.attrs = [["href", o]], l.markup = "autolink", l.info = "auto";
      const f = e10.push("text", "", 0);
      f.content = e10.md.normalizeLinkText(s);
      const h2 = e10.push("link_close", "a", -1);
      h2.markup = "autolink", h2.info = "auto";
    }
    return e10.pos += s.length + 2, true;
  }
  if (G8.test(s)) {
    const o = e10.md.normalizeLink("mailto:" + s);
    if (!e10.md.validateLink(o))
      return false;
    if (!t) {
      const l = e10.push("link_open", "a", 1);
      l.attrs = [["href", o]], l.markup = "autolink", l.info = "auto";
      const f = e10.push("text", "", 0);
      f.content = e10.md.normalizeLinkText(s);
      const h2 = e10.push("link_close", "a", -1);
      h2.markup = "autolink", h2.info = "auto";
    }
    return e10.pos += s.length + 2, true;
  }
  return false;
}
function X8(e10) {
  return /^<a[>\s]/i.test(e10);
}
function Y8(e10) {
  return /^<\/a\s*>/i.test(e10);
}
function Z8(e10) {
  const t = e10 | 32;
  return t >= 97 && t <= 122;
}
function J8(e10, t) {
  if (!e10.md.options.html)
    return false;
  const n = e10.posMax, r = e10.pos;
  if (e10.src.charCodeAt(r) !== 60 || r + 2 >= n)
    return false;
  const i = e10.src.charCodeAt(r + 1);
  if (i !== 33 && i !== 63 && i !== 47 && !Z8(i))
    return false;
  const s = e10.src.slice(r).match(C8);
  if (!s)
    return false;
  if (!t) {
    const o = e10.push("html_inline", "", 0);
    o.content = s[0], X8(o.content) && e10.linkLevel++, Y8(o.content) && e10.linkLevel--;
  }
  return e10.pos += s[0].length, true;
}
var Q8 = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var e7 = /^&([a-z][a-z0-9]{1,31});/i;
function t7(e10, t) {
  const n = e10.pos, r = e10.posMax;
  if (e10.src.charCodeAt(n) !== 38 || n + 1 >= r) return false;
  if (e10.src.charCodeAt(n + 1) === 35) {
    const s = e10.src.slice(n).match(Q8);
    if (s) {
      if (!t) {
        const o = s[1][0].toLowerCase() === "x" ? parseInt(s[1].slice(1), 16) : parseInt(s[1], 10), l = e10.push("text_special", "", 0);
        l.content = qa(o) ? w0(o) : w0(65533), l.markup = s[0], l.info = "entity";
      }
      return e10.pos += s[0].length, true;
    }
  } else {
    const s = e10.src.slice(n).match(e7);
    if (s) {
      const o = Z1(s[0]);
      if (o !== s[0]) {
        if (!t) {
          const l = e10.push("text_special", "", 0);
          l.content = o, l.markup = s[0], l.info = "entity";
        }
        return e10.pos += s[0].length, true;
      }
    }
  }
  return false;
}
function $f(e10) {
  const t = {}, n = e10.length;
  if (!n) return;
  let r = 0, i = -2;
  const s = [];
  for (let o = 0; o < n; o++) {
    const l = e10[o];
    if (s.push(0), (e10[r].marker !== l.marker || i !== l.token - 1) && (r = o), i = l.token, l.length = l.length || 0, !l.close) continue;
    t.hasOwnProperty(l.marker) || (t[l.marker] = [-1, -1, -1, -1, -1, -1]);
    const f = t[l.marker][(l.open ? 3 : 0) + l.length % 3];
    let h2 = r - s[r] - 1, p = h2;
    for (; h2 > f; h2 -= s[h2] + 1) {
      const b = e10[h2];
      if (b.marker === l.marker && b.open && b.end < 0) {
        let v = false;
        if ((b.close || l.open) && (b.length + l.length) % 3 === 0 && (b.length % 3 !== 0 || l.length % 3 !== 0) && (v = true), !v) {
          const k = h2 > 0 && !e10[h2 - 1].open ? s[h2 - 1] + 1 : 0;
          s[o] = o - h2 + k, s[h2] = k, l.open = false, b.end = o, b.close = false, p = -1, i = -2;
          break;
        }
      }
    }
    p !== -1 && (t[l.marker][(l.open ? 3 : 0) + (l.length || 0) % 3] = p);
  }
}
function n7(e10) {
  const t = e10.tokens_meta, n = e10.tokens_meta.length;
  $f(e10.delimiters);
  for (let r = 0; r < n; r++)
    t[r] && t[r].delimiters && $f(t[r].delimiters);
}
function r7(e10) {
  let t, n, r = 0;
  const i = e10.tokens, s = e10.tokens.length;
  for (t = n = 0; t < s; t++)
    i[t].nesting < 0 && r--, i[t].level = r, i[t].nesting > 0 && r++, i[t].type === "text" && t + 1 < s && i[t + 1].type === "text" ? i[t + 1].content = i[t].content + i[t + 1].content : (t !== n && (i[n] = i[t]), n++);
  t !== n && (i.length = n);
}
var io = [
  ["text", B8],
  ["linkify", z8],
  ["newline", $8],
  ["escape", L8],
  ["backticks", q8],
  ["strikethrough", id.tokenize],
  ["emphasis", sd.tokenize],
  ["link", U8],
  ["image", V8],
  ["autolink", K8],
  ["html_inline", J8],
  ["entity", t7]
];
var so = [
  ["balance_pairs", n7],
  ["strikethrough", id.postProcess],
  ["emphasis", sd.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", r7]
];
function is() {
  this.ruler = new It();
  for (let e10 = 0; e10 < io.length; e10++)
    this.ruler.push(io[e10][0], io[e10][1]);
  this.ruler2 = new It();
  for (let e10 = 0; e10 < so.length; e10++)
    this.ruler2.push(so[e10][0], so[e10][1]);
}
is.prototype.skipToken = function(e10) {
  const t = e10.pos, n = this.ruler.getRules(""), r = n.length, i = e10.md.options.maxNesting, s = e10.cache;
  if (typeof s[t] < "u") {
    e10.pos = s[t];
    return;
  }
  let o = false;
  if (e10.level < i) {
    for (let l = 0; l < r; l++)
      if (e10.level++, o = n[l](e10, true), e10.level--, o) {
        if (t >= e10.pos)
          throw new Error("inline rule didn't increment state.pos");
        break;
      }
  } else
    e10.pos = e10.posMax;
  o || e10.pos++, s[t] = e10.pos;
};
is.prototype.tokenize = function(e10) {
  const t = this.ruler.getRules(""), n = t.length, r = e10.posMax, i = e10.md.options.maxNesting;
  for (; e10.pos < r; ) {
    const s = e10.pos;
    let o = false;
    if (e10.level < i) {
      for (let l = 0; l < n; l++)
        if (o = t[l](e10, false), o) {
          if (s >= e10.pos)
            throw new Error("inline rule didn't increment state.pos");
          break;
        }
    }
    if (o) {
      if (e10.pos >= r)
        break;
      continue;
    }
    e10.pending += e10.src[e10.pos++];
  }
  e10.pending && e10.pushPending();
};
is.prototype.parse = function(e10, t, n, r) {
  const i = new this.State(e10, t, n, r);
  this.tokenize(i);
  const s = this.ruler2.getRules(""), o = s.length;
  for (let l = 0; l < o; l++)
    s[l](i);
};
is.prototype.State = rs;
function i7(e10) {
  const t = {};
  e10 = e10 || {}, t.src_Any = G1.source, t.src_Cc = W1.source, t.src_Z = X1.source, t.src_P = $a.source, t.src_ZPCc = [t.src_Z, t.src_P, t.src_Cc].join("|"), t.src_ZCc = [t.src_Z, t.src_Cc].join("|");
  const n = "[><ï½œ]";
  return t.src_pseudo_letter = "(?:(?!" + n + "|" + t.src_ZPCc + ")" + t.src_Any + ")", t.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", t.src_auth = "(?:(?:(?!" + t.src_ZCc + "|[@/\\[\\]()]).)+@)?", t.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", t.src_host_terminator = "(?=$|" + n + "|" + t.src_ZPCc + ")(?!" + (e10["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + t.src_ZPCc + "))", t.src_path = "(?:[/?#](?:(?!" + t.src_ZCc + "|" + n + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + t.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + t.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + t.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + t.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + t.src_ZCc + "|[']).)+\\'|\\'(?=" + t.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + t.src_ZCc + "|[.]|$)|" + (e10["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
  ",(?!" + t.src_ZCc + "|$)|;(?!" + t.src_ZCc + "|$)|\\!+(?!" + t.src_ZCc + "|[!]|$)|\\?(?!" + t.src_ZCc + "|[?]|$))+|\\/)?", t.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', t.src_xn = "xn--[a-z0-9\\-]{1,59}", t.src_domain_root = // Allow letters & digits (http://test1)
  "(?:" + t.src_xn + "|" + t.src_pseudo_letter + "{1,63})", t.src_domain = "(?:" + t.src_xn + "|(?:" + t.src_pseudo_letter + ")|(?:" + t.src_pseudo_letter + "(?:-|" + t.src_pseudo_letter + "){0,61}" + t.src_pseudo_letter + "))", t.src_host = "(?:(?:(?:(?:" + t.src_domain + ")\\.)*" + t.src_domain + "))", t.tpl_host_fuzzy = "(?:" + t.src_ip4 + "|(?:(?:(?:" + t.src_domain + ")\\.)+(?:%TLDS%)))", t.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + t.src_domain + ")\\.)+(?:%TLDS%))", t.src_host_strict = t.src_host + t.src_host_terminator, t.tpl_host_fuzzy_strict = t.tpl_host_fuzzy + t.src_host_terminator, t.src_host_port_strict = t.src_host + t.src_port + t.src_host_terminator, t.tpl_host_port_fuzzy_strict = t.tpl_host_fuzzy + t.src_port + t.src_host_terminator, t.tpl_host_port_no_ip_fuzzy_strict = t.tpl_host_no_ip_fuzzy + t.src_port + t.src_host_terminator, t.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + t.src_ZPCc + "|>|$))", t.tpl_email_fuzzy = "(^|" + n + '|"|\\(|' + t.src_ZCc + ")(" + t.src_email_name + "@" + t.tpl_host_fuzzy_strict + ")", t.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|ï½œ]|" + t.src_ZPCc + "))((?![$+<=>^`|ï½œ])" + t.tpl_host_port_fuzzy_strict + t.src_path + ")", t.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|ï½œ]|" + t.src_ZPCc + "))((?![$+<=>^`|ï½œ])" + t.tpl_host_port_no_ip_fuzzy_strict + t.src_path + ")", t;
}
function Uo(e10) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(n) {
    n && Object.keys(n).forEach(function(r) {
      e10[r] = n[r];
    });
  }), e10;
}
function H0(e10) {
  return Object.prototype.toString.call(e10);
}
function s7(e10) {
  return H0(e10) === "[object String]";
}
function u7(e10) {
  return H0(e10) === "[object Object]";
}
function o7(e10) {
  return H0(e10) === "[object RegExp]";
}
function Lf(e10) {
  return H0(e10) === "[object Function]";
}
function a7(e10) {
  return e10.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var ud = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function l7(e10) {
  return Object.keys(e10 || {}).reduce(function(t, n) {
    return t || ud.hasOwnProperty(n);
  }, false);
}
var c7 = {
  "http:": {
    validate: function(e10, t, n) {
      const r = e10.slice(t);
      return n.re.http || (n.re.http = new RegExp(
        "^\\/\\/" + n.re.src_auth + n.re.src_host_port_strict + n.re.src_path,
        "i"
      )), n.re.http.test(r) ? r.match(n.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(e10, t, n) {
      const r = e10.slice(t);
      return n.re.no_http || (n.re.no_http = new RegExp(
        "^" + n.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        "(?:localhost|(?:(?:" + n.re.src_domain + ")\\.)+" + n.re.src_domain_root + ")" + n.re.src_port + n.re.src_host_terminator + n.re.src_path,
        "i"
      )), n.re.no_http.test(r) ? t >= 3 && e10[t - 3] === ":" || t >= 3 && e10[t - 3] === "/" ? 0 : r.match(n.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(e10, t, n) {
      const r = e10.slice(t);
      return n.re.mailto || (n.re.mailto = new RegExp(
        "^" + n.re.src_email_name + "@" + n.re.src_host_strict,
        "i"
      )), n.re.mailto.test(r) ? r.match(n.re.mailto)[0].length : 0;
    }
  }
};
var f7 = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
var h7 = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|Ñ€Ñ„".split("|");
function d7(e10) {
  e10.__index__ = -1, e10.__text_cache__ = "";
}
function p7(e10) {
  return function(t, n) {
    const r = t.slice(n);
    return e10.test(r) ? r.match(e10)[0].length : 0;
  };
}
function qf() {
  return function(e10, t) {
    t.normalize(e10);
  };
}
function v0(e10) {
  const t = e10.re = i7(e10.__opts__), n = e10.__tlds__.slice();
  e10.onCompile(), e10.__tlds_replaced__ || n.push(f7), n.push(t.src_xn), t.src_tlds = n.join("|");
  function r(l) {
    return l.replace("%TLDS%", t.src_tlds);
  }
  t.email_fuzzy = RegExp(r(t.tpl_email_fuzzy), "i"), t.link_fuzzy = RegExp(r(t.tpl_link_fuzzy), "i"), t.link_no_ip_fuzzy = RegExp(r(t.tpl_link_no_ip_fuzzy), "i"), t.host_fuzzy_test = RegExp(r(t.tpl_host_fuzzy_test), "i");
  const i = [];
  e10.__compiled__ = {};
  function s(l, f) {
    throw new Error('(LinkifyIt) Invalid schema "' + l + '": ' + f);
  }
  Object.keys(e10.__schemas__).forEach(function(l) {
    const f = e10.__schemas__[l];
    if (f === null)
      return;
    const h2 = { validate: null, link: null };
    if (e10.__compiled__[l] = h2, u7(f)) {
      o7(f.validate) ? h2.validate = p7(f.validate) : Lf(f.validate) ? h2.validate = f.validate : s(l, f), Lf(f.normalize) ? h2.normalize = f.normalize : f.normalize ? s(l, f) : h2.normalize = qf();
      return;
    }
    if (s7(f)) {
      i.push(l);
      return;
    }
    s(l, f);
  }), i.forEach(function(l) {
    e10.__compiled__[e10.__schemas__[l]] && (e10.__compiled__[l].validate = e10.__compiled__[e10.__schemas__[l]].validate, e10.__compiled__[l].normalize = e10.__compiled__[e10.__schemas__[l]].normalize);
  }), e10.__compiled__[""] = { validate: null, normalize: qf() };
  const o = Object.keys(e10.__compiled__).filter(function(l) {
    return l.length > 0 && e10.__compiled__[l];
  }).map(a7).join("|");
  e10.re.schema_test = RegExp("(^|(?!_)(?:[><ï½œ]|" + t.src_ZPCc + "))(" + o + ")", "i"), e10.re.schema_search = RegExp("(^|(?!_)(?:[><ï½œ]|" + t.src_ZPCc + "))(" + o + ")", "ig"), e10.re.schema_at_start = RegExp("^" + e10.re.schema_search.source, "i"), e10.re.pretest = RegExp(
    "(" + e10.re.schema_test.source + ")|(" + e10.re.host_fuzzy_test.source + ")|@",
    "i"
  ), d7(e10);
}
function m7(e10, t) {
  const n = e10.__index__, r = e10.__last_index__, i = e10.__text_cache__.slice(n, r);
  this.schema = e10.__schema__.toLowerCase(), this.index = n + t, this.lastIndex = r + t, this.raw = i, this.text = i, this.url = i;
}
function Vo(e10, t) {
  const n = new m7(e10, t);
  return e10.__compiled__[n.schema].normalize(n, e10), n;
}
function Lt(e10, t) {
  if (!(this instanceof Lt))
    return new Lt(e10, t);
  t || l7(e10) && (t = e10, e10 = {}), this.__opts__ = Uo({}, ud, t), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = Uo({}, c7, e10), this.__compiled__ = {}, this.__tlds__ = h7, this.__tlds_replaced__ = false, this.re = {}, v0(this);
}
Lt.prototype.add = function(t, n) {
  return this.__schemas__[t] = n, v0(this), this;
};
Lt.prototype.set = function(t) {
  return this.__opts__ = Uo(this.__opts__, t), this;
};
Lt.prototype.test = function(t) {
  if (this.__text_cache__ = t, this.__index__ = -1, !t.length)
    return false;
  let n, r, i, s, o, l, f, h2, p;
  if (this.re.schema_test.test(t)) {
    for (f = this.re.schema_search, f.lastIndex = 0; (n = f.exec(t)) !== null; )
      if (s = this.testSchemaAt(t, n[2], f.lastIndex), s) {
        this.__schema__ = n[2], this.__index__ = n.index + n[1].length, this.__last_index__ = n.index + n[0].length + s;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (h2 = t.search(this.re.host_fuzzy_test), h2 >= 0 && (this.__index__ < 0 || h2 < this.__index__) && (r = t.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (o = r.index + r[1].length, (this.__index__ < 0 || o < this.__index__) && (this.__schema__ = "", this.__index__ = o, this.__last_index__ = r.index + r[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (p = t.indexOf("@"), p >= 0 && (i = t.match(this.re.email_fuzzy)) !== null && (o = i.index + i[1].length, l = i.index + i[0].length, (this.__index__ < 0 || o < this.__index__ || o === this.__index__ && l > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = o, this.__last_index__ = l))), this.__index__ >= 0;
};
Lt.prototype.pretest = function(t) {
  return this.re.pretest.test(t);
};
Lt.prototype.testSchemaAt = function(t, n, r) {
  return this.__compiled__[n.toLowerCase()] ? this.__compiled__[n.toLowerCase()].validate(t, r, this) : 0;
};
Lt.prototype.match = function(t) {
  const n = [];
  let r = 0;
  this.__index__ >= 0 && this.__text_cache__ === t && (n.push(Vo(this, r)), r = this.__last_index__);
  let i = r ? t.slice(r) : t;
  for (; this.test(i); )
    n.push(Vo(this, r)), i = i.slice(this.__last_index__), r += this.__last_index__;
  return n.length ? n : null;
};
Lt.prototype.matchAtStart = function(t) {
  if (this.__text_cache__ = t, this.__index__ = -1, !t.length) return null;
  const n = this.re.schema_at_start.exec(t);
  if (!n) return null;
  const r = this.testSchemaAt(t, n[2], n[0].length);
  return r ? (this.__schema__ = n[2], this.__index__ = n.index + n[1].length, this.__last_index__ = n.index + n[0].length + r, Vo(this, 0)) : null;
};
Lt.prototype.tlds = function(t, n) {
  return t = Array.isArray(t) ? t : [t], n ? (this.__tlds__ = this.__tlds__.concat(t).sort().filter(function(r, i, s) {
    return r !== s[i - 1];
  }).reverse(), v0(this), this) : (this.__tlds__ = t.slice(), this.__tlds_replaced__ = true, v0(this), this);
};
Lt.prototype.normalize = function(t) {
  t.schema || (t.url = "http://" + t.url), t.schema === "mailto:" && !/^mailto:/i.test(t.url) && (t.url = "mailto:" + t.url);
};
Lt.prototype.onCompile = function() {
};
var Hr = 2147483647;
var hn = 36;
var Ha = 1;
var Vi = 26;
var g7 = 38;
var b7 = 700;
var od = 72;
var ad = 128;
var ld = "-";
var y7 = /^xn--/;
var x7 = /[^\0-\x7F]/;
var w7 = /[\x2E\u3002\uFF0E\uFF61]/g;
var v7 = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var uo = hn - Ha;
var dn = Math.floor;
var oo = String.fromCharCode;
function Vn(e10) {
  throw new RangeError(v7[e10]);
}
function k7(e10, t) {
  const n = [];
  let r = e10.length;
  for (; r--; )
    n[r] = t(e10[r]);
  return n;
}
function cd(e10, t) {
  const n = e10.split("@");
  let r = "";
  n.length > 1 && (r = n[0] + "@", e10 = n[1]), e10 = e10.replace(w7, ".");
  const i = e10.split("."), s = k7(i, t).join(".");
  return r + s;
}
function fd(e10) {
  const t = [];
  let n = 0;
  const r = e10.length;
  for (; n < r; ) {
    const i = e10.charCodeAt(n++);
    if (i >= 55296 && i <= 56319 && n < r) {
      const s = e10.charCodeAt(n++);
      (s & 64512) == 56320 ? t.push(((i & 1023) << 10) + (s & 1023) + 65536) : (t.push(i), n--);
    } else
      t.push(i);
  }
  return t;
}
var _7 = (e10) => String.fromCodePoint(...e10);
var S7 = function(e10) {
  return e10 >= 48 && e10 < 58 ? 26 + (e10 - 48) : e10 >= 65 && e10 < 91 ? e10 - 65 : e10 >= 97 && e10 < 123 ? e10 - 97 : hn;
};
var Rf = function(e10, t) {
  return e10 + 22 + 75 * (e10 < 26) - ((t != 0) << 5);
};
var hd = function(e10, t, n) {
  let r = 0;
  for (e10 = n ? dn(e10 / b7) : e10 >> 1, e10 += dn(e10 / t); e10 > uo * Vi >> 1; r += hn)
    e10 = dn(e10 / uo);
  return dn(r + (uo + 1) * e10 / (e10 + g7));
};
var dd = function(e10) {
  const t = [], n = e10.length;
  let r = 0, i = ad, s = od, o = e10.lastIndexOf(ld);
  o < 0 && (o = 0);
  for (let l = 0; l < o; ++l)
    e10.charCodeAt(l) >= 128 && Vn("not-basic"), t.push(e10.charCodeAt(l));
  for (let l = o > 0 ? o + 1 : 0; l < n; ) {
    const f = r;
    for (let p = 1, b = hn; ; b += hn) {
      l >= n && Vn("invalid-input");
      const v = S7(e10.charCodeAt(l++));
      v >= hn && Vn("invalid-input"), v > dn((Hr - r) / p) && Vn("overflow"), r += v * p;
      const k = b <= s ? Ha : b >= s + Vi ? Vi : b - s;
      if (v < k)
        break;
      const w = hn - k;
      p > dn(Hr / w) && Vn("overflow"), p *= w;
    }
    const h2 = t.length + 1;
    s = hd(r - f, h2, f == 0), dn(r / h2) > Hr - i && Vn("overflow"), i += dn(r / h2), r %= h2, t.splice(r++, 0, i);
  }
  return String.fromCodePoint(...t);
};
var pd = function(e10) {
  const t = [];
  e10 = fd(e10);
  const n = e10.length;
  let r = ad, i = 0, s = od;
  for (const f of e10)
    f < 128 && t.push(oo(f));
  const o = t.length;
  let l = o;
  for (o && t.push(ld); l < n; ) {
    let f = Hr;
    for (const p of e10)
      p >= r && p < f && (f = p);
    const h2 = l + 1;
    f - r > dn((Hr - i) / h2) && Vn("overflow"), i += (f - r) * h2, r = f;
    for (const p of e10)
      if (p < r && ++i > Hr && Vn("overflow"), p === r) {
        let b = i;
        for (let v = hn; ; v += hn) {
          const k = v <= s ? Ha : v >= s + Vi ? Vi : v - s;
          if (b < k)
            break;
          const w = b - k, A = hn - k;
          t.push(
            oo(Rf(k + w % A, 0))
          ), b = dn(w / A);
        }
        t.push(oo(Rf(b, 0))), s = hd(i, h2, l === o), i = 0, ++l;
      }
    ++i, ++r;
  }
  return t.join("");
};
var A7 = function(e10) {
  return cd(e10, function(t) {
    return y7.test(t) ? dd(t.slice(4).toLowerCase()) : t;
  });
};
var E7 = function(e10) {
  return cd(e10, function(t) {
    return x7.test(t) ? "xn--" + pd(t) : t;
  });
};
var md = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  version: "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  ucs2: {
    decode: fd,
    encode: _7
  },
  decode: dd,
  encode: pd,
  toASCII: E7,
  toUnicode: A7
};
var C7 = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use 'Â«Â»â€â€œ' for Russian, 'â€â€œâ€šâ€˜' for German,
    // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
    quotes: "â€œâ€â€˜â€™",
    /* â€œâ€â€˜â€™ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
};
var T7 = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use 'Â«Â»â€â€œ' for Russian, 'â€â€œâ€šâ€˜' for German,
    // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
    quotes: "â€œâ€â€˜â€™",
    /* â€œâ€â€˜â€™ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
};
var D7 = {
  options: {
    // Enable HTML tags in source
    html: true,
    // Use '/' to close single tags (<br />)
    xhtmlOut: true,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use 'Â«Â»â€â€œ' for Russian, 'â€â€œâ€šâ€˜' for German,
    // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
    quotes: "â€œâ€â€˜â€™",
    /* â€œâ€â€˜â€™ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
};
var M7 = {
  default: C7,
  zero: T7,
  commonmark: D7
};
var N7 = /^(vbscript|javascript|file|data):/;
var I7 = /^data:image\/(gif|png|jpeg|webp);/;
function F7(e10) {
  const t = e10.trim().toLowerCase();
  return N7.test(t) ? I7.test(t) : true;
}
var gd = ["http:", "https:", "mailto:"];
function B7(e10) {
  const t = za(e10, true);
  if (t.hostname && (!t.protocol || gd.indexOf(t.protocol) >= 0))
    try {
      t.hostname = md.toASCII(t.hostname);
    } catch {
    }
  return ns(Oa(t));
}
function O7(e10) {
  const t = za(e10, true);
  if (t.hostname && (!t.protocol || gd.indexOf(t.protocol) >= 0))
    try {
      t.hostname = md.toUnicode(t.hostname);
    } catch {
    }
  return Xr(Oa(t), Xr.defaultChars + "%");
}
function Xt(e10, t) {
  if (!(this instanceof Xt))
    return new Xt(e10, t);
  t || La(e10) || (t = e10 || {}, e10 = "default"), this.inline = new is(), this.block = new P0(), this.core = new Ra(), this.renderer = new ui(), this.linkify = new Lt(), this.validateLink = F7, this.normalizeLink = B7, this.normalizeLinkText = O7, this.utils = $g, this.helpers = q0({}, Pg), this.options = {}, this.configure(e10), t && this.set(t);
}
Xt.prototype.set = function(e10) {
  return q0(this.options, e10), this;
};
Xt.prototype.configure = function(e10) {
  const t = this;
  if (La(e10)) {
    const n = e10;
    if (e10 = M7[n], !e10)
      throw new Error('Wrong `markdown-it` preset "' + n + '", check name');
  }
  if (!e10)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return e10.options && t.set(e10.options), e10.components && Object.keys(e10.components).forEach(function(n) {
    e10.components[n].rules && t[n].ruler.enableOnly(e10.components[n].rules), e10.components[n].rules2 && t[n].ruler2.enableOnly(e10.components[n].rules2);
  }), this;
};
Xt.prototype.enable = function(e10, t) {
  let n = [];
  Array.isArray(e10) || (e10 = [e10]), ["core", "block", "inline"].forEach(function(i) {
    n = n.concat(this[i].ruler.enable(e10, true));
  }, this), n = n.concat(this.inline.ruler2.enable(e10, true));
  const r = e10.filter(function(i) {
    return n.indexOf(i) < 0;
  });
  if (r.length && !t)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + r);
  return this;
};
Xt.prototype.disable = function(e10, t) {
  let n = [];
  Array.isArray(e10) || (e10 = [e10]), ["core", "block", "inline"].forEach(function(i) {
    n = n.concat(this[i].ruler.disable(e10, true));
  }, this), n = n.concat(this.inline.ruler2.disable(e10, true));
  const r = e10.filter(function(i) {
    return n.indexOf(i) < 0;
  });
  if (r.length && !t)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + r);
  return this;
};
Xt.prototype.use = function(e10) {
  const t = [this].concat(Array.prototype.slice.call(arguments, 1));
  return e10.apply(e10, t), this;
};
Xt.prototype.parse = function(e10, t) {
  if (typeof e10 != "string")
    throw new Error("Input data should be a String");
  const n = new this.core.State(e10, this, t);
  return this.core.process(n), n.tokens;
};
Xt.prototype.render = function(e10, t) {
  return t = t || {}, this.renderer.render(this.parse(e10, t), this.options, t);
};
Xt.prototype.parseInline = function(e10, t) {
  const n = new this.core.State(e10, this, t);
  return n.inlineMode = true, this.core.process(n), n.tokens;
};
Xt.prototype.renderInline = function(e10, t) {
  return t = t || {}, this.renderer.render(this.parseInline(e10, t), this.options, t);
};
function z7(e10) {
  function t(r, i) {
    const s = r.pos, o = r.src.charCodeAt(s);
    if (i || o !== 43)
      return false;
    const l = r.scanDelims(r.pos, true);
    let f = l.length;
    const h2 = String.fromCharCode(o);
    if (f < 2)
      return false;
    if (f % 2) {
      const p = r.push("text", "", 0);
      p.content = h2, f--;
    }
    for (let p = 0; p < f; p += 2) {
      const b = r.push("text", "", 0);
      b.content = h2 + h2, !(!l.can_open && !l.can_close) && r.delimiters.push({
        marker: o,
        length: 0,
        // disable "rule of 3" length checks meant for emphasis
        jump: p / 2,
        // 1 delimiter = 2 characters
        token: r.tokens.length - 1,
        end: -1,
        open: l.can_open,
        close: l.can_close
      });
    }
    return r.pos += l.length, true;
  }
  function n(r, i) {
    let s;
    const o = [], l = i.length;
    for (let f = 0; f < l; f++) {
      const h2 = i[f];
      if (h2.marker !== 43 || h2.end === -1)
        continue;
      const p = i[h2.end];
      s = r.tokens[h2.token], s.type = "ins_open", s.tag = "ins", s.nesting = 1, s.markup = "++", s.content = "", s = r.tokens[p.token], s.type = "ins_close", s.tag = "ins", s.nesting = -1, s.markup = "++", s.content = "", r.tokens[p.token - 1].type === "text" && r.tokens[p.token - 1].content === "+" && o.push(p.token - 1);
    }
    for (; o.length; ) {
      const f = o.pop();
      let h2 = f + 1;
      for (; h2 < r.tokens.length && r.tokens[h2].type === "ins_close"; )
        h2++;
      h2--, f !== h2 && (s = r.tokens[h2], r.tokens[h2] = r.tokens[f], r.tokens[f] = s);
    }
  }
  e10.inline.ruler.before("emphasis", "ins", t), e10.inline.ruler2.before("emphasis", "ins", function(r) {
    const i = r.tokens_meta, s = (r.tokens_meta || []).length;
    n(r, r.delimiters);
    for (let o = 0; o < s; o++)
      i[o] && i[o].delimiters && n(r, i[o].delimiters);
  });
}
function $7(e10) {
  function t(r, i) {
    const s = r.pos, o = r.src.charCodeAt(s);
    if (i || o !== 61)
      return false;
    const l = r.scanDelims(r.pos, true);
    let f = l.length;
    const h2 = String.fromCharCode(o);
    if (f < 2)
      return false;
    if (f % 2) {
      const p = r.push("text", "", 0);
      p.content = h2, f--;
    }
    for (let p = 0; p < f; p += 2) {
      const b = r.push("text", "", 0);
      b.content = h2 + h2, !(!l.can_open && !l.can_close) && r.delimiters.push({
        marker: o,
        length: 0,
        // disable "rule of 3" length checks meant for emphasis
        jump: p / 2,
        // 1 delimiter = 2 characters
        token: r.tokens.length - 1,
        end: -1,
        open: l.can_open,
        close: l.can_close
      });
    }
    return r.pos += l.length, true;
  }
  function n(r, i) {
    const s = [], o = i.length;
    for (let l = 0; l < o; l++) {
      const f = i[l];
      if (f.marker !== 61 || f.end === -1)
        continue;
      const h2 = i[f.end], p = r.tokens[f.token];
      p.type = "mark_open", p.tag = "mark", p.nesting = 1, p.markup = "==", p.content = "";
      const b = r.tokens[h2.token];
      b.type = "mark_close", b.tag = "mark", b.nesting = -1, b.markup = "==", b.content = "", r.tokens[h2.token - 1].type === "text" && r.tokens[h2.token - 1].content === "=" && s.push(h2.token - 1);
    }
    for (; s.length; ) {
      const l = s.pop();
      let f = l + 1;
      for (; f < r.tokens.length && r.tokens[f].type === "mark_close"; )
        f++;
      if (f--, l !== f) {
        const h2 = r.tokens[f];
        r.tokens[f] = r.tokens[l], r.tokens[l] = h2;
      }
    }
  }
  e10.inline.ruler.before("emphasis", "mark", t), e10.inline.ruler2.before("emphasis", "mark", function(r) {
    let i;
    const s = r.tokens_meta, o = (r.tokens_meta || []).length;
    for (n(r, r.delimiters), i = 0; i < o; i++)
      s[i] && s[i].delimiters && n(r, s[i].delimiters);
  });
}
var L7 = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g;
function q7(e10, t) {
  const n = e10.posMax, r = e10.pos;
  if (e10.src.charCodeAt(r) !== 126 || t || r + 2 >= n)
    return false;
  e10.pos = r + 1;
  let i = false;
  for (; e10.pos < n; ) {
    if (e10.src.charCodeAt(e10.pos) === 126) {
      i = true;
      break;
    }
    e10.md.inline.skipToken(e10);
  }
  if (!i || r + 1 === e10.pos)
    return e10.pos = r, false;
  const s = e10.src.slice(r + 1, e10.pos);
  if (s.match(/(^|[^\\])(\\\\)*\s/))
    return e10.pos = r, false;
  e10.posMax = e10.pos, e10.pos = r + 1;
  const o = e10.push("sub_open", "sub", 1);
  o.markup = "~";
  const l = e10.push("text", "", 0);
  l.content = s.replace(L7, "$1");
  const f = e10.push("sub_close", "sub", -1);
  return f.markup = "~", e10.pos = e10.posMax + 1, e10.posMax = n, true;
}
function R7(e10) {
  e10.inline.ruler.after("emphasis", "sub", q7);
}
var P7 = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g;
function H7(e10, t) {
  const n = e10.posMax, r = e10.pos;
  if (e10.src.charCodeAt(r) !== 94 || t || r + 2 >= n)
    return false;
  e10.pos = r + 1;
  let i = false;
  for (; e10.pos < n; ) {
    if (e10.src.charCodeAt(e10.pos) === 94) {
      i = true;
      break;
    }
    e10.md.inline.skipToken(e10);
  }
  if (!i || r + 1 === e10.pos)
    return e10.pos = r, false;
  const s = e10.src.slice(r + 1, e10.pos);
  if (s.match(/(^|[^\\])(\\\\)*\s/))
    return e10.pos = r, false;
  e10.posMax = e10.pos, e10.pos = r + 1;
  const o = e10.push("sup_open", "sup", 1);
  o.markup = "^";
  const l = e10.push("text", "", 0);
  l.content = s.replace(P7, "$1");
  const f = e10.push("sup_close", "sup", -1);
  return f.markup = "^", e10.pos = e10.posMax + 1, e10.posMax = n, true;
}
function j7(e10) {
  e10.inline.ruler.after("emphasis", "sup", H7);
}
var ja = Symbol.for("yaml.alias");
var Go = Symbol.for("yaml.document");
var er = Symbol.for("yaml.map");
var bd = Symbol.for("yaml.pair");
var mn = Symbol.for("yaml.scalar");
var oi = Symbol.for("yaml.seq");
var Yt = Symbol.for("yaml.node.type");
var Ar = (e10) => !!e10 && typeof e10 == "object" && e10[Yt] === ja;
var j0 = (e10) => !!e10 && typeof e10 == "object" && e10[Yt] === Go;
var ss = (e10) => !!e10 && typeof e10 == "object" && e10[Yt] === er;
var at = (e10) => !!e10 && typeof e10 == "object" && e10[Yt] === bd;
var We = (e10) => !!e10 && typeof e10 == "object" && e10[Yt] === mn;
var us = (e10) => !!e10 && typeof e10 == "object" && e10[Yt] === oi;
function ut(e10) {
  if (e10 && typeof e10 == "object")
    switch (e10[Yt]) {
      case er:
      case oi:
        return true;
    }
  return false;
}
function ot(e10) {
  if (e10 && typeof e10 == "object")
    switch (e10[Yt]) {
      case ja:
      case er:
      case mn:
      case oi:
        return true;
    }
  return false;
}
var yd = (e10) => (We(e10) || ut(e10)) && !!e10.anchor;
var cr = Symbol("break visit");
var U7 = Symbol("skip children");
var Oi = Symbol("remove node");
function ai(e10, t) {
  const n = V7(t);
  j0(e10) ? Lr(null, e10.contents, n, Object.freeze([e10])) === Oi && (e10.contents = null) : Lr(null, e10, n, Object.freeze([]));
}
ai.BREAK = cr;
ai.SKIP = U7;
ai.REMOVE = Oi;
function Lr(e10, t, n, r) {
  const i = G7(e10, t, n, r);
  if (ot(i) || at(i))
    return W7(e10, r, i), Lr(e10, i, n, r);
  if (typeof i != "symbol") {
    if (ut(t)) {
      r = Object.freeze(r.concat(t));
      for (let s = 0; s < t.items.length; ++s) {
        const o = Lr(s, t.items[s], n, r);
        if (typeof o == "number")
          s = o - 1;
        else {
          if (o === cr)
            return cr;
          o === Oi && (t.items.splice(s, 1), s -= 1);
        }
      }
    } else if (at(t)) {
      r = Object.freeze(r.concat(t));
      const s = Lr("key", t.key, n, r);
      if (s === cr)
        return cr;
      s === Oi && (t.key = null);
      const o = Lr("value", t.value, n, r);
      if (o === cr)
        return cr;
      o === Oi && (t.value = null);
    }
  }
  return i;
}
function V7(e10) {
  return typeof e10 == "object" && (e10.Collection || e10.Node || e10.Value) ? Object.assign({
    Alias: e10.Node,
    Map: e10.Node,
    Scalar: e10.Node,
    Seq: e10.Node
  }, e10.Value && {
    Map: e10.Value,
    Scalar: e10.Value,
    Seq: e10.Value
  }, e10.Collection && {
    Map: e10.Collection,
    Seq: e10.Collection
  }, e10) : e10;
}
function G7(e10, t, n, r) {
  var _a2, _b2, _c, _d2, _e;
  if (typeof n == "function")
    return n(e10, t, r);
  if (ss(t))
    return (_a2 = n.Map) == null ? void 0 : _a2.call(n, e10, t, r);
  if (us(t))
    return (_b2 = n.Seq) == null ? void 0 : _b2.call(n, e10, t, r);
  if (at(t))
    return (_c = n.Pair) == null ? void 0 : _c.call(n, e10, t, r);
  if (We(t))
    return (_d2 = n.Scalar) == null ? void 0 : _d2.call(n, e10, t, r);
  if (Ar(t))
    return (_e = n.Alias) == null ? void 0 : _e.call(n, e10, t, r);
}
function W7(e10, t, n) {
  const r = t[t.length - 1];
  if (ut(r))
    r.items[e10] = n;
  else if (at(r))
    e10 === "key" ? r.key = n : r.value = n;
  else if (j0(r))
    r.contents = n;
  else {
    const i = Ar(r) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${i} parent`);
  }
}
var K7 = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var X7 = (e10) => e10.replace(/[!,[\]{}]/g, (t) => K7[t]);
var St = class _St {
  constructor(t, n) {
    this.docStart = null, this.docEnd = false, this.yaml = Object.assign({}, _St.defaultYaml, t), this.tags = Object.assign({}, _St.defaultTags, n);
  }
  clone() {
    const t = new _St(this.yaml, this.tags);
    return t.docStart = this.docStart, t;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const t = new _St(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false, this.yaml = {
          explicit: _St.defaultYaml.explicit,
          version: "1.2"
        }, this.tags = Object.assign({}, _St.defaultTags);
        break;
    }
    return t;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(t, n) {
    this.atNextDocument && (this.yaml = { explicit: _St.defaultYaml.explicit, version: "1.1" }, this.tags = Object.assign({}, _St.defaultTags), this.atNextDocument = false);
    const r = t.trim().split(/[ \t]+/), i = r.shift();
    switch (i) {
      case "%TAG": {
        if (r.length !== 2 && (n(0, "%TAG directive should contain exactly two parts"), r.length < 2))
          return false;
        const [s, o] = r;
        return this.tags[s] = o, true;
      }
      case "%YAML": {
        if (this.yaml.explicit = true, r.length !== 1)
          return n(0, "%YAML directive should contain exactly one part"), false;
        const [s] = r;
        if (s === "1.1" || s === "1.2")
          return this.yaml.version = s, true;
        {
          const o = /^\d+\.\d+$/.test(s);
          return n(6, `Unsupported YAML version ${s}`, o), false;
        }
      }
      default:
        return n(0, `Unknown directive ${i}`, true), false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(t, n) {
    if (t === "!")
      return "!";
    if (t[0] !== "!")
      return n(`Not a valid tag: ${t}`), null;
    if (t[1] === "<") {
      const o = t.slice(2, -1);
      return o === "!" || o === "!!" ? (n(`Verbatim tags aren't resolved, so ${t} is invalid.`), null) : (t[t.length - 1] !== ">" && n("Verbatim tags must end with a >"), o);
    }
    const [, r, i] = t.match(/^(.*!)([^!]*)$/s);
    i || n(`The ${t} tag has no suffix`);
    const s = this.tags[r];
    if (s)
      try {
        return s + decodeURIComponent(i);
      } catch (o) {
        return n(String(o)), null;
      }
    return r === "!" ? t : (n(`Could not resolve tag: ${t}`), null);
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(t) {
    for (const [n, r] of Object.entries(this.tags))
      if (t.startsWith(r))
        return n + X7(t.substring(r.length));
    return t[0] === "!" ? t : `!<${t}>`;
  }
  toString(t) {
    const n = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [], r = Object.entries(this.tags);
    let i;
    if (t && r.length > 0 && ot(t.contents)) {
      const s = {};
      ai(t.contents, (o, l) => {
        ot(l) && l.tag && (s[l.tag] = true);
      }), i = Object.keys(s);
    } else
      i = [];
    for (const [s, o] of r)
      s === "!!" && o === "tag:yaml.org,2002:" || (!t || i.some((l) => l.startsWith(o))) && n.push(`%TAG ${s} ${o}`);
    return n.join(`
`);
  }
};
St.defaultYaml = { explicit: false, version: "1.2" };
St.defaultTags = { "!!": "tag:yaml.org,2002:" };
function xd(e10) {
  if (/[\x00-\x19\s,[\]{}]/.test(e10)) {
    const n = `Anchor must not contain whitespace or control characters: ${JSON.stringify(e10)}`;
    throw new Error(n);
  }
  return true;
}
function wd(e10) {
  const t = /* @__PURE__ */ new Set();
  return ai(e10, {
    Value(n, r) {
      r.anchor && t.add(r.anchor);
    }
  }), t;
}
function vd(e10, t) {
  for (let n = 1; ; ++n) {
    const r = `${e10}${n}`;
    if (!t.has(r))
      return r;
  }
}
function Y7(e10, t) {
  const n = [], r = /* @__PURE__ */ new Map();
  let i = null;
  return {
    onAnchor: (s) => {
      n.push(s), i ?? (i = wd(e10));
      const o = vd(t, i);
      return i.add(o), o;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const s of n) {
        const o = r.get(s);
        if (typeof o == "object" && o.anchor && (We(o.node) || ut(o.node)))
          o.node.anchor = o.anchor;
        else {
          const l = new Error("Failed to resolve repeated object (this should not happen)");
          throw l.source = s, l;
        }
      }
    },
    sourceObjects: r
  };
}
function qr(e10, t, n, r) {
  if (r && typeof r == "object")
    if (Array.isArray(r))
      for (let i = 0, s = r.length; i < s; ++i) {
        const o = r[i], l = qr(e10, r, String(i), o);
        l === void 0 ? delete r[i] : l !== o && (r[i] = l);
      }
    else if (r instanceof Map)
      for (const i of Array.from(r.keys())) {
        const s = r.get(i), o = qr(e10, r, i, s);
        o === void 0 ? r.delete(i) : o !== s && r.set(i, o);
      }
    else if (r instanceof Set)
      for (const i of Array.from(r)) {
        const s = qr(e10, r, i, i);
        s === void 0 ? r.delete(i) : s !== i && (r.delete(i), r.add(s));
      }
    else
      for (const [i, s] of Object.entries(r)) {
        const o = qr(e10, r, i, s);
        o === void 0 ? delete r[i] : o !== s && (r[i] = o);
      }
  return e10.call(t, n, r);
}
function Kt(e10, t, n) {
  if (Array.isArray(e10))
    return e10.map((r, i) => Kt(r, String(i), n));
  if (e10 && typeof e10.toJSON == "function") {
    if (!n || !yd(e10))
      return e10.toJSON(t, n);
    const r = { aliasCount: 0, count: 1, res: void 0 };
    n.anchors.set(e10, r), n.onCreate = (s) => {
      r.res = s, delete n.onCreate;
    };
    const i = e10.toJSON(t, n);
    return n.onCreate && n.onCreate(i), i;
  }
  return typeof e10 == "bigint" && !(n == null ? void 0 : n.keep) ? Number(e10) : e10;
}
var Ua = class {
  constructor(t) {
    Object.defineProperty(this, Yt, { value: t });
  }
  /** Create a copy of this node.  */
  clone() {
    const t = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return this.range && (t.range = this.range.slice()), t;
  }
  /** A plain JavaScript representation of this node. */
  toJS(t, { mapAsMap: n, maxAliasCount: r, onAnchor: i, reviver: s } = {}) {
    if (!j0(t))
      throw new TypeError("A document argument is required");
    const o = {
      anchors: /* @__PURE__ */ new Map(),
      doc: t,
      keep: true,
      mapAsMap: n === true,
      mapKeyWarned: false,
      maxAliasCount: typeof r == "number" ? r : 100
    }, l = Kt(this, "", o);
    if (typeof i == "function")
      for (const { count: f, res: h2 } of o.anchors.values())
        i(h2, f);
    return typeof s == "function" ? qr(s, { "": l }, "", l) : l;
  }
};
var Va = class extends Ua {
  constructor(t) {
    super(ja), this.source = t, Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(t, n) {
    let r;
    (n == null ? void 0 : n.aliasResolveCache) ? r = n.aliasResolveCache : (r = [], ai(t, {
      Node: (s, o) => {
        (Ar(o) || yd(o)) && r.push(o);
      }
    }), n && (n.aliasResolveCache = r));
    let i;
    for (const s of r) {
      if (s === this)
        break;
      s.anchor === this.source && (i = s);
    }
    return i;
  }
  toJSON(t, n) {
    if (!n)
      return { source: this.source };
    const { anchors: r, doc: i, maxAliasCount: s } = n, o = this.resolve(i, n);
    if (!o) {
      const f = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(f);
    }
    let l = r.get(o);
    if (l || (Kt(o, null, n), l = r.get(o)), !l || l.res === void 0) {
      const f = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(f);
    }
    if (s >= 0 && (l.count += 1, l.aliasCount === 0 && (l.aliasCount = Zs(i, o, r)), l.count * l.aliasCount > s)) {
      const f = "Excessive alias count indicates a resource exhaustion attack";
      throw new ReferenceError(f);
    }
    return l.res;
  }
  toString(t, n, r) {
    const i = `*${this.source}`;
    if (t) {
      if (xd(this.source), t.options.verifyAliasOrder && !t.anchors.has(this.source)) {
        const s = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(s);
      }
      if (t.implicitKey)
        return `${i} `;
    }
    return i;
  }
};
function Zs(e10, t, n) {
  if (Ar(t)) {
    const r = t.resolve(e10), i = n && r && n.get(r);
    return i ? i.count * i.aliasCount : 0;
  } else if (ut(t)) {
    let r = 0;
    for (const i of t.items) {
      const s = Zs(e10, i, n);
      s > r && (r = s);
    }
    return r;
  } else if (at(t)) {
    const r = Zs(e10, t.key, n), i = Zs(e10, t.value, n);
    return Math.max(r, i);
  }
  return 1;
}
var kd = (e10) => !e10 || typeof e10 != "function" && typeof e10 != "object";
var Se = class extends Ua {
  constructor(t) {
    super(mn), this.value = t;
  }
  toJSON(t, n) {
    return (n == null ? void 0 : n.keep) ? this.value : Kt(this.value, t, n);
  }
  toString() {
    return String(this.value);
  }
};
Se.BLOCK_FOLDED = "BLOCK_FOLDED";
Se.BLOCK_LITERAL = "BLOCK_LITERAL";
Se.PLAIN = "PLAIN";
Se.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Se.QUOTE_SINGLE = "QUOTE_SINGLE";
var Z7 = "tag:yaml.org,2002:";
function J7(e10, t, n) {
  if (t) {
    const r = n.filter((s) => s.tag === t), i = r.find((s) => !s.format) ?? r[0];
    if (!i)
      throw new Error(`Tag ${t} not found`);
    return i;
  }
  return n.find((r) => {
    var _a2;
    return ((_a2 = r.identify) == null ? void 0 : _a2.call(r, e10)) && !r.format;
  });
}
function Gi(e10, t, n) {
  var _a2, _b2, _c;
  if (j0(e10) && (e10 = e10.contents), ot(e10))
    return e10;
  if (at(e10)) {
    const b = (_b2 = (_a2 = n.schema[er]).createNode) == null ? void 0 : _b2.call(_a2, n.schema, null, n);
    return b.items.push(e10), b;
  }
  (e10 instanceof String || e10 instanceof Number || e10 instanceof Boolean || typeof BigInt < "u" && e10 instanceof BigInt) && (e10 = e10.valueOf());
  const { aliasDuplicateObjects: r, onAnchor: i, onTagObj: s, schema: o, sourceObjects: l } = n;
  let f;
  if (r && e10 && typeof e10 == "object") {
    if (f = l.get(e10), f)
      return f.anchor ?? (f.anchor = i(e10)), new Va(f.anchor);
    f = { anchor: null, node: null }, l.set(e10, f);
  }
  (t == null ? void 0 : t.startsWith("!!")) && (t = Z7 + t.slice(2));
  let h2 = J7(e10, t, o.tags);
  if (!h2) {
    if (e10 && typeof e10.toJSON == "function" && (e10 = e10.toJSON()), !e10 || typeof e10 != "object") {
      const b = new Se(e10);
      return f && (f.node = b), b;
    }
    h2 = e10 instanceof Map ? o[er] : Symbol.iterator in Object(e10) ? o[oi] : o[er];
  }
  s && (s(h2), delete n.onTagObj);
  const p = (h2 == null ? void 0 : h2.createNode) ? h2.createNode(n.schema, e10, n) : typeof ((_c = h2 == null ? void 0 : h2.nodeClass) == null ? void 0 : _c.from) == "function" ? h2.nodeClass.from(n.schema, e10, n) : new Se(e10);
  return t ? p.tag = t : h2.default || (p.tag = h2.tag), f && (f.node = p), p;
}
function k0(e10, t, n) {
  let r = n;
  for (let i = t.length - 1; i >= 0; --i) {
    const s = t[i];
    if (typeof s == "number" && Number.isInteger(s) && s >= 0) {
      const o = [];
      o[s] = r, r = o;
    } else
      r = /* @__PURE__ */ new Map([[s, r]]);
  }
  return Gi(r, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: e10,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var Ti = (e10) => e10 == null || typeof e10 == "object" && !!e10[Symbol.iterator]().next().done;
var _d = class extends Ua {
  constructor(t, n) {
    super(t), Object.defineProperty(this, "schema", {
      value: n,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(t) {
    const n = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return t && (n.schema = t), n.items = n.items.map((r) => ot(r) || at(r) ? r.clone(t) : r), this.range && (n.range = this.range.slice()), n;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(t, n) {
    if (Ti(t))
      this.add(n);
    else {
      const [r, ...i] = t, s = this.get(r, true);
      if (ut(s))
        s.addIn(i, n);
      else if (s === void 0 && this.schema)
        this.set(r, k0(this.schema, i, n));
      else
        throw new Error(`Expected YAML collection at ${r}. Remaining path: ${i}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(t) {
    const [n, ...r] = t;
    if (r.length === 0)
      return this.delete(n);
    const i = this.get(n, true);
    if (ut(i))
      return i.deleteIn(r);
    throw new Error(`Expected YAML collection at ${n}. Remaining path: ${r}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(t, n) {
    const [r, ...i] = t, s = this.get(r, true);
    return i.length === 0 ? !n && We(s) ? s.value : s : ut(s) ? s.getIn(i, n) : void 0;
  }
  hasAllNullValues(t) {
    return this.items.every((n) => {
      if (!at(n))
        return false;
      const r = n.value;
      return r == null || t && We(r) && r.value == null && !r.commentBefore && !r.comment && !r.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(t) {
    const [n, ...r] = t;
    if (r.length === 0)
      return this.has(n);
    const i = this.get(n, true);
    return ut(i) ? i.hasIn(r) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(t, n) {
    const [r, ...i] = t;
    if (i.length === 0)
      this.set(r, n);
    else {
      const s = this.get(r, true);
      if (ut(s))
        s.setIn(i, n);
      else if (s === void 0 && this.schema)
        this.set(r, k0(this.schema, i, n));
      else
        throw new Error(`Expected YAML collection at ${r}. Remaining path: ${i}`);
    }
  }
};
var Q7 = (e10) => e10.replace(/^(?!$)(?: $)?/gm, "#");
function Fn(e10, t) {
  return /^\n+$/.test(e10) ? e10.substring(1) : t ? e10.replace(/^(?! *$)/gm, t) : e10;
}
var dr = (e10, t, n) => e10.endsWith(`
`) ? Fn(n, t) : n.includes(`
`) ? `
` + Fn(n, t) : (e10.endsWith(" ") ? "" : " ") + n;
var Sd = "flow";
var Wo = "block";
var Js = "quoted";
function U0(e10, t, n = "flow", { indentAtStart: r, lineWidth: i = 80, minContentWidth: s = 20, onFold: o, onOverflow: l } = {}) {
  if (!i || i < 0)
    return e10;
  i < s && (s = 0);
  const f = Math.max(1 + s, 1 + i - t.length);
  if (e10.length <= f)
    return e10;
  const h2 = [], p = {};
  let b = i - t.length;
  typeof r == "number" && (r > i - Math.max(2, s) ? h2.push(0) : b = i - r);
  let v, k, w = false, A = -1, T = -1, D = -1;
  n === Wo && (A = Pf(e10, A, t.length), A !== -1 && (b = A + f));
  for (let O; O = e10[A += 1]; ) {
    if (n === Js && O === "\\") {
      switch (T = A, e10[A + 1]) {
        case "x":
          A += 3;
          break;
        case "u":
          A += 5;
          break;
        case "U":
          A += 9;
          break;
        default:
          A += 1;
      }
      D = A;
    }
    if (O === `
`)
      n === Wo && (A = Pf(e10, A, t.length)), b = A + t.length + f, v = void 0;
    else {
      if (O === " " && k && k !== " " && k !== `
` && k !== "	") {
        const q = e10[A + 1];
        q && q !== " " && q !== `
` && q !== "	" && (v = A);
      }
      if (A >= b)
        if (v)
          h2.push(v), b = v + f, v = void 0;
        else if (n === Js) {
          for (; k === " " || k === "	"; )
            k = O, O = e10[A += 1], w = true;
          const q = A > D + 1 ? A - 2 : T - 1;
          if (p[q])
            return e10;
          h2.push(q), p[q] = true, b = q + f, v = void 0;
        } else
          w = true;
    }
    k = O;
  }
  if (w && l && l(), h2.length === 0)
    return e10;
  o && o();
  let N = e10.slice(0, h2[0]);
  for (let O = 0; O < h2.length; ++O) {
    const q = h2[O], z = h2[O + 1] || e10.length;
    q === 0 ? N = `
${t}${e10.slice(0, z)}` : (n === Js && p[q] && (N += `${e10[q]}\\`), N += `
${t}${e10.slice(q + 1, z)}`);
  }
  return N;
}
function Pf(e10, t, n) {
  let r = t, i = t + 1, s = e10[i];
  for (; s === " " || s === "	"; )
    if (t < i + n)
      s = e10[++t];
    else {
      do
        s = e10[++t];
      while (s && s !== `
`);
      r = t, i = t + 1, s = e10[i];
    }
  return r;
}
var V0 = (e10, t) => ({
  indentAtStart: t ? e10.indent.length : e10.indentAtStart,
  lineWidth: e10.options.lineWidth,
  minContentWidth: e10.options.minContentWidth
});
var G0 = (e10) => /^(%|---|\.\.\.)/m.test(e10);
function eb(e10, t, n) {
  if (!t || t < 0)
    return false;
  const r = t - n, i = e10.length;
  if (i <= r)
    return false;
  for (let s = 0, o = 0; s < i; ++s)
    if (e10[s] === `
`) {
      if (s - o > r)
        return true;
      if (o = s + 1, i - o <= r)
        return false;
    }
  return true;
}
function zi(e10, t) {
  const n = JSON.stringify(e10);
  if (t.options.doubleQuotedAsJSON)
    return n;
  const { implicitKey: r } = t, i = t.options.doubleQuotedMinMultiLineLength, s = t.indent || (G0(e10) ? "  " : "");
  let o = "", l = 0;
  for (let f = 0, h2 = n[f]; h2; h2 = n[++f])
    if (h2 === " " && n[f + 1] === "\\" && n[f + 2] === "n" && (o += n.slice(l, f) + "\\ ", f += 1, l = f, h2 = "\\"), h2 === "\\")
      switch (n[f + 1]) {
        case "u":
          {
            o += n.slice(l, f);
            const p = n.substr(f + 2, 4);
            switch (p) {
              case "0000":
                o += "\\0";
                break;
              case "0007":
                o += "\\a";
                break;
              case "000b":
                o += "\\v";
                break;
              case "001b":
                o += "\\e";
                break;
              case "0085":
                o += "\\N";
                break;
              case "00a0":
                o += "\\_";
                break;
              case "2028":
                o += "\\L";
                break;
              case "2029":
                o += "\\P";
                break;
              default:
                p.substr(0, 2) === "00" ? o += "\\x" + p.substr(2) : o += n.substr(f, 6);
            }
            f += 5, l = f + 1;
          }
          break;
        case "n":
          if (r || n[f + 2] === '"' || n.length < i)
            f += 1;
          else {
            for (o += n.slice(l, f) + `

`; n[f + 2] === "\\" && n[f + 3] === "n" && n[f + 4] !== '"'; )
              o += `
`, f += 2;
            o += s, n[f + 2] === " " && (o += "\\"), f += 1, l = f + 1;
          }
          break;
        default:
          f += 1;
      }
  return o = l ? o + n.slice(l) : n, r ? o : U0(o, s, Js, V0(t, false));
}
function Ko(e10, t) {
  if (t.options.singleQuote === false || t.implicitKey && e10.includes(`
`) || /[ \t]\n|\n[ \t]/.test(e10))
    return zi(e10, t);
  const n = t.indent || (G0(e10) ? "  " : ""), r = "'" + e10.replace(/'/g, "''").replace(/\n+/g, `$&
${n}`) + "'";
  return t.implicitKey ? r : U0(r, n, Sd, V0(t, false));
}
function Rr(e10, t) {
  const { singleQuote: n } = t.options;
  let r;
  if (n === false)
    r = zi;
  else {
    const i = e10.includes('"'), s = e10.includes("'");
    i && !s ? r = Ko : s && !i ? r = zi : r = n ? Ko : zi;
  }
  return r(e10, t);
}
var Xo;
try {
  Xo = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
} catch {
  Xo = /\n+(?!\n|$)/g;
}
function Qs({ comment: e10, type: t, value: n }, r, i, s) {
  const { blockQuote: o, commentString: l, lineWidth: f } = r.options;
  if (!o || /\n[\t ]+$/.test(n) || /^\s*$/.test(n))
    return Rr(n, r);
  const h2 = r.indent || (r.forceBlockIndent || G0(n) ? "  " : ""), p = o === "literal" ? true : o === "folded" || t === Se.BLOCK_FOLDED ? false : t === Se.BLOCK_LITERAL ? true : !eb(n, f, h2.length);
  if (!n)
    return p ? `|
` : `>
`;
  let b, v;
  for (v = n.length; v > 0; --v) {
    const z = n[v - 1];
    if (z !== `
` && z !== "	" && z !== " ")
      break;
  }
  let k = n.substring(v);
  const w = k.indexOf(`
`);
  w === -1 ? b = "-" : n === k || w !== k.length - 1 ? (b = "+", s && s()) : b = "", k && (n = n.slice(0, -k.length), k[k.length - 1] === `
` && (k = k.slice(0, -1)), k = k.replace(Xo, `$&${h2}`));
  let A = false, T, D = -1;
  for (T = 0; T < n.length; ++T) {
    const z = n[T];
    if (z === " ")
      A = true;
    else if (z === `
`)
      D = T;
    else
      break;
  }
  let N = n.substring(0, D < T ? D + 1 : T);
  N && (n = n.substring(N.length), N = N.replace(/\n+/g, `$&${h2}`));
  let q = (A ? h2 ? "2" : "1" : "") + b;
  if (e10 && (q += " " + l(e10.replace(/ ?[\r\n]+/g, " ")), i && i()), !p) {
    const z = n.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${h2}`);
    let R = false;
    const J = V0(r, true);
    o !== "folded" && t !== Se.BLOCK_FOLDED && (J.onOverflow = () => {
      R = true;
    });
    const K = U0(`${N}${z}${k}`, h2, Wo, J);
    if (!R)
      return `>${q}
${h2}${K}`;
  }
  return n = n.replace(/\n+/g, `$&${h2}`), `|${q}
${h2}${N}${n}${k}`;
}
function tb(e10, t, n, r) {
  const { type: i, value: s } = e10, { actualString: o, implicitKey: l, indent: f, indentStep: h2, inFlow: p } = t;
  if (l && s.includes(`
`) || p && /[[\]{},]/.test(s))
    return Rr(s, t);
  if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(s))
    return l || p || !s.includes(`
`) ? Rr(s, t) : Qs(e10, t, n, r);
  if (!l && !p && i !== Se.PLAIN && s.includes(`
`))
    return Qs(e10, t, n, r);
  if (G0(s)) {
    if (f === "")
      return t.forceBlockIndent = true, Qs(e10, t, n, r);
    if (l && f === h2)
      return Rr(s, t);
  }
  const b = s.replace(/\n+/g, `$&
${f}`);
  if (o) {
    const v = (A) => {
      var _a2;
      return A.default && A.tag !== "tag:yaml.org,2002:str" && ((_a2 = A.test) == null ? void 0 : _a2.test(b));
    }, { compat: k, tags: w } = t.doc.schema;
    if (w.some(v) || (k == null ? void 0 : k.some(v)))
      return Rr(s, t);
  }
  return l ? b : U0(b, f, Sd, V0(t, false));
}
function Ga(e10, t, n, r) {
  const { implicitKey: i, inFlow: s } = t, o = typeof e10.value == "string" ? e10 : Object.assign({}, e10, { value: String(e10.value) });
  let { type: l } = e10;
  l !== Se.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(o.value) && (l = Se.QUOTE_DOUBLE);
  const f = (p) => {
    switch (p) {
      case Se.BLOCK_FOLDED:
      case Se.BLOCK_LITERAL:
        return i || s ? Rr(o.value, t) : Qs(o, t, n, r);
      case Se.QUOTE_DOUBLE:
        return zi(o.value, t);
      case Se.QUOTE_SINGLE:
        return Ko(o.value, t);
      case Se.PLAIN:
        return tb(o, t, n, r);
      default:
        return null;
    }
  };
  let h2 = f(l);
  if (h2 === null) {
    const { defaultKeyType: p, defaultStringType: b } = t.options, v = i && p || b;
    if (h2 = f(v), h2 === null)
      throw new Error(`Unsupported default string type ${v}`);
  }
  return h2;
}
function Ad(e10, t) {
  const n = Object.assign({
    blockQuote: true,
    commentString: Q7,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, e10.schema.toStringOptions, t);
  let r;
  switch (n.collectionStyle) {
    case "block":
      r = false;
      break;
    case "flow":
      r = true;
      break;
    default:
      r = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc: e10,
    flowCollectionPadding: n.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof n.indent == "number" ? " ".repeat(n.indent) : "  ",
    inFlow: r,
    options: n
  };
}
function nb(e10, t) {
  var _a2;
  if (t.tag) {
    const i = e10.filter((s) => s.tag === t.tag);
    if (i.length > 0)
      return i.find((s) => s.format === t.format) ?? i[0];
  }
  let n, r;
  if (We(t)) {
    r = t.value;
    let i = e10.filter((s) => {
      var _a3;
      return (_a3 = s.identify) == null ? void 0 : _a3.call(s, r);
    });
    if (i.length > 1) {
      const s = i.filter((o) => o.test);
      s.length > 0 && (i = s);
    }
    n = i.find((s) => s.format === t.format) ?? i.find((s) => !s.format);
  } else
    r = t, n = e10.find((i) => i.nodeClass && r instanceof i.nodeClass);
  if (!n) {
    const i = ((_a2 = r == null ? void 0 : r.constructor) == null ? void 0 : _a2.name) ?? (r === null ? "null" : typeof r);
    throw new Error(`Tag not resolved for ${i} value`);
  }
  return n;
}
function rb(e10, t, { anchors: n, doc: r }) {
  if (!r.directives)
    return "";
  const i = [], s = (We(e10) || ut(e10)) && e10.anchor;
  s && xd(s) && (n.add(s), i.push(`&${s}`));
  const o = e10.tag ?? (t.default ? null : t.tag);
  return o && i.push(r.directives.tagString(o)), i.join(" ");
}
function Zr(e10, t, n, r) {
  var _a2;
  if (at(e10))
    return e10.toString(t, n, r);
  if (Ar(e10)) {
    if (t.doc.directives)
      return e10.toString(t);
    if ((_a2 = t.resolvedAliases) == null ? void 0 : _a2.has(e10))
      throw new TypeError("Cannot stringify circular structure without alias nodes");
    t.resolvedAliases ? t.resolvedAliases.add(e10) : t.resolvedAliases = /* @__PURE__ */ new Set([e10]), e10 = e10.resolve(t.doc);
  }
  let i;
  const s = ot(e10) ? e10 : t.doc.createNode(e10, { onTagObj: (f) => i = f });
  i ?? (i = nb(t.doc.schema.tags, s));
  const o = rb(s, i, t);
  o.length > 0 && (t.indentAtStart = (t.indentAtStart ?? 0) + o.length + 1);
  const l = typeof i.stringify == "function" ? i.stringify(s, t, n, r) : We(s) ? Ga(s, t, n, r) : s.toString(t, n, r);
  return o ? We(s) || l[0] === "{" || l[0] === "[" ? `${o} ${l}` : `${o}
${t.indent}${l}` : l;
}
function ib({ key: e10, value: t }, n, r, i) {
  const { allNullValues: s, doc: o, indent: l, indentStep: f, options: { commentString: h2, indentSeq: p, simpleKeys: b } } = n;
  let v = ot(e10) && e10.comment || null;
  if (b) {
    if (v)
      throw new Error("With simple keys, key nodes cannot have comments");
    if (ut(e10) || !ot(e10) && typeof e10 == "object") {
      const J = "With simple keys, collection cannot be used as a key value";
      throw new Error(J);
    }
  }
  let k = !b && (!e10 || v && t == null && !n.inFlow || ut(e10) || (We(e10) ? e10.type === Se.BLOCK_FOLDED || e10.type === Se.BLOCK_LITERAL : typeof e10 == "object"));
  n = Object.assign({}, n, {
    allNullValues: false,
    implicitKey: !k && (b || !s),
    indent: l + f
  });
  let w = false, A = false, T = Zr(e10, n, () => w = true, () => A = true);
  if (!k && !n.inFlow && T.length > 1024) {
    if (b)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    k = true;
  }
  if (n.inFlow) {
    if (s || t == null)
      return w && r && r(), T === "" ? "?" : k ? `? ${T}` : T;
  } else if (s && !b || t == null && k)
    return T = `? ${T}`, v && !w ? T += dr(T, n.indent, h2(v)) : A && i && i(), T;
  w && (v = null), k ? (v && (T += dr(T, n.indent, h2(v))), T = `? ${T}
${l}:`) : (T = `${T}:`, v && (T += dr(T, n.indent, h2(v))));
  let D, N, O;
  ot(t) ? (D = !!t.spaceBefore, N = t.commentBefore, O = t.comment) : (D = false, N = null, O = null, t && typeof t == "object" && (t = o.createNode(t))), n.implicitKey = false, !k && !v && We(t) && (n.indentAtStart = T.length + 1), A = false, !p && f.length >= 2 && !n.inFlow && !k && us(t) && !t.flow && !t.tag && !t.anchor && (n.indent = n.indent.substring(2));
  let q = false;
  const z = Zr(t, n, () => q = true, () => A = true);
  let R = " ";
  if (v || D || N) {
    if (R = D ? `
` : "", N) {
      const J = h2(N);
      R += `
${Fn(J, n.indent)}`;
    }
    z === "" && !n.inFlow ? R === `
` && (R = `

`) : R += `
${n.indent}`;
  } else if (!k && ut(t)) {
    const J = z[0], K = z.indexOf(`
`), V = K !== -1, te = n.inFlow ?? t.flow ?? t.items.length === 0;
    if (V || !te) {
      let Z = false;
      if (V && (J === "&" || J === "!")) {
        let se = z.indexOf(" ");
        J === "&" && se !== -1 && se < K && z[se + 1] === "!" && (se = z.indexOf(" ", se + 1)), (se === -1 || K < se) && (Z = true);
      }
      Z || (R = `
${n.indent}`);
    }
  } else (z === "" || z[0] === `
`) && (R = "");
  return T += R + z, n.inFlow ? q && r && r() : O && !q ? T += dr(T, n.indent, h2(O)) : A && i && i(), T;
}
function Ed(e10, t) {
  (e10 === "debug" || e10 === "warn") && console.warn(t);
}
var Ls = "<<";
var zn = {
  identify: (e10) => e10 === Ls || typeof e10 == "symbol" && e10.description === Ls,
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: () => Object.assign(new Se(Symbol(Ls)), {
    addToJSMap: Cd
  }),
  stringify: () => Ls
};
var sb = (e10, t) => (zn.identify(t) || We(t) && (!t.type || t.type === Se.PLAIN) && zn.identify(t.value)) && (e10 == null ? void 0 : e10.doc.schema.tags.some((n) => n.tag === zn.tag && n.default));
function Cd(e10, t, n) {
  if (n = e10 && Ar(n) ? n.resolve(e10.doc) : n, us(n))
    for (const r of n.items)
      ao(e10, t, r);
  else if (Array.isArray(n))
    for (const r of n)
      ao(e10, t, r);
  else
    ao(e10, t, n);
}
function ao(e10, t, n) {
  const r = e10 && Ar(n) ? n.resolve(e10.doc) : n;
  if (!ss(r))
    throw new Error("Merge sources must be maps or map aliases");
  const i = r.toJSON(null, e10, Map);
  for (const [s, o] of i)
    t instanceof Map ? t.has(s) || t.set(s, o) : t instanceof Set ? t.add(s) : Object.prototype.hasOwnProperty.call(t, s) || Object.defineProperty(t, s, {
      value: o,
      writable: true,
      enumerable: true,
      configurable: true
    });
  return t;
}
function Td(e10, t, { key: n, value: r }) {
  if (ot(n) && n.addToJSMap)
    n.addToJSMap(e10, t, r);
  else if (sb(e10, n))
    Cd(e10, t, r);
  else {
    const i = Kt(n, "", e10);
    if (t instanceof Map)
      t.set(i, Kt(r, i, e10));
    else if (t instanceof Set)
      t.add(i);
    else {
      const s = ub(n, i, e10), o = Kt(r, s, e10);
      s in t ? Object.defineProperty(t, s, {
        value: o,
        writable: true,
        enumerable: true,
        configurable: true
      }) : t[s] = o;
    }
  }
  return t;
}
function ub(e10, t, n) {
  if (t === null)
    return "";
  if (typeof t != "object")
    return String(t);
  if (ot(e10) && (n == null ? void 0 : n.doc)) {
    const r = Ad(n.doc, {});
    r.anchors = /* @__PURE__ */ new Set();
    for (const s of n.anchors.keys())
      r.anchors.add(s.anchor);
    r.inFlow = true, r.inStringifyKey = true;
    const i = e10.toString(r);
    if (!n.mapKeyWarned) {
      let s = JSON.stringify(i);
      s.length > 40 && (s = s.substring(0, 36) + '..."'), Ed(n.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${s}. Set mapAsMap: true to use object keys.`), n.mapKeyWarned = true;
    }
    return i;
  }
  return JSON.stringify(t);
}
function Wa(e10, t, n) {
  const r = Gi(e10, void 0, n), i = Gi(t, void 0, n);
  return new At(r, i);
}
var At = class _At {
  constructor(t, n = null) {
    Object.defineProperty(this, Yt, { value: bd }), this.key = t, this.value = n;
  }
  clone(t) {
    let { key: n, value: r } = this;
    return ot(n) && (n = n.clone(t)), ot(r) && (r = r.clone(t)), new _At(n, r);
  }
  toJSON(t, n) {
    const r = (n == null ? void 0 : n.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    return Td(n, r, this);
  }
  toString(t, n, r) {
    return (t == null ? void 0 : t.doc) ? ib(this, t, n, r) : JSON.stringify(this);
  }
};
function Dd(e10, t, n) {
  return (t.inFlow ?? e10.flow ? ab : ob)(e10, t, n);
}
function ob({ comment: e10, items: t }, n, { blockItemPrefix: r, flowChars: i, itemIndent: s, onChompKeep: o, onComment: l }) {
  const { indent: f, options: { commentString: h2 } } = n, p = Object.assign({}, n, { indent: s, type: null });
  let b = false;
  const v = [];
  for (let w = 0; w < t.length; ++w) {
    const A = t[w];
    let T = null;
    if (ot(A))
      !b && A.spaceBefore && v.push(""), _0(n, v, A.commentBefore, b), A.comment && (T = A.comment);
    else if (at(A)) {
      const N = ot(A.key) ? A.key : null;
      N && (!b && N.spaceBefore && v.push(""), _0(n, v, N.commentBefore, b));
    }
    b = false;
    let D = Zr(A, p, () => T = null, () => b = true);
    T && (D += dr(D, s, h2(T))), b && T && (b = false), v.push(r + D);
  }
  let k;
  if (v.length === 0)
    k = i.start + i.end;
  else {
    k = v[0];
    for (let w = 1; w < v.length; ++w) {
      const A = v[w];
      k += A ? `
${f}${A}` : `
`;
    }
  }
  return e10 ? (k += `
` + Fn(h2(e10), f), l && l()) : b && o && o(), k;
}
function ab({ items: e10 }, t, { flowChars: n, itemIndent: r }) {
  const { indent: i, indentStep: s, flowCollectionPadding: o, options: { commentString: l } } = t;
  r += s;
  const f = Object.assign({}, t, {
    indent: r,
    inFlow: true,
    type: null
  });
  let h2 = false, p = 0;
  const b = [];
  for (let w = 0; w < e10.length; ++w) {
    const A = e10[w];
    let T = null;
    if (ot(A))
      A.spaceBefore && b.push(""), _0(t, b, A.commentBefore, false), A.comment && (T = A.comment);
    else if (at(A)) {
      const N = ot(A.key) ? A.key : null;
      N && (N.spaceBefore && b.push(""), _0(t, b, N.commentBefore, false), N.comment && (h2 = true));
      const O = ot(A.value) ? A.value : null;
      O ? (O.comment && (T = O.comment), O.commentBefore && (h2 = true)) : A.value == null && (N == null ? void 0 : N.comment) && (T = N.comment);
    }
    T && (h2 = true);
    let D = Zr(A, f, () => T = null);
    w < e10.length - 1 && (D += ","), T && (D += dr(D, r, l(T))), !h2 && (b.length > p || D.includes(`
`)) && (h2 = true), b.push(D), p = b.length;
  }
  const { start: v, end: k } = n;
  if (b.length === 0)
    return v + k;
  if (!h2) {
    const w = b.reduce((A, T) => A + T.length + 2, 2);
    h2 = t.options.lineWidth > 0 && w > t.options.lineWidth;
  }
  if (h2) {
    let w = v;
    for (const A of b)
      w += A ? `
${s}${i}${A}` : `
`;
    return `${w}
${i}${k}`;
  } else
    return `${v}${o}${b.join(" ")}${o}${k}`;
}
function _0({ indent: e10, options: { commentString: t } }, n, r, i) {
  if (r && i && (r = r.replace(/^\n+/, "")), r) {
    const s = Fn(t(r), e10);
    n.push(s.trimStart());
  }
}
function pr(e10, t) {
  const n = We(t) ? t.value : t;
  for (const r of e10)
    if (at(r) && (r.key === t || r.key === n || We(r.key) && r.key.value === n))
      return r;
}
var Wt = class extends _d {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(t) {
    super(er, t), this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(t, n, r) {
    const { keepUndefined: i, replacer: s } = r, o = new this(t), l = (f, h2) => {
      if (typeof s == "function")
        h2 = s.call(n, f, h2);
      else if (Array.isArray(s) && !s.includes(f))
        return;
      (h2 !== void 0 || i) && o.items.push(Wa(f, h2, r));
    };
    if (n instanceof Map)
      for (const [f, h2] of n)
        l(f, h2);
    else if (n && typeof n == "object")
      for (const f of Object.keys(n))
        l(f, n[f]);
    return typeof t.sortMapEntries == "function" && o.items.sort(t.sortMapEntries), o;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(t, n) {
    var _a2;
    let r;
    at(t) ? r = t : !t || typeof t != "object" || !("key" in t) ? r = new At(t, t == null ? void 0 : t.value) : r = new At(t.key, t.value);
    const i = pr(this.items, r.key), s = (_a2 = this.schema) == null ? void 0 : _a2.sortMapEntries;
    if (i) {
      if (!n)
        throw new Error(`Key ${r.key} already set`);
      We(i.value) && kd(r.value) ? i.value.value = r.value : i.value = r.value;
    } else if (s) {
      const o = this.items.findIndex((l) => s(r, l) < 0);
      o === -1 ? this.items.push(r) : this.items.splice(o, 0, r);
    } else
      this.items.push(r);
  }
  delete(t) {
    const n = pr(this.items, t);
    return n ? this.items.splice(this.items.indexOf(n), 1).length > 0 : false;
  }
  get(t, n) {
    var _a2;
    const i = (_a2 = pr(this.items, t)) == null ? void 0 : _a2.value;
    return (!n && We(i) ? i.value : i) ?? void 0;
  }
  has(t) {
    return !!pr(this.items, t);
  }
  set(t, n) {
    this.add(new At(t, n), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(t, n, r) {
    const i = r ? new r() : (n == null ? void 0 : n.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    (n == null ? void 0 : n.onCreate) && n.onCreate(i);
    for (const s of this.items)
      Td(n, i, s);
    return i;
  }
  toString(t, n, r) {
    if (!t)
      return JSON.stringify(this);
    for (const i of this.items)
      if (!at(i))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(i)} instead`);
    return !t.allNullValues && this.hasAllNullValues(false) && (t = Object.assign({}, t, { allNullValues: true })), Dd(this, t, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: t.indent || "",
      onChompKeep: r,
      onComment: n
    });
  }
};
var li = {
  collection: "map",
  default: true,
  nodeClass: Wt,
  tag: "tag:yaml.org,2002:map",
  resolve(e10, t) {
    return ss(e10) || t("Expected a mapping for this tag"), e10;
  },
  createNode: (e10, t, n) => Wt.from(e10, t, n)
};
var wr = class extends _d {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(t) {
    super(oi, t), this.items = [];
  }
  add(t) {
    this.items.push(t);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(t) {
    const n = qs(t);
    return typeof n != "number" ? false : this.items.splice(n, 1).length > 0;
  }
  get(t, n) {
    const r = qs(t);
    if (typeof r != "number")
      return;
    const i = this.items[r];
    return !n && We(i) ? i.value : i;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(t) {
    const n = qs(t);
    return typeof n == "number" && n < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(t, n) {
    const r = qs(t);
    if (typeof r != "number")
      throw new Error(`Expected a valid index, not ${t}.`);
    const i = this.items[r];
    We(i) && kd(n) ? i.value = n : this.items[r] = n;
  }
  toJSON(t, n) {
    const r = [];
    (n == null ? void 0 : n.onCreate) && n.onCreate(r);
    let i = 0;
    for (const s of this.items)
      r.push(Kt(s, String(i++), n));
    return r;
  }
  toString(t, n, r) {
    return t ? Dd(this, t, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (t.indent || "") + "  ",
      onChompKeep: r,
      onComment: n
    }) : JSON.stringify(this);
  }
  static from(t, n, r) {
    const { replacer: i } = r, s = new this(t);
    if (n && Symbol.iterator in Object(n)) {
      let o = 0;
      for (let l of n) {
        if (typeof i == "function") {
          const f = n instanceof Set ? l : String(o++);
          l = i.call(n, f, l);
        }
        s.items.push(Gi(l, void 0, r));
      }
    }
    return s;
  }
};
function qs(e10) {
  let t = We(e10) ? e10.value : e10;
  return t && typeof t == "string" && (t = Number(t)), typeof t == "number" && Number.isInteger(t) && t >= 0 ? t : null;
}
var ci = {
  collection: "seq",
  default: true,
  nodeClass: wr,
  tag: "tag:yaml.org,2002:seq",
  resolve(e10, t) {
    return us(e10) || t("Expected a sequence for this tag"), e10;
  },
  createNode: (e10, t, n) => wr.from(e10, t, n)
};
var W0 = {
  identify: (e10) => typeof e10 == "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (e10) => e10,
  stringify(e10, t, n, r) {
    return t = Object.assign({ actualString: true }, t), Ga(e10, t, n, r);
  }
};
var K0 = {
  identify: (e10) => e10 == null,
  createNode: () => new Se(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Se(null),
  stringify: ({ source: e10 }, t) => typeof e10 == "string" && K0.test.test(e10) ? e10 : t.options.nullStr
};
var Ka = {
  identify: (e10) => typeof e10 == "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (e10) => new Se(e10[0] === "t" || e10[0] === "T"),
  stringify({ source: e10, value: t }, n) {
    if (e10 && Ka.test.test(e10)) {
      const r = e10[0] === "t" || e10[0] === "T";
      if (t === r)
        return e10;
    }
    return t ? n.options.trueStr : n.options.falseStr;
  }
};
function nn({ format: e10, minFractionDigits: t, tag: n, value: r }) {
  if (typeof r == "bigint")
    return String(r);
  const i = typeof r == "number" ? r : Number(r);
  if (!isFinite(i))
    return isNaN(i) ? ".nan" : i < 0 ? "-.inf" : ".inf";
  let s = JSON.stringify(r);
  if (!e10 && t && (!n || n === "tag:yaml.org,2002:float") && /^\d/.test(s)) {
    let o = s.indexOf(".");
    o < 0 && (o = s.length, s += ".");
    let l = t - (s.length - o - 1);
    for (; l-- > 0; )
      s += "0";
  }
  return s;
}
var Md = {
  identify: (e10) => typeof e10 == "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (e10) => e10.slice(-3).toLowerCase() === "nan" ? NaN : e10[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: nn
};
var Nd = {
  identify: (e10) => typeof e10 == "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (e10) => parseFloat(e10),
  stringify(e10) {
    const t = Number(e10.value);
    return isFinite(t) ? t.toExponential() : nn(e10);
  }
};
var Id = {
  identify: (e10) => typeof e10 == "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(e10) {
    const t = new Se(parseFloat(e10)), n = e10.indexOf(".");
    return n !== -1 && e10[e10.length - 1] === "0" && (t.minFractionDigits = e10.length - n - 1), t;
  },
  stringify: nn
};
var X0 = (e10) => typeof e10 == "bigint" || Number.isInteger(e10);
var Xa = (e10, t, n, { intAsBigInt: r }) => r ? BigInt(e10) : parseInt(e10.substring(t), n);
function Fd(e10, t, n) {
  const { value: r } = e10;
  return X0(r) && r >= 0 ? n + r.toString(t) : nn(e10);
}
var Bd = {
  identify: (e10) => X0(e10) && e10 >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (e10, t, n) => Xa(e10, 2, 8, n),
  stringify: (e10) => Fd(e10, 8, "0o")
};
var Od = {
  identify: X0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (e10, t, n) => Xa(e10, 0, 10, n),
  stringify: nn
};
var zd = {
  identify: (e10) => X0(e10) && e10 >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (e10, t, n) => Xa(e10, 2, 16, n),
  stringify: (e10) => Fd(e10, 16, "0x")
};
var lb = [
  li,
  ci,
  W0,
  K0,
  Ka,
  Bd,
  Od,
  zd,
  Md,
  Nd,
  Id
];
function Hf(e10) {
  return typeof e10 == "bigint" || Number.isInteger(e10);
}
var Rs = ({ value: e10 }) => JSON.stringify(e10);
var cb = [
  {
    identify: (e10) => typeof e10 == "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (e10) => e10,
    stringify: Rs
  },
  {
    identify: (e10) => e10 == null,
    createNode: () => new Se(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: Rs
  },
  {
    identify: (e10) => typeof e10 == "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true$|^false$/,
    resolve: (e10) => e10 === "true",
    stringify: Rs
  },
  {
    identify: Hf,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (e10, t, { intAsBigInt: n }) => n ? BigInt(e10) : parseInt(e10, 10),
    stringify: ({ value: e10 }) => Hf(e10) ? e10.toString() : JSON.stringify(e10)
  },
  {
    identify: (e10) => typeof e10 == "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (e10) => parseFloat(e10),
    stringify: Rs
  }
];
var fb = {
  default: true,
  tag: "",
  test: /^/,
  resolve(e10, t) {
    return t(`Unresolved plain scalar ${JSON.stringify(e10)}`), e10;
  }
};
var hb = [li, ci].concat(cb, fb);
var Ya = {
  identify: (e10) => e10 instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(e10, t) {
    if (typeof atob == "function") {
      const n = atob(e10.replace(/[\n\r]/g, "")), r = new Uint8Array(n.length);
      for (let i = 0; i < n.length; ++i)
        r[i] = n.charCodeAt(i);
      return r;
    } else
      return t("This environment does not support reading binary tags; either Buffer or atob is required"), e10;
  },
  stringify({ comment: e10, type: t, value: n }, r, i, s) {
    if (!n)
      return "";
    const o = n;
    let l;
    if (typeof btoa == "function") {
      let f = "";
      for (let h2 = 0; h2 < o.length; ++h2)
        f += String.fromCharCode(o[h2]);
      l = btoa(f);
    } else
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    if (t ?? (t = Se.BLOCK_LITERAL), t !== Se.QUOTE_DOUBLE) {
      const f = Math.max(r.options.lineWidth - r.indent.length, r.options.minContentWidth), h2 = Math.ceil(l.length / f), p = new Array(h2);
      for (let b = 0, v = 0; b < h2; ++b, v += f)
        p[b] = l.substr(v, f);
      l = p.join(t === Se.BLOCK_LITERAL ? `
` : " ");
    }
    return Ga({ comment: e10, type: t, value: l }, r, i, s);
  }
};
function $d(e10, t) {
  if (us(e10))
    for (let n = 0; n < e10.items.length; ++n) {
      let r = e10.items[n];
      if (!at(r)) {
        if (ss(r)) {
          r.items.length > 1 && t("Each pair must have its own sequence indicator");
          const i = r.items[0] || new At(new Se(null));
          if (r.commentBefore && (i.key.commentBefore = i.key.commentBefore ? `${r.commentBefore}
${i.key.commentBefore}` : r.commentBefore), r.comment) {
            const s = i.value ?? i.key;
            s.comment = s.comment ? `${r.comment}
${s.comment}` : r.comment;
          }
          r = i;
        }
        e10.items[n] = at(r) ? r : new At(r);
      }
    }
  else
    t("Expected a sequence for this tag");
  return e10;
}
function Ld(e10, t, n) {
  const { replacer: r } = n, i = new wr(e10);
  i.tag = "tag:yaml.org,2002:pairs";
  let s = 0;
  if (t && Symbol.iterator in Object(t))
    for (let o of t) {
      typeof r == "function" && (o = r.call(t, String(s++), o));
      let l, f;
      if (Array.isArray(o))
        if (o.length === 2)
          l = o[0], f = o[1];
        else
          throw new TypeError(`Expected [key, value] tuple: ${o}`);
      else if (o && o instanceof Object) {
        const h2 = Object.keys(o);
        if (h2.length === 1)
          l = h2[0], f = o[l];
        else
          throw new TypeError(`Expected tuple with one key, not ${h2.length} keys`);
      } else
        l = o;
      i.items.push(Wa(l, f, n));
    }
  return i;
}
var Za = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: $d,
  createNode: Ld
};
var jr = class _jr extends wr {
  constructor() {
    super(), this.add = Wt.prototype.add.bind(this), this.delete = Wt.prototype.delete.bind(this), this.get = Wt.prototype.get.bind(this), this.has = Wt.prototype.has.bind(this), this.set = Wt.prototype.set.bind(this), this.tag = _jr.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(t, n) {
    if (!n)
      return super.toJSON(t);
    const r = /* @__PURE__ */ new Map();
    (n == null ? void 0 : n.onCreate) && n.onCreate(r);
    for (const i of this.items) {
      let s, o;
      if (at(i) ? (s = Kt(i.key, "", n), o = Kt(i.value, s, n)) : s = Kt(i, "", n), r.has(s))
        throw new Error("Ordered maps must not include duplicate keys");
      r.set(s, o);
    }
    return r;
  }
  static from(t, n, r) {
    const i = Ld(t, n, r), s = new this();
    return s.items = i.items, s;
  }
};
jr.tag = "tag:yaml.org,2002:omap";
var Ja = {
  collection: "seq",
  identify: (e10) => e10 instanceof Map,
  nodeClass: jr,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(e10, t) {
    const n = $d(e10, t), r = [];
    for (const { key: i } of n.items)
      We(i) && (r.includes(i.value) ? t(`Ordered maps must not include duplicate keys: ${i.value}`) : r.push(i.value));
    return Object.assign(new jr(), n);
  },
  createNode: (e10, t, n) => jr.from(e10, t, n)
};
function qd({ value: e10, source: t }, n) {
  return t && (e10 ? Rd : Pd).test.test(t) ? t : e10 ? n.options.trueStr : n.options.falseStr;
}
var Rd = {
  identify: (e10) => e10 === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Se(true),
  stringify: qd
};
var Pd = {
  identify: (e10) => e10 === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: () => new Se(false),
  stringify: qd
};
var db = {
  identify: (e10) => typeof e10 == "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (e10) => e10.slice(-3).toLowerCase() === "nan" ? NaN : e10[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: nn
};
var pb = {
  identify: (e10) => typeof e10 == "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (e10) => parseFloat(e10.replace(/_/g, "")),
  stringify(e10) {
    const t = Number(e10.value);
    return isFinite(t) ? t.toExponential() : nn(e10);
  }
};
var mb = {
  identify: (e10) => typeof e10 == "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(e10) {
    const t = new Se(parseFloat(e10.replace(/_/g, ""))), n = e10.indexOf(".");
    if (n !== -1) {
      const r = e10.substring(n + 1).replace(/_/g, "");
      r[r.length - 1] === "0" && (t.minFractionDigits = r.length);
    }
    return t;
  },
  stringify: nn
};
var os = (e10) => typeof e10 == "bigint" || Number.isInteger(e10);
function Y0(e10, t, n, { intAsBigInt: r }) {
  const i = e10[0];
  if ((i === "-" || i === "+") && (t += 1), e10 = e10.substring(t).replace(/_/g, ""), r) {
    switch (n) {
      case 2:
        e10 = `0b${e10}`;
        break;
      case 8:
        e10 = `0o${e10}`;
        break;
      case 16:
        e10 = `0x${e10}`;
        break;
    }
    const o = BigInt(e10);
    return i === "-" ? BigInt(-1) * o : o;
  }
  const s = parseInt(e10, n);
  return i === "-" ? -1 * s : s;
}
function Qa(e10, t, n) {
  const { value: r } = e10;
  if (os(r)) {
    const i = r.toString(t);
    return r < 0 ? "-" + n + i.substr(1) : n + i;
  }
  return nn(e10);
}
var gb = {
  identify: os,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (e10, t, n) => Y0(e10, 2, 2, n),
  stringify: (e10) => Qa(e10, 2, "0b")
};
var bb = {
  identify: os,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (e10, t, n) => Y0(e10, 1, 8, n),
  stringify: (e10) => Qa(e10, 8, "0")
};
var yb = {
  identify: os,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (e10, t, n) => Y0(e10, 0, 10, n),
  stringify: nn
};
var xb = {
  identify: os,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (e10, t, n) => Y0(e10, 2, 16, n),
  stringify: (e10) => Qa(e10, 16, "0x")
};
var Ur = class _Ur extends Wt {
  constructor(t) {
    super(t), this.tag = _Ur.tag;
  }
  add(t) {
    let n;
    at(t) ? n = t : t && typeof t == "object" && "key" in t && "value" in t && t.value === null ? n = new At(t.key, null) : n = new At(t, null), pr(this.items, n.key) || this.items.push(n);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(t, n) {
    const r = pr(this.items, t);
    return !n && at(r) ? We(r.key) ? r.key.value : r.key : r;
  }
  set(t, n) {
    if (typeof n != "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof n}`);
    const r = pr(this.items, t);
    r && !n ? this.items.splice(this.items.indexOf(r), 1) : !r && n && this.items.push(new At(t));
  }
  toJSON(t, n) {
    return super.toJSON(t, n, Set);
  }
  toString(t, n, r) {
    if (!t)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, t, { allNullValues: true }), n, r);
    throw new Error("Set items must all have null values");
  }
  static from(t, n, r) {
    const { replacer: i } = r, s = new this(t);
    if (n && Symbol.iterator in Object(n))
      for (let o of n)
        typeof i == "function" && (o = i.call(n, o, o)), s.items.push(Wa(o, null, r));
    return s;
  }
};
Ur.tag = "tag:yaml.org,2002:set";
var el = {
  collection: "map",
  identify: (e10) => e10 instanceof Set,
  nodeClass: Ur,
  default: false,
  tag: "tag:yaml.org,2002:set",
  createNode: (e10, t, n) => Ur.from(e10, t, n),
  resolve(e10, t) {
    if (ss(e10)) {
      if (e10.hasAllNullValues(true))
        return Object.assign(new Ur(), e10);
      t("Set items must all have null values");
    } else
      t("Expected a mapping for this tag");
    return e10;
  }
};
function tl(e10, t) {
  const n = e10[0], r = n === "-" || n === "+" ? e10.substring(1) : e10, i = (o) => t ? BigInt(o) : Number(o), s = r.replace(/_/g, "").split(":").reduce((o, l) => o * i(60) + i(l), i(0));
  return n === "-" ? i(-1) * s : s;
}
function Hd(e10) {
  let { value: t } = e10, n = (o) => o;
  if (typeof t == "bigint")
    n = (o) => BigInt(o);
  else if (isNaN(t) || !isFinite(t))
    return nn(e10);
  let r = "";
  t < 0 && (r = "-", t *= n(-1));
  const i = n(60), s = [t % i];
  return t < 60 ? s.unshift(0) : (t = (t - s[0]) / i, s.unshift(t % i), t >= 60 && (t = (t - s[0]) / i, s.unshift(t))), r + s.map((o) => String(o).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
var jd = {
  identify: (e10) => typeof e10 == "bigint" || Number.isInteger(e10),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (e10, t, { intAsBigInt: n }) => tl(e10, n),
  stringify: Hd
};
var Ud = {
  identify: (e10) => typeof e10 == "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (e10) => tl(e10, false),
  stringify: Hd
};
var Z0 = {
  identify: (e10) => e10 instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(e10) {
    const t = e10.match(Z0.test);
    if (!t)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, n, r, i, s, o, l] = t.map(Number), f = t[7] ? Number((t[7] + "00").substr(1, 3)) : 0;
    let h2 = Date.UTC(n, r - 1, i, s || 0, o || 0, l || 0, f);
    const p = t[8];
    if (p && p !== "Z") {
      let b = tl(p, false);
      Math.abs(b) < 30 && (b *= 60), h2 -= 6e4 * b;
    }
    return new Date(h2);
  },
  stringify: ({ value: e10 }) => (e10 == null ? void 0 : e10.toISOString().replace(/(T00:00:00)?\.000Z$/, "")) ?? ""
};
var jf = [
  li,
  ci,
  W0,
  K0,
  Rd,
  Pd,
  gb,
  bb,
  yb,
  xb,
  db,
  pb,
  mb,
  Ya,
  zn,
  Ja,
  Za,
  el,
  jd,
  Ud,
  Z0
];
var Uf = /* @__PURE__ */ new Map([
  ["core", lb],
  ["failsafe", [li, ci, W0]],
  ["json", hb],
  ["yaml11", jf],
  ["yaml-1.1", jf]
]);
var Vf = {
  binary: Ya,
  bool: Ka,
  float: Id,
  floatExp: Nd,
  floatNaN: Md,
  floatTime: Ud,
  int: Od,
  intHex: zd,
  intOct: Bd,
  intTime: jd,
  map: li,
  merge: zn,
  null: K0,
  omap: Ja,
  pairs: Za,
  seq: ci,
  set: el,
  timestamp: Z0
};
var wb = {
  "tag:yaml.org,2002:binary": Ya,
  "tag:yaml.org,2002:merge": zn,
  "tag:yaml.org,2002:omap": Ja,
  "tag:yaml.org,2002:pairs": Za,
  "tag:yaml.org,2002:set": el,
  "tag:yaml.org,2002:timestamp": Z0
};
function lo(e10, t, n) {
  const r = Uf.get(t);
  if (r && !e10)
    return n && !r.includes(zn) ? r.concat(zn) : r.slice();
  let i = r;
  if (!i)
    if (Array.isArray(e10))
      i = [];
    else {
      const s = Array.from(Uf.keys()).filter((o) => o !== "yaml11").map((o) => JSON.stringify(o)).join(", ");
      throw new Error(`Unknown schema "${t}"; use one of ${s} or define customTags array`);
    }
  if (Array.isArray(e10))
    for (const s of e10)
      i = i.concat(s);
  else typeof e10 == "function" && (i = e10(i.slice()));
  return n && (i = i.concat(zn)), i.reduce((s, o) => {
    const l = typeof o == "string" ? Vf[o] : o;
    if (!l) {
      const f = JSON.stringify(o), h2 = Object.keys(Vf).map((p) => JSON.stringify(p)).join(", ");
      throw new Error(`Unknown custom tag ${f}; use one of ${h2}`);
    }
    return s.includes(l) || s.push(l), s;
  }, []);
}
var vb = (e10, t) => e10.key < t.key ? -1 : e10.key > t.key ? 1 : 0;
var nl = class _nl {
  constructor({ compat: t, customTags: n, merge: r, resolveKnownTags: i, schema: s, sortMapEntries: o, toStringDefaults: l }) {
    this.compat = Array.isArray(t) ? lo(t, "compat") : t ? lo(null, t) : null, this.name = typeof s == "string" && s || "core", this.knownTags = i ? wb : {}, this.tags = lo(n, this.name, r), this.toStringOptions = l ?? null, Object.defineProperty(this, er, { value: li }), Object.defineProperty(this, mn, { value: W0 }), Object.defineProperty(this, oi, { value: ci }), this.sortMapEntries = typeof o == "function" ? o : o === true ? vb : null;
  }
  clone() {
    const t = Object.create(_nl.prototype, Object.getOwnPropertyDescriptors(this));
    return t.tags = this.tags.slice(), t;
  }
};
function kb(e10, t) {
  var _a2;
  const n = [];
  let r = t.directives === true;
  if (t.directives !== false && e10.directives) {
    const f = e10.directives.toString(e10);
    f ? (n.push(f), r = true) : e10.directives.docStart && (r = true);
  }
  r && n.push("---");
  const i = Ad(e10, t), { commentString: s } = i.options;
  if (e10.commentBefore) {
    n.length !== 1 && n.unshift("");
    const f = s(e10.commentBefore);
    n.unshift(Fn(f, ""));
  }
  let o = false, l = null;
  if (e10.contents) {
    if (ot(e10.contents)) {
      if (e10.contents.spaceBefore && r && n.push(""), e10.contents.commentBefore) {
        const p = s(e10.contents.commentBefore);
        n.push(Fn(p, ""));
      }
      i.forceBlockIndent = !!e10.comment, l = e10.contents.comment;
    }
    const f = l ? void 0 : () => o = true;
    let h2 = Zr(e10.contents, i, () => l = null, f);
    l && (h2 += dr(h2, "", s(l))), (h2[0] === "|" || h2[0] === ">") && n[n.length - 1] === "---" ? n[n.length - 1] = `--- ${h2}` : n.push(h2);
  } else
    n.push(Zr(e10.contents, i));
  if ((_a2 = e10.directives) == null ? void 0 : _a2.docEnd)
    if (e10.comment) {
      const f = s(e10.comment);
      f.includes(`
`) ? (n.push("..."), n.push(Fn(f, ""))) : n.push(`... ${f}`);
    } else
      n.push("...");
  else {
    let f = e10.comment;
    f && o && (f = f.replace(/^\n+/, "")), f && ((!o || l) && n[n.length - 1] !== "" && n.push(""), n.push(Fn(s(f), "")));
  }
  return n.join(`
`) + `
`;
}
var Vd = class Gd {
  constructor(t, n, r) {
    this.commentBefore = null, this.comment = null, this.errors = [], this.warnings = [], Object.defineProperty(this, Yt, { value: Go });
    let i = null;
    typeof n == "function" || Array.isArray(n) ? i = n : r === void 0 && n && (r = n, n = void 0);
    const s = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      stringKeys: false,
      uniqueKeys: true,
      version: "1.2"
    }, r);
    this.options = s;
    let { version: o } = s;
    (r == null ? void 0 : r._directives) ? (this.directives = r._directives.atDocument(), this.directives.yaml.explicit && (o = this.directives.yaml.version)) : this.directives = new St({ version: o }), this.setSchema(o, r), this.contents = t === void 0 ? null : this.createNode(t, i, r);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const t = Object.create(Gd.prototype, {
      [Yt]: { value: Go }
    });
    return t.commentBefore = this.commentBefore, t.comment = this.comment, t.errors = this.errors.slice(), t.warnings = this.warnings.slice(), t.options = Object.assign({}, this.options), this.directives && (t.directives = this.directives.clone()), t.schema = this.schema.clone(), t.contents = ot(this.contents) ? this.contents.clone(t.schema) : this.contents, this.range && (t.range = this.range.slice()), t;
  }
  /** Adds a value to the document. */
  add(t) {
    Nr(this.contents) && this.contents.add(t);
  }
  /** Adds a value to the document. */
  addIn(t, n) {
    Nr(this.contents) && this.contents.addIn(t, n);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(t, n) {
    if (!t.anchor) {
      const r = wd(this);
      t.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !n || r.has(n) ? vd(n || "a", r) : n;
    }
    return new Va(t.anchor);
  }
  createNode(t, n, r) {
    let i;
    if (typeof n == "function")
      t = n.call({ "": t }, "", t), i = n;
    else if (Array.isArray(n)) {
      const T = (N) => typeof N == "number" || N instanceof String || N instanceof Number, D = n.filter(T).map(String);
      D.length > 0 && (n = n.concat(D)), i = n;
    } else r === void 0 && n && (r = n, n = void 0);
    const { aliasDuplicateObjects: s, anchorPrefix: o, flow: l, keepUndefined: f, onTagObj: h2, tag: p } = r ?? {}, { onAnchor: b, setAnchors: v, sourceObjects: k } = Y7(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      o || "a"
    ), w = {
      aliasDuplicateObjects: s ?? true,
      keepUndefined: f ?? false,
      onAnchor: b,
      onTagObj: h2,
      replacer: i,
      schema: this.schema,
      sourceObjects: k
    }, A = Gi(t, p, w);
    return l && ut(A) && (A.flow = true), v(), A;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(t, n, r = {}) {
    const i = this.createNode(t, null, r), s = this.createNode(n, null, r);
    return new At(i, s);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(t) {
    return Nr(this.contents) ? this.contents.delete(t) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(t) {
    return Ti(t) ? this.contents == null ? false : (this.contents = null, true) : Nr(this.contents) ? this.contents.deleteIn(t) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(t, n) {
    return ut(this.contents) ? this.contents.get(t, n) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(t, n) {
    return Ti(t) ? !n && We(this.contents) ? this.contents.value : this.contents : ut(this.contents) ? this.contents.getIn(t, n) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(t) {
    return ut(this.contents) ? this.contents.has(t) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(t) {
    return Ti(t) ? this.contents !== void 0 : ut(this.contents) ? this.contents.hasIn(t) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(t, n) {
    this.contents == null ? this.contents = k0(this.schema, [t], n) : Nr(this.contents) && this.contents.set(t, n);
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(t, n) {
    Ti(t) ? this.contents = n : this.contents == null ? this.contents = k0(this.schema, Array.from(t), n) : Nr(this.contents) && this.contents.setIn(t, n);
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(t, n = {}) {
    typeof t == "number" && (t = String(t));
    let r;
    switch (t) {
      case "1.1":
        this.directives ? this.directives.yaml.version = "1.1" : this.directives = new St({ version: "1.1" }), r = { resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        this.directives ? this.directives.yaml.version = t : this.directives = new St({ version: t }), r = { resolveKnownTags: true, schema: "core" };
        break;
      case null:
        this.directives && delete this.directives, r = null;
        break;
      default: {
        const i = JSON.stringify(t);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${i}`);
      }
    }
    if (n.schema instanceof Object)
      this.schema = n.schema;
    else if (r)
      this.schema = new nl(Object.assign(r, n));
    else
      throw new Error("With a null YAML version, the { schema: Schema } option is required");
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json: t, jsonArg: n, mapAsMap: r, maxAliasCount: i, onAnchor: s, reviver: o } = {}) {
    const l = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !t,
      mapAsMap: r === true,
      mapKeyWarned: false,
      maxAliasCount: typeof i == "number" ? i : 100
    }, f = Kt(this.contents, n ?? "", l);
    if (typeof s == "function")
      for (const { count: h2, res: p } of l.anchors.values())
        s(p, h2);
    return typeof o == "function" ? qr(o, { "": f }, "", f) : f;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(t, n) {
    return this.toJS({ json: true, jsonArg: t, mapAsMap: false, onAnchor: n });
  }
  /** A YAML representation of the document. */
  toString(t = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in t && (!Number.isInteger(t.indent) || Number(t.indent) <= 0)) {
      const n = JSON.stringify(t.indent);
      throw new Error(`"indent" option must be a positive integer, not ${n}`);
    }
    return kb(this, t);
  }
};
function Nr(e10) {
  if (ut(e10))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
var Wd = class extends Error {
  constructor(t, n, r, i) {
    super(), this.name = t, this.code = r, this.message = i, this.pos = n;
  }
};
var Di = class extends Wd {
  constructor(t, n, r) {
    super("YAMLParseError", t, n, r);
  }
};
var _b = class extends Wd {
  constructor(t, n, r) {
    super("YAMLWarning", t, n, r);
  }
};
var Gf = (e10, t) => (n) => {
  if (n.pos[0] === -1)
    return;
  n.linePos = n.pos.map((l) => t.linePos(l));
  const { line: r, col: i } = n.linePos[0];
  n.message += ` at line ${r}, column ${i}`;
  let s = i - 1, o = e10.substring(t.lineStarts[r - 1], t.lineStarts[r]).replace(/[\n\r]+$/, "");
  if (s >= 60 && o.length > 80) {
    const l = Math.min(s - 39, o.length - 79);
    o = "â€¦" + o.substring(l), s -= l - 1;
  }
  if (o.length > 80 && (o = o.substring(0, 79) + "â€¦"), r > 1 && /^ *$/.test(o.substring(0, s))) {
    let l = e10.substring(t.lineStarts[r - 2], t.lineStarts[r - 1]);
    l.length > 80 && (l = l.substring(0, 79) + `â€¦
`), o = l + o;
  }
  if (/[^ ]/.test(o)) {
    let l = 1;
    const f = n.linePos[1];
    f && f.line === r && f.col > i && (l = Math.max(1, Math.min(f.col - i, 80 - s)));
    const h2 = " ".repeat(s) + "^".repeat(l);
    n.message += `:

${o}
${h2}
`;
  }
};
function Jr(e10, { flow: t, indicator: n, next: r, offset: i, onError: s, parentIndent: o, startOnNewline: l }) {
  let f = false, h2 = l, p = l, b = "", v = "", k = false, w = false, A = null, T = null, D = null, N = null, O = null, q = null, z = null;
  for (const K of e10)
    switch (w && (K.type !== "space" && K.type !== "newline" && K.type !== "comma" && s(K.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), w = false), A && (h2 && K.type !== "comment" && K.type !== "newline" && s(A, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), A = null), K.type) {
      case "space":
        !t && (n !== "doc-start" || (r == null ? void 0 : r.type) !== "flow-collection") && K.source.includes("	") && (A = K), p = true;
        break;
      case "comment": {
        p || s(K, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const V = K.source.substring(1) || " ";
        b ? b += v + V : b = V, v = "", h2 = false;
        break;
      }
      case "newline":
        h2 ? b ? b += K.source : (!q || n !== "seq-item-ind") && (f = true) : v += K.source, h2 = true, k = true, (T || D) && (N = K), p = true;
        break;
      case "anchor":
        T && s(K, "MULTIPLE_ANCHORS", "A node can have at most one anchor"), K.source.endsWith(":") && s(K.offset + K.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true), T = K, z ?? (z = K.offset), h2 = false, p = false, w = true;
        break;
      case "tag": {
        D && s(K, "MULTIPLE_TAGS", "A node can have at most one tag"), D = K, z ?? (z = K.offset), h2 = false, p = false, w = true;
        break;
      }
      case n:
        (T || D) && s(K, "BAD_PROP_ORDER", `Anchors and tags must be after the ${K.source} indicator`), q && s(K, "UNEXPECTED_TOKEN", `Unexpected ${K.source} in ${t ?? "collection"}`), q = K, h2 = n === "seq-item-ind" || n === "explicit-key-ind", p = false;
        break;
      case "comma":
        if (t) {
          O && s(K, "UNEXPECTED_TOKEN", `Unexpected , in ${t}`), O = K, h2 = false, p = false;
          break;
        }
      default:
        s(K, "UNEXPECTED_TOKEN", `Unexpected ${K.type} token`), h2 = false, p = false;
    }
  const R = e10[e10.length - 1], J = R ? R.offset + R.source.length : i;
  return w && r && r.type !== "space" && r.type !== "newline" && r.type !== "comma" && (r.type !== "scalar" || r.source !== "") && s(r.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), A && (h2 && A.indent <= o || (r == null ? void 0 : r.type) === "block-map" || (r == null ? void 0 : r.type) === "block-seq") && s(A, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), {
    comma: O,
    found: q,
    spaceBefore: f,
    comment: b,
    hasNewline: k,
    anchor: T,
    tag: D,
    newlineAfterProp: N,
    end: J,
    start: z ?? J
  };
}
function Wi(e10) {
  if (!e10)
    return null;
  switch (e10.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (e10.source.includes(`
`))
        return true;
      if (e10.end) {
        for (const t of e10.end)
          if (t.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const t of e10.items) {
        for (const n of t.start)
          if (n.type === "newline")
            return true;
        if (t.sep) {
          for (const n of t.sep)
            if (n.type === "newline")
              return true;
        }
        if (Wi(t.key) || Wi(t.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}
function Yo(e10, t, n) {
  if ((t == null ? void 0 : t.type) === "flow-collection") {
    const r = t.end[0];
    r.indent === e10 && (r.source === "]" || r.source === "}") && Wi(t) && n(r, "BAD_INDENT", "Flow end indicator should be more indented than parent", true);
  }
}
function Kd(e10, t, n) {
  const { uniqueKeys: r } = e10.options;
  if (r === false)
    return false;
  const i = typeof r == "function" ? r : (s, o) => s === o || We(s) && We(o) && s.value === o.value;
  return t.some((s) => i(s.key, n));
}
var Wf = "All mapping items must start at the same column";
function Sb({ composeNode: e10, composeEmptyNode: t }, n, r, i, s) {
  var _a2;
  const o = (s == null ? void 0 : s.nodeClass) ?? Wt, l = new o(n.schema);
  n.atRoot && (n.atRoot = false);
  let f = r.offset, h2 = null;
  for (const p of r.items) {
    const { start: b, key: v, sep: k, value: w } = p, A = Jr(b, {
      indicator: "explicit-key-ind",
      next: v ?? (k == null ? void 0 : k[0]),
      offset: f,
      onError: i,
      parentIndent: r.indent,
      startOnNewline: true
    }), T = !A.found;
    if (T) {
      if (v && (v.type === "block-seq" ? i(f, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key") : "indent" in v && v.indent !== r.indent && i(f, "BAD_INDENT", Wf)), !A.anchor && !A.tag && !k) {
        h2 = A.end, A.comment && (l.comment ? l.comment += `
` + A.comment : l.comment = A.comment);
        continue;
      }
      (A.newlineAfterProp || Wi(v)) && i(v ?? b[b.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
    } else ((_a2 = A.found) == null ? void 0 : _a2.indent) !== r.indent && i(f, "BAD_INDENT", Wf);
    n.atKey = true;
    const D = A.end, N = v ? e10(n, v, A, i) : t(n, D, b, null, A, i);
    n.schema.compat && Yo(r.indent, v, i), n.atKey = false, Kd(n, l.items, N) && i(D, "DUPLICATE_KEY", "Map keys must be unique");
    const O = Jr(k ?? [], {
      indicator: "map-value-ind",
      next: w,
      offset: N.range[2],
      onError: i,
      parentIndent: r.indent,
      startOnNewline: !v || v.type === "block-scalar"
    });
    if (f = O.end, O.found) {
      T && ((w == null ? void 0 : w.type) === "block-map" && !O.hasNewline && i(f, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"), n.options.strict && A.start < O.found.offset - 1024 && i(N.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));
      const q = w ? e10(n, w, O, i) : t(n, f, k, null, O, i);
      n.schema.compat && Yo(r.indent, w, i), f = q.range[2];
      const z = new At(N, q);
      n.options.keepSourceTokens && (z.srcToken = p), l.items.push(z);
    } else {
      T && i(N.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"), O.comment && (N.comment ? N.comment += `
` + O.comment : N.comment = O.comment);
      const q = new At(N);
      n.options.keepSourceTokens && (q.srcToken = p), l.items.push(q);
    }
  }
  return h2 && h2 < f && i(h2, "IMPOSSIBLE", "Map comment with trailing content"), l.range = [r.offset, f, h2 ?? f], l;
}
function Ab({ composeNode: e10, composeEmptyNode: t }, n, r, i, s) {
  const o = (s == null ? void 0 : s.nodeClass) ?? wr, l = new o(n.schema);
  n.atRoot && (n.atRoot = false), n.atKey && (n.atKey = false);
  let f = r.offset, h2 = null;
  for (const { start: p, value: b } of r.items) {
    const v = Jr(p, {
      indicator: "seq-item-ind",
      next: b,
      offset: f,
      onError: i,
      parentIndent: r.indent,
      startOnNewline: true
    });
    if (!v.found)
      if (v.anchor || v.tag || b)
        b && b.type === "block-seq" ? i(v.end, "BAD_INDENT", "All sequence items must start at the same column") : i(f, "MISSING_CHAR", "Sequence item without - indicator");
      else {
        h2 = v.end, v.comment && (l.comment = v.comment);
        continue;
      }
    const k = b ? e10(n, b, v, i) : t(n, v.end, p, null, v, i);
    n.schema.compat && Yo(r.indent, b, i), f = k.range[2], l.items.push(k);
  }
  return l.range = [r.offset, f, h2 ?? f], l;
}
function as(e10, t, n, r) {
  let i = "";
  if (e10) {
    let s = false, o = "";
    for (const l of e10) {
      const { source: f, type: h2 } = l;
      switch (h2) {
        case "space":
          s = true;
          break;
        case "comment": {
          n && !s && r(l, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const p = f.substring(1) || " ";
          i ? i += o + p : i = p, o = "";
          break;
        }
        case "newline":
          i && (o += f), s = true;
          break;
        default:
          r(l, "UNEXPECTED_TOKEN", `Unexpected ${h2} at node end`);
      }
      t += f.length;
    }
  }
  return { comment: i, offset: t };
}
var co = "Block collections are not allowed within flow collections";
var fo = (e10) => e10 && (e10.type === "block-map" || e10.type === "block-seq");
function Eb({ composeNode: e10, composeEmptyNode: t }, n, r, i, s) {
  const o = r.start.source === "{", l = o ? "flow map" : "flow sequence", f = (s == null ? void 0 : s.nodeClass) ?? (o ? Wt : wr), h2 = new f(n.schema);
  h2.flow = true;
  const p = n.atRoot;
  p && (n.atRoot = false), n.atKey && (n.atKey = false);
  let b = r.offset + r.start.source.length;
  for (let T = 0; T < r.items.length; ++T) {
    const D = r.items[T], { start: N, key: O, sep: q, value: z } = D, R = Jr(N, {
      flow: l,
      indicator: "explicit-key-ind",
      next: O ?? (q == null ? void 0 : q[0]),
      offset: b,
      onError: i,
      parentIndent: r.indent,
      startOnNewline: false
    });
    if (!R.found) {
      if (!R.anchor && !R.tag && !q && !z) {
        T === 0 && R.comma ? i(R.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${l}`) : T < r.items.length - 1 && i(R.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${l}`), R.comment && (h2.comment ? h2.comment += `
` + R.comment : h2.comment = R.comment), b = R.end;
        continue;
      }
      !o && n.options.strict && Wi(O) && i(
        O,
        // checked by containsNewline()
        "MULTILINE_IMPLICIT_KEY",
        "Implicit keys of flow sequence pairs need to be on a single line"
      );
    }
    if (T === 0)
      R.comma && i(R.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${l}`);
    else if (R.comma || i(R.start, "MISSING_CHAR", `Missing , between ${l} items`), R.comment) {
      let J = "";
      e: for (const K of N)
        switch (K.type) {
          case "comma":
          case "space":
            break;
          case "comment":
            J = K.source.substring(1);
            break e;
          default:
            break e;
        }
      if (J) {
        let K = h2.items[h2.items.length - 1];
        at(K) && (K = K.value ?? K.key), K.comment ? K.comment += `
` + J : K.comment = J, R.comment = R.comment.substring(J.length + 1);
      }
    }
    if (!o && !q && !R.found) {
      const J = z ? e10(n, z, R, i) : t(n, R.end, q, null, R, i);
      h2.items.push(J), b = J.range[2], fo(z) && i(J.range, "BLOCK_IN_FLOW", co);
    } else {
      n.atKey = true;
      const J = R.end, K = O ? e10(n, O, R, i) : t(n, J, N, null, R, i);
      fo(O) && i(K.range, "BLOCK_IN_FLOW", co), n.atKey = false;
      const V = Jr(q ?? [], {
        flow: l,
        indicator: "map-value-ind",
        next: z,
        offset: K.range[2],
        onError: i,
        parentIndent: r.indent,
        startOnNewline: false
      });
      if (V.found) {
        if (!o && !R.found && n.options.strict) {
          if (q)
            for (const se of q) {
              if (se === V.found)
                break;
              if (se.type === "newline") {
                i(se, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          R.start < V.found.offset - 1024 && i(V.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else z && ("source" in z && z.source && z.source[0] === ":" ? i(z, "MISSING_CHAR", `Missing space after : in ${l}`) : i(V.start, "MISSING_CHAR", `Missing , or : between ${l} items`));
      const te = z ? e10(n, z, V, i) : V.found ? t(n, V.end, q, null, V, i) : null;
      te ? fo(z) && i(te.range, "BLOCK_IN_FLOW", co) : V.comment && (K.comment ? K.comment += `
` + V.comment : K.comment = V.comment);
      const Z = new At(K, te);
      if (n.options.keepSourceTokens && (Z.srcToken = D), o) {
        const se = h2;
        Kd(n, se.items, K) && i(J, "DUPLICATE_KEY", "Map keys must be unique"), se.items.push(Z);
      } else {
        const se = new Wt(n.schema);
        se.flow = true, se.items.push(Z);
        const fe = (te ?? K).range;
        se.range = [K.range[0], fe[1], fe[2]], h2.items.push(se);
      }
      b = te ? te.range[2] : V.end;
    }
  }
  const v = o ? "}" : "]", [k, ...w] = r.end;
  let A = b;
  if (k && k.source === v)
    A = k.offset + k.source.length;
  else {
    const T = l[0].toUpperCase() + l.substring(1), D = p ? `${T} must end with a ${v}` : `${T} in block collection must be sufficiently indented and end with a ${v}`;
    i(b, p ? "MISSING_CHAR" : "BAD_INDENT", D), k && k.source.length !== 1 && w.unshift(k);
  }
  if (w.length > 0) {
    const T = as(w, A, n.options.strict, i);
    T.comment && (h2.comment ? h2.comment += `
` + T.comment : h2.comment = T.comment), h2.range = [r.offset, A, T.offset];
  } else
    h2.range = [r.offset, A, A];
  return h2;
}
function ho(e10, t, n, r, i, s) {
  const o = n.type === "block-map" ? Sb(e10, t, n, r, s) : n.type === "block-seq" ? Ab(e10, t, n, r, s) : Eb(e10, t, n, r, s), l = o.constructor;
  return i === "!" || i === l.tagName ? (o.tag = l.tagName, o) : (i && (o.tag = i), o);
}
function Cb(e10, t, n, r, i) {
  var _a2;
  const s = r.tag, o = s ? t.directives.tagName(s.source, (v) => i(s, "TAG_RESOLVE_FAILED", v)) : null;
  if (n.type === "block-seq") {
    const { anchor: v, newlineAfterProp: k } = r, w = v && s ? v.offset > s.offset ? v : s : v ?? s;
    w && (!k || k.offset < w.offset) && i(w, "MISSING_CHAR", "Missing newline after block sequence props");
  }
  const l = n.type === "block-map" ? "map" : n.type === "block-seq" ? "seq" : n.start.source === "{" ? "map" : "seq";
  if (!s || !o || o === "!" || o === Wt.tagName && l === "map" || o === wr.tagName && l === "seq")
    return ho(e10, t, n, i, o);
  let f = t.schema.tags.find((v) => v.tag === o && v.collection === l);
  if (!f) {
    const v = t.schema.knownTags[o];
    if (v && v.collection === l)
      t.schema.tags.push(Object.assign({}, v, { default: false })), f = v;
    else
      return v ? i(s, "BAD_COLLECTION_TYPE", `${v.tag} used for ${l} collection, but expects ${v.collection ?? "scalar"}`, true) : i(s, "TAG_RESOLVE_FAILED", `Unresolved tag: ${o}`, true), ho(e10, t, n, i, o);
  }
  const h2 = ho(e10, t, n, i, o, f), p = ((_a2 = f.resolve) == null ? void 0 : _a2.call(f, h2, (v) => i(s, "TAG_RESOLVE_FAILED", v), t.options)) ?? h2, b = ot(p) ? p : new Se(p);
  return b.range = h2.range, b.tag = o, (f == null ? void 0 : f.format) && (b.format = f.format), b;
}
function Tb(e10, t, n) {
  const r = t.offset, i = Db(t, e10.options.strict, n);
  if (!i)
    return { value: "", type: null, comment: "", range: [r, r, r] };
  const s = i.mode === ">" ? Se.BLOCK_FOLDED : Se.BLOCK_LITERAL, o = t.source ? Mb(t.source) : [];
  let l = o.length;
  for (let A = o.length - 1; A >= 0; --A) {
    const T = o[A][1];
    if (T === "" || T === "\r")
      l = A;
    else
      break;
  }
  if (l === 0) {
    const A = i.chomp === "+" && o.length > 0 ? `
`.repeat(Math.max(1, o.length - 1)) : "";
    let T = r + i.length;
    return t.source && (T += t.source.length), { value: A, type: s, comment: i.comment, range: [r, T, T] };
  }
  let f = t.indent + i.indent, h2 = t.offset + i.length, p = 0;
  for (let A = 0; A < l; ++A) {
    const [T, D] = o[A];
    if (D === "" || D === "\r")
      i.indent === 0 && T.length > f && (f = T.length);
    else {
      T.length < f && n(h2 + T.length, "MISSING_CHAR", "Block scalars with more-indented leading empty lines must use an explicit indentation indicator"), i.indent === 0 && (f = T.length), p = A, f === 0 && !e10.atRoot && n(h2, "BAD_INDENT", "Block scalar values in collections must be indented");
      break;
    }
    h2 += T.length + D.length + 1;
  }
  for (let A = o.length - 1; A >= l; --A)
    o[A][0].length > f && (l = A + 1);
  let b = "", v = "", k = false;
  for (let A = 0; A < p; ++A)
    b += o[A][0].slice(f) + `
`;
  for (let A = p; A < l; ++A) {
    let [T, D] = o[A];
    h2 += T.length + D.length + 1;
    const N = D[D.length - 1] === "\r";
    if (N && (D = D.slice(0, -1)), D && T.length < f) {
      const q = `Block scalar lines must not be less indented than their ${i.indent ? "explicit indentation indicator" : "first line"}`;
      n(h2 - D.length - (N ? 2 : 1), "BAD_INDENT", q), T = "";
    }
    s === Se.BLOCK_LITERAL ? (b += v + T.slice(f) + D, v = `
`) : T.length > f || D[0] === "	" ? (v === " " ? v = `
` : !k && v === `
` && (v = `

`), b += v + T.slice(f) + D, v = `
`, k = true) : D === "" ? v === `
` ? b += `
` : v = `
` : (b += v + D, v = " ", k = false);
  }
  switch (i.chomp) {
    case "-":
      break;
    case "+":
      for (let A = l; A < o.length; ++A)
        b += `
` + o[A][0].slice(f);
      b[b.length - 1] !== `
` && (b += `
`);
      break;
    default:
      b += `
`;
  }
  const w = r + i.length + t.source.length;
  return { value: b, type: s, comment: i.comment, range: [r, w, w] };
}
function Db({ offset: e10, props: t }, n, r) {
  if (t[0].type !== "block-scalar-header")
    return r(t[0], "IMPOSSIBLE", "Block scalar header not found"), null;
  const { source: i } = t[0], s = i[0];
  let o = 0, l = "", f = -1;
  for (let v = 1; v < i.length; ++v) {
    const k = i[v];
    if (!l && (k === "-" || k === "+"))
      l = k;
    else {
      const w = Number(k);
      !o && w ? o = w : f === -1 && (f = e10 + v);
    }
  }
  f !== -1 && r(f, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${i}`);
  let h2 = false, p = "", b = i.length;
  for (let v = 1; v < t.length; ++v) {
    const k = t[v];
    switch (k.type) {
      case "space":
        h2 = true;
      case "newline":
        b += k.source.length;
        break;
      case "comment":
        n && !h2 && r(k, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters"), b += k.source.length, p = k.source.substring(1);
        break;
      case "error":
        r(k, "UNEXPECTED_TOKEN", k.message), b += k.source.length;
        break;
      default: {
        const w = `Unexpected token in block scalar header: ${k.type}`;
        r(k, "UNEXPECTED_TOKEN", w);
        const A = k.source;
        A && typeof A == "string" && (b += A.length);
      }
    }
  }
  return { mode: s, indent: o, chomp: l, comment: p, length: b };
}
function Mb(e10) {
  const t = e10.split(/\n( *)/), n = t[0], r = n.match(/^( *)/), s = [(r == null ? void 0 : r[1]) ? [r[1], n.slice(r[1].length)] : ["", n]];
  for (let o = 1; o < t.length; o += 2)
    s.push([t[o], t[o + 1]]);
  return s;
}
function Nb(e10, t, n) {
  const { offset: r, type: i, source: s, end: o } = e10;
  let l, f;
  const h2 = (v, k, w) => n(r + v, k, w);
  switch (i) {
    case "scalar":
      l = Se.PLAIN, f = Ib(s, h2);
      break;
    case "single-quoted-scalar":
      l = Se.QUOTE_SINGLE, f = Fb(s, h2);
      break;
    case "double-quoted-scalar":
      l = Se.QUOTE_DOUBLE, f = Bb(s, h2);
      break;
    default:
      return n(e10, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${i}`), {
        value: "",
        type: null,
        comment: "",
        range: [r, r + s.length, r + s.length]
      };
  }
  const p = r + s.length, b = as(o, p, t, n);
  return {
    value: f,
    type: l,
    comment: b.comment,
    range: [r, p, b.offset]
  };
}
function Ib(e10, t) {
  let n = "";
  switch (e10[0]) {
    case "	":
      n = "a tab character";
      break;
    case ",":
      n = "flow indicator character ,";
      break;
    case "%":
      n = "directive indicator character %";
      break;
    case "|":
    case ">": {
      n = `block scalar indicator ${e10[0]}`;
      break;
    }
    case "@":
    case "`": {
      n = `reserved character ${e10[0]}`;
      break;
    }
  }
  return n && t(0, "BAD_SCALAR_START", `Plain value cannot start with ${n}`), Xd(e10);
}
function Fb(e10, t) {
  return (e10[e10.length - 1] !== "'" || e10.length === 1) && t(e10.length, "MISSING_CHAR", "Missing closing 'quote"), Xd(e10.slice(1, -1)).replace(/''/g, "'");
}
function Xd(e10) {
  let t, n;
  try {
    t = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy"), n = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
  } catch {
    t = /(.*?)[ \t]*\r?\n/sy, n = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let r = t.exec(e10);
  if (!r)
    return e10;
  let i = r[1], s = " ", o = t.lastIndex;
  for (n.lastIndex = o; r = n.exec(e10); )
    r[1] === "" ? s === `
` ? i += s : s = `
` : (i += s + r[1], s = " "), o = n.lastIndex;
  const l = /[ \t]*(.*)/sy;
  return l.lastIndex = o, r = l.exec(e10), i + s + ((r == null ? void 0 : r[1]) ?? "");
}
function Bb(e10, t) {
  let n = "";
  for (let r = 1; r < e10.length - 1; ++r) {
    const i = e10[r];
    if (!(i === "\r" && e10[r + 1] === `
`))
      if (i === `
`) {
        const { fold: s, offset: o } = Ob(e10, r);
        n += s, r = o;
      } else if (i === "\\") {
        let s = e10[++r];
        const o = zb[s];
        if (o)
          n += o;
        else if (s === `
`)
          for (s = e10[r + 1]; s === " " || s === "	"; )
            s = e10[++r + 1];
        else if (s === "\r" && e10[r + 1] === `
`)
          for (s = e10[++r + 1]; s === " " || s === "	"; )
            s = e10[++r + 1];
        else if (s === "x" || s === "u" || s === "U") {
          const l = { x: 2, u: 4, U: 8 }[s];
          n += $b(e10, r + 1, l, t), r += l;
        } else {
          const l = e10.substr(r - 1, 2);
          t(r - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${l}`), n += l;
        }
      } else if (i === " " || i === "	") {
        const s = r;
        let o = e10[r + 1];
        for (; o === " " || o === "	"; )
          o = e10[++r + 1];
        o !== `
` && !(o === "\r" && e10[r + 2] === `
`) && (n += r > s ? e10.slice(s, r + 1) : i);
      } else
        n += i;
  }
  return (e10[e10.length - 1] !== '"' || e10.length === 1) && t(e10.length, "MISSING_CHAR", 'Missing closing "quote'), n;
}
function Ob(e10, t) {
  let n = "", r = e10[t + 1];
  for (; (r === " " || r === "	" || r === `
` || r === "\r") && !(r === "\r" && e10[t + 2] !== `
`); )
    r === `
` && (n += `
`), t += 1, r = e10[t + 1];
  return n || (n = " "), { fold: n, offset: t };
}
var zb = {
  0: "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: `
`,
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "Â…",
  // Unicode next line
  _: "Â ",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function $b(e10, t, n, r) {
  const i = e10.substr(t, n), o = i.length === n && /^[0-9a-fA-F]+$/.test(i) ? parseInt(i, 16) : NaN;
  if (isNaN(o)) {
    const l = e10.substr(t - 2, n + 2);
    return r(t - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${l}`), l;
  }
  return String.fromCodePoint(o);
}
function Yd(e10, t, n, r) {
  const { value: i, type: s, comment: o, range: l } = t.type === "block-scalar" ? Tb(e10, t, r) : Nb(t, e10.options.strict, r), f = n ? e10.directives.tagName(n.source, (b) => r(n, "TAG_RESOLVE_FAILED", b)) : null;
  let h2;
  e10.options.stringKeys && e10.atKey ? h2 = e10.schema[mn] : f ? h2 = Lb(e10.schema, i, f, n, r) : t.type === "scalar" ? h2 = qb(e10, i, t, r) : h2 = e10.schema[mn];
  let p;
  try {
    const b = h2.resolve(i, (v) => r(n ?? t, "TAG_RESOLVE_FAILED", v), e10.options);
    p = We(b) ? b : new Se(b);
  } catch (b) {
    const v = b instanceof Error ? b.message : String(b);
    r(n ?? t, "TAG_RESOLVE_FAILED", v), p = new Se(i);
  }
  return p.range = l, p.source = i, s && (p.type = s), f && (p.tag = f), h2.format && (p.format = h2.format), o && (p.comment = o), p;
}
function Lb(e10, t, n, r, i) {
  var _a2;
  if (n === "!")
    return e10[mn];
  const s = [];
  for (const l of e10.tags)
    if (!l.collection && l.tag === n)
      if (l.default && l.test)
        s.push(l);
      else
        return l;
  for (const l of s)
    if ((_a2 = l.test) == null ? void 0 : _a2.test(t))
      return l;
  const o = e10.knownTags[n];
  return o && !o.collection ? (e10.tags.push(Object.assign({}, o, { default: false, test: void 0 })), o) : (i(r, "TAG_RESOLVE_FAILED", `Unresolved tag: ${n}`, n !== "tag:yaml.org,2002:str"), e10[mn]);
}
function qb({ atKey: e10, directives: t, schema: n }, r, i, s) {
  const o = n.tags.find((l) => {
    var _a2;
    return (l.default === true || e10 && l.default === "key") && ((_a2 = l.test) == null ? void 0 : _a2.test(r));
  }) || n[mn];
  if (n.compat) {
    const l = n.compat.find((f) => {
      var _a2;
      return f.default && ((_a2 = f.test) == null ? void 0 : _a2.test(r));
    }) ?? n[mn];
    if (o.tag !== l.tag) {
      const f = t.tagString(o.tag), h2 = t.tagString(l.tag), p = `Value may be parsed as either ${f} or ${h2}`;
      s(i, "TAG_RESOLVE_FAILED", p, true);
    }
  }
  return o;
}
function Rb(e10, t, n) {
  if (t) {
    n ?? (n = t.length);
    for (let r = n - 1; r >= 0; --r) {
      let i = t[r];
      switch (i.type) {
        case "space":
        case "comment":
        case "newline":
          e10 -= i.source.length;
          continue;
      }
      for (i = t[++r]; (i == null ? void 0 : i.type) === "space"; )
        e10 += i.source.length, i = t[++r];
      break;
    }
  }
  return e10;
}
var Pb = { composeNode: Zd, composeEmptyNode: rl };
function Zd(e10, t, n, r) {
  const i = e10.atKey, { spaceBefore: s, comment: o, anchor: l, tag: f } = n;
  let h2, p = true;
  switch (t.type) {
    case "alias":
      h2 = Hb(e10, t, r), (l || f) && r(t, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      h2 = Yd(e10, t, f, r), l && (h2.anchor = l.source.substring(1));
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      h2 = Cb(Pb, e10, t, n, r), l && (h2.anchor = l.source.substring(1));
      break;
    default: {
      const b = t.type === "error" ? t.message : `Unsupported token (type: ${t.type})`;
      r(t, "UNEXPECTED_TOKEN", b), h2 = rl(e10, t.offset, void 0, null, n, r), p = false;
    }
  }
  return l && h2.anchor === "" && r(l, "BAD_ALIAS", "Anchor cannot be an empty string"), i && e10.options.stringKeys && (!We(h2) || typeof h2.value != "string" || h2.tag && h2.tag !== "tag:yaml.org,2002:str") && r(f ?? t, "NON_STRING_KEY", "With stringKeys, all keys must be strings"), s && (h2.spaceBefore = true), o && (t.type === "scalar" && t.source === "" ? h2.comment = o : h2.commentBefore = o), e10.options.keepSourceTokens && p && (h2.srcToken = t), h2;
}
function rl(e10, t, n, r, { spaceBefore: i, comment: s, anchor: o, tag: l, end: f }, h2) {
  const p = {
    type: "scalar",
    offset: Rb(t, n, r),
    indent: -1,
    source: ""
  }, b = Yd(e10, p, l, h2);
  return o && (b.anchor = o.source.substring(1), b.anchor === "" && h2(o, "BAD_ALIAS", "Anchor cannot be an empty string")), i && (b.spaceBefore = true), s && (b.comment = s, b.range[2] = f), b;
}
function Hb({ options: e10 }, { offset: t, source: n, end: r }, i) {
  const s = new Va(n.substring(1));
  s.source === "" && i(t, "BAD_ALIAS", "Alias cannot be an empty string"), s.source.endsWith(":") && i(t + n.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const o = t + n.length, l = as(r, o, e10.strict, i);
  return s.range = [t, o, l.offset], l.comment && (s.comment = l.comment), s;
}
function jb(e10, t, { offset: n, start: r, value: i, end: s }, o) {
  const l = Object.assign({ _directives: t }, e10), f = new Vd(void 0, l), h2 = {
    atKey: false,
    atRoot: true,
    directives: f.directives,
    options: f.options,
    schema: f.schema
  }, p = Jr(r, {
    indicator: "doc-start",
    next: i ?? (s == null ? void 0 : s[0]),
    offset: n,
    onError: o,
    parentIndent: 0,
    startOnNewline: true
  });
  p.found && (f.directives.docStart = true, i && (i.type === "block-map" || i.type === "block-seq") && !p.hasNewline && o(p.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")), f.contents = i ? Zd(h2, i, p, o) : rl(h2, p.end, r, null, p, o);
  const b = f.contents.range[2], v = as(s, b, false, o);
  return v.comment && (f.comment = v.comment), f.range = [n, b, v.offset], f;
}
function wi(e10) {
  if (typeof e10 == "number")
    return [e10, e10 + 1];
  if (Array.isArray(e10))
    return e10.length === 2 ? e10 : [e10[0], e10[1]];
  const { offset: t, source: n } = e10;
  return [t, t + (typeof n == "string" ? n.length : 1)];
}
function Kf(e10) {
  var _a2;
  let t = "", n = false, r = false;
  for (let i = 0; i < e10.length; ++i) {
    const s = e10[i];
    switch (s[0]) {
      case "#":
        t += (t === "" ? "" : r ? `

` : `
`) + (s.substring(1) || " "), n = true, r = false;
        break;
      case "%":
        ((_a2 = e10[i + 1]) == null ? void 0 : _a2[0]) !== "#" && (i += 1), n = false;
        break;
      default:
        n || (r = true), n = false;
    }
  }
  return { comment: t, afterEmptyLine: r };
}
var Ub = class {
  constructor(t = {}) {
    this.doc = null, this.atDirectives = false, this.prelude = [], this.errors = [], this.warnings = [], this.onError = (n, r, i, s) => {
      const o = wi(n);
      s ? this.warnings.push(new _b(o, r, i)) : this.errors.push(new Di(o, r, i));
    }, this.directives = new St({ version: t.version || "1.2" }), this.options = t;
  }
  decorate(t, n) {
    const { comment: r, afterEmptyLine: i } = Kf(this.prelude);
    if (r) {
      const s = t.contents;
      if (n)
        t.comment = t.comment ? `${t.comment}
${r}` : r;
      else if (i || t.directives.docStart || !s)
        t.commentBefore = r;
      else if (ut(s) && !s.flow && s.items.length > 0) {
        let o = s.items[0];
        at(o) && (o = o.key);
        const l = o.commentBefore;
        o.commentBefore = l ? `${r}
${l}` : r;
      } else {
        const o = s.commentBefore;
        s.commentBefore = o ? `${r}
${o}` : r;
      }
    }
    n ? (Array.prototype.push.apply(t.errors, this.errors), Array.prototype.push.apply(t.warnings, this.warnings)) : (t.errors = this.errors, t.warnings = this.warnings), this.prelude = [], this.errors = [], this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: Kf(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(t, n = false, r = -1) {
    for (const i of t)
      yield* this.next(i);
    yield* this.end(n, r);
  }
  /** Advance the composer by one CST token. */
  *next(t) {
    switch (t.type) {
      case "directive":
        this.directives.add(t.source, (n, r, i) => {
          const s = wi(t);
          s[0] += n, this.onError(s, "BAD_DIRECTIVE", r, i);
        }), this.prelude.push(t.source), this.atDirectives = true;
        break;
      case "document": {
        const n = jb(this.options, this.directives, t, this.onError);
        this.atDirectives && !n.directives.docStart && this.onError(t, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"), this.decorate(n, false), this.doc && (yield this.doc), this.doc = n, this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(t.source);
        break;
      case "error": {
        const n = t.source ? `${t.message}: ${JSON.stringify(t.source)}` : t.message, r = new Di(wi(t), "UNEXPECTED_TOKEN", n);
        this.atDirectives || !this.doc ? this.errors.push(r) : this.doc.errors.push(r);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const r = "Unexpected doc-end without preceding document";
          this.errors.push(new Di(wi(t), "UNEXPECTED_TOKEN", r));
          break;
        }
        this.doc.directives.docEnd = true;
        const n = as(t.end, t.offset + t.source.length, this.doc.options.strict, this.onError);
        if (this.decorate(this.doc, true), n.comment) {
          const r = this.doc.comment;
          this.doc.comment = r ? `${r}
${n.comment}` : n.comment;
        }
        this.doc.range[2] = n.offset;
        break;
      }
      default:
        this.errors.push(new Di(wi(t), "UNEXPECTED_TOKEN", `Unsupported token ${t.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(t = false, n = -1) {
    if (this.doc)
      this.decorate(this.doc, true), yield this.doc, this.doc = null;
    else if (t) {
      const r = Object.assign({ _directives: this.directives }, this.options), i = new Vd(void 0, r);
      this.atDirectives && this.onError(n, "MISSING_CHAR", "Missing directives-end indicator line"), i.range = [0, n, n], this.decorate(i, false), yield i;
    }
  }
};
var Jd = "\uFEFF";
var Qd = "";
var ep = "";
var Zo = "";
function Vb(e10) {
  switch (e10) {
    case Jd:
      return "byte-order-mark";
    case Qd:
      return "doc-mode";
    case ep:
      return "flow-error-end";
    case Zo:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case `
`:
    case `\r
`:
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (e10[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
function Jt(e10) {
  switch (e10) {
    case void 0:
    case " ":
    case `
`:
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var Xf = new Set("0123456789ABCDEFabcdef");
var Gb = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
var Ps = new Set(",[]{}");
var Wb = new Set(` ,[]{}
\r	`);
var po = (e10) => !e10 || Wb.has(e10);
var Kb = class {
  constructor() {
    this.atEnd = false, this.blockScalarIndent = -1, this.blockScalarKeep = false, this.buffer = "", this.flowKey = false, this.flowLevel = 0, this.indentNext = 0, this.indentValue = 0, this.lineEndPos = null, this.next = null, this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(t, n = false) {
    if (t) {
      if (typeof t != "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + t : t, this.lineEndPos = null;
    }
    this.atEnd = !n;
    let r = this.next ?? "stream";
    for (; r && (n || this.hasChars(1)); )
      r = yield* this.parseNext(r);
  }
  atLineEnd() {
    let t = this.pos, n = this.buffer[t];
    for (; n === " " || n === "	"; )
      n = this.buffer[++t];
    return !n || n === "#" || n === `
` ? true : n === "\r" ? this.buffer[t + 1] === `
` : false;
  }
  charAt(t) {
    return this.buffer[this.pos + t];
  }
  continueScalar(t) {
    let n = this.buffer[t];
    if (this.indentNext > 0) {
      let r = 0;
      for (; n === " "; )
        n = this.buffer[++r + t];
      if (n === "\r") {
        const i = this.buffer[r + t + 1];
        if (i === `
` || !i && !this.atEnd)
          return t + r + 1;
      }
      return n === `
` || r >= this.indentNext || !n && !this.atEnd ? t + r : -1;
    }
    if (n === "-" || n === ".") {
      const r = this.buffer.substr(t, 3);
      if ((r === "---" || r === "...") && Jt(this.buffer[t + 3]))
        return -1;
    }
    return t;
  }
  getLine() {
    let t = this.lineEndPos;
    return (typeof t != "number" || t !== -1 && t < this.pos) && (t = this.buffer.indexOf(`
`, this.pos), this.lineEndPos = t), t === -1 ? this.atEnd ? this.buffer.substring(this.pos) : null : (this.buffer[t - 1] === "\r" && (t -= 1), this.buffer.substring(this.pos, t));
  }
  hasChars(t) {
    return this.pos + t <= this.buffer.length;
  }
  setNext(t) {
    return this.buffer = this.buffer.substring(this.pos), this.pos = 0, this.lineEndPos = null, this.next = t, null;
  }
  peek(t) {
    return this.buffer.substr(this.pos, t);
  }
  *parseNext(t) {
    switch (t) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let t = this.getLine();
    if (t === null)
      return this.setNext("stream");
    if (t[0] === Jd && (yield* this.pushCount(1), t = t.substring(1)), t[0] === "%") {
      let n = t.length, r = t.indexOf("#");
      for (; r !== -1; ) {
        const s = t[r - 1];
        if (s === " " || s === "	") {
          n = r - 1;
          break;
        } else
          r = t.indexOf("#", r + 1);
      }
      for (; ; ) {
        const s = t[n - 1];
        if (s === " " || s === "	")
          n -= 1;
        else
          break;
      }
      const i = (yield* this.pushCount(n)) + (yield* this.pushSpaces(true));
      return yield* this.pushCount(t.length - i), this.pushNewline(), "stream";
    }
    if (this.atLineEnd()) {
      const n = yield* this.pushSpaces(true);
      return yield* this.pushCount(t.length - n), yield* this.pushNewline(), "stream";
    }
    return yield Qd, yield* this.parseLineStart();
  }
  *parseLineStart() {
    const t = this.charAt(0);
    if (!t && !this.atEnd)
      return this.setNext("line-start");
    if (t === "-" || t === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const n = this.peek(3);
      if ((n === "---" || n === "...") && Jt(this.charAt(3)))
        return yield* this.pushCount(3), this.indentValue = 0, this.indentNext = 0, n === "---" ? "doc" : "stream";
    }
    return this.indentValue = yield* this.pushSpaces(false), this.indentNext > this.indentValue && !Jt(this.charAt(1)) && (this.indentNext = this.indentValue), yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [t, n] = this.peek(2);
    if (!n && !this.atEnd)
      return this.setNext("block-start");
    if ((t === "-" || t === "?" || t === ":") && Jt(n)) {
      const r = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      return this.indentNext = this.indentValue + 1, this.indentValue += r, yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const t = this.getLine();
    if (t === null)
      return this.setNext("doc");
    let n = yield* this.pushIndicators();
    switch (t[n]) {
      case "#":
        yield* this.pushCount(t.length - n);
      case void 0:
        return yield* this.pushNewline(), yield* this.parseLineStart();
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = false, this.flowLevel = 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), "doc";
      case "*":
        return yield* this.pushUntil(po), "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        return n += yield* this.parseBlockScalarHeader(), n += yield* this.pushSpaces(true), yield* this.pushCount(t.length - n), yield* this.pushNewline(), yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let t, n, r = -1;
    do
      t = yield* this.pushNewline(), t > 0 ? (n = yield* this.pushSpaces(false), this.indentValue = r = n) : n = 0, n += yield* this.pushSpaces(true);
    while (t + n > 0);
    const i = this.getLine();
    if (i === null)
      return this.setNext("flow");
    if ((r !== -1 && r < this.indentNext && i[0] !== "#" || r === 0 && (i.startsWith("---") || i.startsWith("...")) && Jt(i[3])) && !(r === this.indentNext - 1 && this.flowLevel === 1 && (i[0] === "]" || i[0] === "}")))
      return this.flowLevel = 0, yield ep, yield* this.parseLineStart();
    let s = 0;
    for (; i[s] === ","; )
      s += yield* this.pushCount(1), s += yield* this.pushSpaces(true), this.flowKey = false;
    switch (s += yield* this.pushIndicators(), i[s]) {
      case void 0:
        return "flow";
      case "#":
        return yield* this.pushCount(i.length - s), "flow";
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = false, this.flowLevel += 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), this.flowKey = true, this.flowLevel -= 1, this.flowLevel ? "flow" : "doc";
      case "*":
        return yield* this.pushUntil(po), "flow";
      case '"':
      case "'":
        return this.flowKey = true, yield* this.parseQuotedScalar();
      case ":": {
        const o = this.charAt(1);
        if (this.flowKey || Jt(o) || o === ",")
          return this.flowKey = false, yield* this.pushCount(1), yield* this.pushSpaces(true), "flow";
      }
      default:
        return this.flowKey = false, yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const t = this.charAt(0);
    let n = this.buffer.indexOf(t, this.pos + 1);
    if (t === "'")
      for (; n !== -1 && this.buffer[n + 1] === "'"; )
        n = this.buffer.indexOf("'", n + 2);
    else
      for (; n !== -1; ) {
        let s = 0;
        for (; this.buffer[n - 1 - s] === "\\"; )
          s += 1;
        if (s % 2 === 0)
          break;
        n = this.buffer.indexOf('"', n + 1);
      }
    const r = this.buffer.substring(0, n);
    let i = r.indexOf(`
`, this.pos);
    if (i !== -1) {
      for (; i !== -1; ) {
        const s = this.continueScalar(i + 1);
        if (s === -1)
          break;
        i = r.indexOf(`
`, s);
      }
      i !== -1 && (n = i - (r[i - 1] === "\r" ? 2 : 1));
    }
    if (n === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      n = this.buffer.length;
    }
    return yield* this.pushToIndex(n + 1, false), this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1, this.blockScalarKeep = false;
    let t = this.pos;
    for (; ; ) {
      const n = this.buffer[++t];
      if (n === "+")
        this.blockScalarKeep = true;
      else if (n > "0" && n <= "9")
        this.blockScalarIndent = Number(n) - 1;
      else if (n !== "-")
        break;
    }
    return yield* this.pushUntil((n) => Jt(n) || n === "#");
  }
  *parseBlockScalar() {
    let t = this.pos - 1, n = 0, r;
    e: for (let s = this.pos; r = this.buffer[s]; ++s)
      switch (r) {
        case " ":
          n += 1;
          break;
        case `
`:
          t = s, n = 0;
          break;
        case "\r": {
          const o = this.buffer[s + 1];
          if (!o && !this.atEnd)
            return this.setNext("block-scalar");
          if (o === `
`)
            break;
        }
        default:
          break e;
      }
    if (!r && !this.atEnd)
      return this.setNext("block-scalar");
    if (n >= this.indentNext) {
      this.blockScalarIndent === -1 ? this.indentNext = n : this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      do {
        const s = this.continueScalar(t + 1);
        if (s === -1)
          break;
        t = this.buffer.indexOf(`
`, s);
      } while (t !== -1);
      if (t === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        t = this.buffer.length;
      }
    }
    let i = t + 1;
    for (r = this.buffer[i]; r === " "; )
      r = this.buffer[++i];
    if (r === "	") {
      for (; r === "	" || r === " " || r === "\r" || r === `
`; )
        r = this.buffer[++i];
      t = i - 1;
    } else if (!this.blockScalarKeep)
      do {
        let s = t - 1, o = this.buffer[s];
        o === "\r" && (o = this.buffer[--s]);
        const l = s;
        for (; o === " "; )
          o = this.buffer[--s];
        if (o === `
` && s >= this.pos && s + 1 + n > l)
          t = s;
        else
          break;
      } while (true);
    return yield Zo, yield* this.pushToIndex(t + 1, true), yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const t = this.flowLevel > 0;
    let n = this.pos - 1, r = this.pos - 1, i;
    for (; i = this.buffer[++r]; )
      if (i === ":") {
        const s = this.buffer[r + 1];
        if (Jt(s) || t && Ps.has(s))
          break;
        n = r;
      } else if (Jt(i)) {
        let s = this.buffer[r + 1];
        if (i === "\r" && (s === `
` ? (r += 1, i = `
`, s = this.buffer[r + 1]) : n = r), s === "#" || t && Ps.has(s))
          break;
        if (i === `
`) {
          const o = this.continueScalar(r + 1);
          if (o === -1)
            break;
          r = Math.max(r, o - 2);
        }
      } else {
        if (t && Ps.has(i))
          break;
        n = r;
      }
    return !i && !this.atEnd ? this.setNext("plain-scalar") : (yield Zo, yield* this.pushToIndex(n + 1, true), t ? "flow" : "doc");
  }
  *pushCount(t) {
    return t > 0 ? (yield this.buffer.substr(this.pos, t), this.pos += t, t) : 0;
  }
  *pushToIndex(t, n) {
    const r = this.buffer.slice(this.pos, t);
    return r ? (yield r, this.pos += r.length, r.length) : (n && (yield ""), 0);
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(po)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      case "?":
      case ":": {
        const t = this.flowLevel > 0, n = this.charAt(1);
        if (Jt(n) || t && Ps.has(n))
          return t ? this.flowKey && (this.flowKey = false) : this.indentNext = this.indentValue + 1, (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let t = this.pos + 2, n = this.buffer[t];
      for (; !Jt(n) && n !== ">"; )
        n = this.buffer[++t];
      return yield* this.pushToIndex(n === ">" ? t + 1 : t, false);
    } else {
      let t = this.pos + 1, n = this.buffer[t];
      for (; n; )
        if (Gb.has(n))
          n = this.buffer[++t];
        else if (n === "%" && Xf.has(this.buffer[t + 1]) && Xf.has(this.buffer[t + 2]))
          n = this.buffer[t += 3];
        else
          break;
      return yield* this.pushToIndex(t, false);
    }
  }
  *pushNewline() {
    const t = this.buffer[this.pos];
    return t === `
` ? yield* this.pushCount(1) : t === "\r" && this.charAt(1) === `
` ? yield* this.pushCount(2) : 0;
  }
  *pushSpaces(t) {
    let n = this.pos - 1, r;
    do
      r = this.buffer[++n];
    while (r === " " || t && r === "	");
    const i = n - this.pos;
    return i > 0 && (yield this.buffer.substr(this.pos, i), this.pos = n), i;
  }
  *pushUntil(t) {
    let n = this.pos, r = this.buffer[n];
    for (; !t(r); )
      r = this.buffer[++n];
    return yield* this.pushToIndex(n, false);
  }
};
var Xb = class {
  constructor() {
    this.lineStarts = [], this.addNewLine = (t) => this.lineStarts.push(t), this.linePos = (t) => {
      let n = 0, r = this.lineStarts.length;
      for (; n < r; ) {
        const s = n + r >> 1;
        this.lineStarts[s] < t ? n = s + 1 : r = s;
      }
      if (this.lineStarts[n] === t)
        return { line: n + 1, col: 1 };
      if (n === 0)
        return { line: 0, col: t };
      const i = this.lineStarts[n - 1];
      return { line: n, col: t - i + 1 };
    };
  }
};
function Gn(e10, t) {
  for (let n = 0; n < e10.length; ++n)
    if (e10[n].type === t)
      return true;
  return false;
}
function Yf(e10) {
  for (let t = 0; t < e10.length; ++t)
    switch (e10[t].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return t;
    }
  return -1;
}
function tp(e10) {
  switch (e10 == null ? void 0 : e10.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function Hs(e10) {
  switch (e10.type) {
    case "document":
      return e10.start;
    case "block-map": {
      const t = e10.items[e10.items.length - 1];
      return t.sep ?? t.start;
    }
    case "block-seq":
      return e10.items[e10.items.length - 1].start;
    default:
      return [];
  }
}
function Ir(e10) {
  var _a2;
  if (e10.length === 0)
    return [];
  let t = e10.length;
  e: for (; --t >= 0; )
    switch (e10[t].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break e;
    }
  for (; ((_a2 = e10[++t]) == null ? void 0 : _a2.type) === "space"; )
    ;
  return e10.splice(t, e10.length);
}
function Zf(e10) {
  if (e10.start.type === "flow-seq-start")
    for (const t of e10.items)
      t.sep && !t.value && !Gn(t.start, "explicit-key-ind") && !Gn(t.sep, "map-value-ind") && (t.key && (t.value = t.key), delete t.key, tp(t.value) ? t.value.end ? Array.prototype.push.apply(t.value.end, t.sep) : t.value.end = t.sep : Array.prototype.push.apply(t.start, t.sep), delete t.sep);
}
var Yb = class {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(t) {
    this.atNewLine = true, this.atScalar = false, this.indent = 0, this.offset = 0, this.onKeyLine = false, this.stack = [], this.source = "", this.type = "", this.lexer = new Kb(), this.onNewLine = t;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(t, n = false) {
    this.onNewLine && this.offset === 0 && this.onNewLine(0);
    for (const r of this.lexer.lex(t, n))
      yield* this.next(r);
    n || (yield* this.end());
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(t) {
    if (this.source = t, this.atScalar) {
      this.atScalar = false, yield* this.step(), this.offset += t.length;
      return;
    }
    const n = Vb(t);
    if (n)
      if (n === "scalar")
        this.atNewLine = false, this.atScalar = true, this.type = "scalar";
      else {
        switch (this.type = n, yield* this.step(), n) {
          case "newline":
            this.atNewLine = true, this.indent = 0, this.onNewLine && this.onNewLine(this.offset + t.length);
            break;
          case "space":
            this.atNewLine && t[0] === " " && (this.indent += t.length);
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            this.atNewLine && (this.indent += t.length);
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = false;
        }
        this.offset += t.length;
      }
    else {
      const r = `Not a YAML token: ${t}`;
      yield* this.pop({ type: "error", offset: this.offset, message: r, source: t }), this.offset += t.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    for (; this.stack.length > 0; )
      yield* this.pop();
  }
  get sourceToken() {
    return {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  *step() {
    const t = this.peek(1);
    if (this.type === "doc-end" && (!t || t.type !== "doc-end")) {
      for (; this.stack.length > 0; )
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!t)
      return yield* this.stream();
    switch (t.type) {
      case "document":
        return yield* this.document(t);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(t);
      case "block-scalar":
        return yield* this.blockScalar(t);
      case "block-map":
        return yield* this.blockMap(t);
      case "block-seq":
        return yield* this.blockSequence(t);
      case "flow-collection":
        return yield* this.flowCollection(t);
      case "doc-end":
        return yield* this.documentEnd(t);
    }
    yield* this.pop();
  }
  peek(t) {
    return this.stack[this.stack.length - t];
  }
  *pop(t) {
    const n = t ?? this.stack.pop();
    if (!n)
      yield { type: "error", offset: this.offset, source: "", message: "Tried to pop an empty stack" };
    else if (this.stack.length === 0)
      yield n;
    else {
      const r = this.peek(1);
      switch (n.type === "block-scalar" ? n.indent = "indent" in r ? r.indent : 0 : n.type === "flow-collection" && r.type === "document" && (n.indent = 0), n.type === "flow-collection" && Zf(n), r.type) {
        case "document":
          r.value = n;
          break;
        case "block-scalar":
          r.props.push(n);
          break;
        case "block-map": {
          const i = r.items[r.items.length - 1];
          if (i.value) {
            r.items.push({ start: [], key: n, sep: [] }), this.onKeyLine = true;
            return;
          } else if (i.sep)
            i.value = n;
          else {
            Object.assign(i, { key: n, sep: [] }), this.onKeyLine = !i.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const i = r.items[r.items.length - 1];
          i.value ? r.items.push({ start: [], value: n }) : i.value = n;
          break;
        }
        case "flow-collection": {
          const i = r.items[r.items.length - 1];
          !i || i.value ? r.items.push({ start: [], key: n, sep: [] }) : i.sep ? i.value = n : Object.assign(i, { key: n, sep: [] });
          return;
        }
        default:
          yield* this.pop(), yield* this.pop(n);
      }
      if ((r.type === "document" || r.type === "block-map" || r.type === "block-seq") && (n.type === "block-map" || n.type === "block-seq")) {
        const i = n.items[n.items.length - 1];
        i && !i.sep && !i.value && i.start.length > 0 && Yf(i.start) === -1 && (n.indent === 0 || i.start.every((s) => s.type !== "comment" || s.indent < n.indent)) && (r.type === "document" ? r.end = i.start : r.items.push({ start: i.start }), n.items.splice(-1, 1));
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const t = {
          type: "document",
          offset: this.offset,
          start: []
        };
        this.type === "doc-start" && t.start.push(this.sourceToken), this.stack.push(t);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(t) {
    if (t.value)
      return yield* this.lineEnd(t);
    switch (this.type) {
      case "doc-start": {
        Yf(t.start) !== -1 ? (yield* this.pop(), yield* this.step()) : t.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        t.start.push(this.sourceToken);
        return;
    }
    const n = this.startBlockValue(t);
    n ? this.stack.push(n) : yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML document`,
      source: this.source
    };
  }
  *scalar(t) {
    if (this.type === "map-value-ind") {
      const n = Hs(this.peek(2)), r = Ir(n);
      let i;
      t.end ? (i = t.end, i.push(this.sourceToken), delete t.end) : i = [this.sourceToken];
      const s = {
        type: "block-map",
        offset: t.offset,
        indent: t.indent,
        items: [{ start: r, key: t, sep: i }]
      };
      this.onKeyLine = true, this.stack[this.stack.length - 1] = s;
    } else
      yield* this.lineEnd(t);
  }
  *blockScalar(t) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        t.props.push(this.sourceToken);
        return;
      case "scalar":
        if (t.source = this.source, this.atNewLine = true, this.indent = 0, this.onNewLine) {
          let n = this.source.indexOf(`
`) + 1;
          for (; n !== 0; )
            this.onNewLine(this.offset + n), n = this.source.indexOf(`
`, n) + 1;
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop(), yield* this.step();
    }
  }
  *blockMap(t) {
    var _a2, _b2, _c;
    const n = t.items[t.items.length - 1];
    switch (this.type) {
      case "newline":
        if (this.onKeyLine = false, n.value) {
          const r = "end" in n.value ? n.value.end : void 0;
          ((_a2 = Array.isArray(r) ? r[r.length - 1] : void 0) == null ? void 0 : _a2.type) === "comment" ? r == null ? void 0 : r.push(this.sourceToken) : t.items.push({ start: [this.sourceToken] });
        } else n.sep ? n.sep.push(this.sourceToken) : n.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (n.value)
          t.items.push({ start: [this.sourceToken] });
        else if (n.sep)
          n.sep.push(this.sourceToken);
        else {
          if (this.atIndentedComment(n.start, t.indent)) {
            const i = (_c = (_b2 = t.items[t.items.length - 2]) == null ? void 0 : _b2.value) == null ? void 0 : _c.end;
            if (Array.isArray(i)) {
              Array.prototype.push.apply(i, n.start), i.push(this.sourceToken), t.items.pop();
              return;
            }
          }
          n.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= t.indent) {
      const r = !this.onKeyLine && this.indent === t.indent, i = r && (n.sep || n.explicitKey) && this.type !== "seq-item-ind";
      let s = [];
      if (i && n.sep && !n.value) {
        const o = [];
        for (let l = 0; l < n.sep.length; ++l) {
          const f = n.sep[l];
          switch (f.type) {
            case "newline":
              o.push(l);
              break;
            case "space":
              break;
            case "comment":
              f.indent > t.indent && (o.length = 0);
              break;
            default:
              o.length = 0;
          }
        }
        o.length >= 2 && (s = n.sep.splice(o[1]));
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          i || n.value ? (s.push(this.sourceToken), t.items.push({ start: s }), this.onKeyLine = true) : n.sep ? n.sep.push(this.sourceToken) : n.start.push(this.sourceToken);
          return;
        case "explicit-key-ind":
          !n.sep && !n.explicitKey ? (n.start.push(this.sourceToken), n.explicitKey = true) : i || n.value ? (s.push(this.sourceToken), t.items.push({ start: s, explicitKey: true })) : this.stack.push({
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken], explicitKey: true }]
          }), this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (n.explicitKey)
            if (n.sep)
              if (n.value)
                t.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (Gn(n.sep, "map-value-ind"))
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: s, key: null, sep: [this.sourceToken] }]
                });
              else if (tp(n.key) && !Gn(n.sep, "newline")) {
                const o = Ir(n.start), l = n.key, f = n.sep;
                f.push(this.sourceToken), delete n.key, delete n.sep, this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: o, key: l, sep: f }]
                });
              } else s.length > 0 ? n.sep = n.sep.concat(s, this.sourceToken) : n.sep.push(this.sourceToken);
            else if (Gn(n.start, "newline"))
              Object.assign(n, { key: null, sep: [this.sourceToken] });
            else {
              const o = Ir(n.start);
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: o, key: null, sep: [this.sourceToken] }]
              });
            }
          else
            n.sep ? n.value || i ? t.items.push({ start: s, key: null, sep: [this.sourceToken] }) : Gn(n.sep, "map-value-ind") ? this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [], key: null, sep: [this.sourceToken] }]
            }) : n.sep.push(this.sourceToken) : Object.assign(n, { key: null, sep: [this.sourceToken] });
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const o = this.flowScalar(this.type);
          i || n.value ? (t.items.push({ start: s, key: o, sep: [] }), this.onKeyLine = true) : n.sep ? this.stack.push(o) : (Object.assign(n, { key: o, sep: [] }), this.onKeyLine = true);
          return;
        }
        default: {
          const o = this.startBlockValue(t);
          if (o) {
            if (o.type === "block-seq") {
              if (!n.explicitKey && n.sep && !Gn(n.sep, "newline")) {
                yield* this.pop({
                  type: "error",
                  offset: this.offset,
                  message: "Unexpected block-seq-ind on same line with key",
                  source: this.source
                });
                return;
              }
            } else r && t.items.push({ start: s });
            this.stack.push(o);
            return;
          }
        }
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *blockSequence(t) {
    var _a2, _b2, _c;
    const n = t.items[t.items.length - 1];
    switch (this.type) {
      case "newline":
        if (n.value) {
          const r = "end" in n.value ? n.value.end : void 0;
          ((_a2 = Array.isArray(r) ? r[r.length - 1] : void 0) == null ? void 0 : _a2.type) === "comment" ? r == null ? void 0 : r.push(this.sourceToken) : t.items.push({ start: [this.sourceToken] });
        } else
          n.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (n.value)
          t.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(n.start, t.indent)) {
            const i = (_c = (_b2 = t.items[t.items.length - 2]) == null ? void 0 : _b2.value) == null ? void 0 : _c.end;
            if (Array.isArray(i)) {
              Array.prototype.push.apply(i, n.start), i.push(this.sourceToken), t.items.pop();
              return;
            }
          }
          n.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (n.value || this.indent <= t.indent)
          break;
        n.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== t.indent)
          break;
        n.value || Gn(n.start, "seq-item-ind") ? t.items.push({ start: [this.sourceToken] }) : n.start.push(this.sourceToken);
        return;
    }
    if (this.indent > t.indent) {
      const r = this.startBlockValue(t);
      if (r) {
        this.stack.push(r);
        return;
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *flowCollection(t) {
    const n = t.items[t.items.length - 1];
    if (this.type === "flow-error-end") {
      let r;
      do
        yield* this.pop(), r = this.peek(1);
      while (r && r.type === "flow-collection");
    } else if (t.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          !n || n.sep ? t.items.push({ start: [this.sourceToken] }) : n.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          !n || n.value ? t.items.push({ start: [], key: null, sep: [this.sourceToken] }) : n.sep ? n.sep.push(this.sourceToken) : Object.assign(n, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          !n || n.value ? t.items.push({ start: [this.sourceToken] }) : n.sep ? n.sep.push(this.sourceToken) : n.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const i = this.flowScalar(this.type);
          !n || n.value ? t.items.push({ start: [], key: i, sep: [] }) : n.sep ? this.stack.push(i) : Object.assign(n, { key: i, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          t.end.push(this.sourceToken);
          return;
      }
      const r = this.startBlockValue(t);
      r ? this.stack.push(r) : (yield* this.pop(), yield* this.step());
    } else {
      const r = this.peek(2);
      if (r.type === "block-map" && (this.type === "map-value-ind" && r.indent === t.indent || this.type === "newline" && !r.items[r.items.length - 1].sep))
        yield* this.pop(), yield* this.step();
      else if (this.type === "map-value-ind" && r.type !== "flow-collection") {
        const i = Hs(r), s = Ir(i);
        Zf(t);
        const o = t.end.splice(1, t.end.length);
        o.push(this.sourceToken);
        const l = {
          type: "block-map",
          offset: t.offset,
          indent: t.indent,
          items: [{ start: s, key: t, sep: o }]
        };
        this.onKeyLine = true, this.stack[this.stack.length - 1] = l;
      } else
        yield* this.lineEnd(t);
    }
  }
  flowScalar(t) {
    if (this.onNewLine) {
      let n = this.source.indexOf(`
`) + 1;
      for (; n !== 0; )
        this.onNewLine(this.offset + n), n = this.source.indexOf(`
`, n) + 1;
    }
    return {
      type: t,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(t) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const n = Hs(t), r = Ir(n);
        return r.push(this.sourceToken), {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: r, explicitKey: true }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const n = Hs(t), r = Ir(n);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: r, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(t, n) {
    return this.type !== "comment" || this.indent <= n ? false : t.every((r) => r.type === "newline" || r.type === "space");
  }
  *documentEnd(t) {
    this.type !== "doc-mode" && (t.end ? t.end.push(this.sourceToken) : t.end = [this.sourceToken], this.type === "newline" && (yield* this.pop()));
  }
  *lineEnd(t) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop(), yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      case "space":
      case "comment":
      default:
        t.end ? t.end.push(this.sourceToken) : t.end = [this.sourceToken], this.type === "newline" && (yield* this.pop());
    }
  }
};
function Zb(e10) {
  const t = e10.prettyErrors !== false;
  return { lineCounter: e10.lineCounter || t && new Xb() || null, prettyErrors: t };
}
function Jb(e10, t = {}) {
  const { lineCounter: n, prettyErrors: r } = Zb(t), i = new Yb(n == null ? void 0 : n.addNewLine), s = new Ub(t);
  let o = null;
  for (const l of s.compose(i.parse(e10), true, e10.length))
    if (!o)
      o = l;
    else if (o.options.logLevel !== "silent") {
      o.errors.push(new Di(l.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  return r && n && (o.errors.forEach(Gf(e10, n)), o.warnings.forEach(Gf(e10, n))), o;
}
function Qb(e10, t, n) {
  let r;
  const i = Jb(e10, n);
  if (!i)
    return null;
  if (i.warnings.forEach((s) => Ed(i.options.logLevel, s)), i.errors.length > 0) {
    if (i.options.logLevel !== "silent")
      throw i.errors[0];
    i.errors = [];
  }
  return i.toJS(Object.assign({ reviver: r }, n));
}
function e9(e10) {
  return e10 && e10.__esModule && Object.prototype.hasOwnProperty.call(e10, "default") ? e10.default : e10;
}
var Fr = {};
var e0 = { exports: {} };
var t9 = e0.exports;
var Jf;
function n9() {
  return Jf || (Jf = 1, function(e10, t) {
    (function(r, i) {
      e10.exports = i();
    })(typeof self < "u" ? self : t9, function() {
      return (
        /******/
        function() {
          var n = {};
          (function() {
            n.d = function(a, u) {
              for (var c in u)
                n.o(u, c) && !n.o(a, c) && Object.defineProperty(a, c, { enumerable: true, get: u[c] });
            };
          })(), function() {
            n.o = function(a, u) {
              return Object.prototype.hasOwnProperty.call(a, u);
            };
          }();
          var r = {};
          n.d(r, {
            default: function() {
              return (
                /* binding */
                Em
              );
            }
          });
          class i {
            // Error start position based on passed-in Token or ParseNode.
            // Length of affected text based on passed-in Token or ParseNode.
            // The underlying error message without any context added.
            constructor(u, c) {
              this.name = void 0, this.position = void 0, this.length = void 0, this.rawMessage = void 0;
              let d = "KaTeX parse error: " + u, m, y;
              const _ = c && c.loc;
              if (_ && _.start <= _.end) {
                const M = _.lexer.input;
                m = _.start, y = _.end, m === M.length ? d += " at end of input: " : d += " at position " + (m + 1) + ": ";
                const B = M.slice(m, y).replace(/[^]/g, "$&Ì²");
                let H;
                m > 15 ? H = "â€¦" + M.slice(m - 15, m) : H = M.slice(0, m);
                let U;
                y + 15 < M.length ? U = M.slice(y, y + 15) + "â€¦" : U = M.slice(y), d += H + B + U;
              }
              const E = new Error(d);
              return E.name = "ParseError", E.__proto__ = i.prototype, E.position = m, m != null && y != null && (E.length = y - m), E.rawMessage = u, E;
            }
          }
          i.prototype.__proto__ = Error.prototype;
          var s = i;
          const o = function(a, u) {
            return a.indexOf(u) !== -1;
          }, l = function(a, u) {
            return a === void 0 ? u : a;
          }, f = /([A-Z])/g, h2 = function(a) {
            return a.replace(f, "-$1").toLowerCase();
          }, p = {
            "&": "&amp;",
            ">": "&gt;",
            "<": "&lt;",
            '"': "&quot;",
            "'": "&#x27;"
          }, b = /[&><"']/g;
          function v(a) {
            return String(a).replace(b, (u) => p[u]);
          }
          const k = function(a) {
            return a.type === "ordgroup" || a.type === "color" ? a.body.length === 1 ? k(a.body[0]) : a : a.type === "font" ? k(a.body) : a;
          }, w = function(a) {
            const u = k(a);
            return u.type === "mathord" || u.type === "textord" || u.type === "atom";
          }, A = function(a) {
            if (!a)
              throw new Error("Expected non-null, but got " + String(a));
            return a;
          };
          var D = {
            contains: o,
            deflt: l,
            escape: v,
            hyphenate: h2,
            getBaseElem: k,
            isCharacterBox: w,
            protocolFromUrl: function(a) {
              const u = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(a);
              return u ? u[2] !== ":" || !/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(u[1]) ? null : u[1].toLowerCase() : "_relative";
            }
          };
          const N = {
            displayMode: {
              type: "boolean",
              description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
              cli: "-d, --display-mode"
            },
            output: {
              type: {
                enum: ["htmlAndMathml", "html", "mathml"]
              },
              description: "Determines the markup language of the output.",
              cli: "-F, --format <type>"
            },
            leqno: {
              type: "boolean",
              description: "Render display math in leqno style (left-justified tags)."
            },
            fleqn: {
              type: "boolean",
              description: "Render display math flush left."
            },
            throwOnError: {
              type: "boolean",
              default: true,
              cli: "-t, --no-throw-on-error",
              cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
            },
            errorColor: {
              type: "string",
              default: "#cc0000",
              cli: "-c, --error-color <color>",
              cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
              cliProcessor: (a) => "#" + a
            },
            macros: {
              type: "object",
              cli: "-m, --macro <def>",
              cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
              cliDefault: [],
              cliProcessor: (a, u) => (u.push(a), u)
            },
            minRuleThickness: {
              type: "number",
              description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
              processor: (a) => Math.max(0, a),
              cli: "--min-rule-thickness <size>",
              cliProcessor: parseFloat
            },
            colorIsTextColor: {
              type: "boolean",
              description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
              cli: "-b, --color-is-text-color"
            },
            strict: {
              type: [{
                enum: ["warn", "ignore", "error"]
              }, "boolean", "function"],
              description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
              cli: "-S, --strict",
              cliDefault: false
            },
            trust: {
              type: ["boolean", "function"],
              description: "Trust the input, enabling all HTML features such as \\url.",
              cli: "-T, --trust"
            },
            maxSize: {
              type: "number",
              default: 1 / 0,
              description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
              processor: (a) => Math.max(0, a),
              cli: "-s, --max-size <n>",
              cliProcessor: parseInt
            },
            maxExpand: {
              type: "number",
              default: 1e3,
              description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
              processor: (a) => Math.max(0, a),
              cli: "-e, --max-expand <n>",
              cliProcessor: (a) => a === "Infinity" ? 1 / 0 : parseInt(a)
            },
            globalGroup: {
              type: "boolean",
              cli: false
            }
          };
          function O(a) {
            if (a.default)
              return a.default;
            const u = a.type, c = Array.isArray(u) ? u[0] : u;
            if (typeof c != "string")
              return c.enum[0];
            switch (c) {
              case "boolean":
                return false;
              case "string":
                return "";
              case "number":
                return 0;
              case "object":
                return {};
            }
          }
          class q {
            constructor(u) {
              this.displayMode = void 0, this.output = void 0, this.leqno = void 0, this.fleqn = void 0, this.throwOnError = void 0, this.errorColor = void 0, this.macros = void 0, this.minRuleThickness = void 0, this.colorIsTextColor = void 0, this.strict = void 0, this.trust = void 0, this.maxSize = void 0, this.maxExpand = void 0, this.globalGroup = void 0, u = u || {};
              for (const c in N)
                if (N.hasOwnProperty(c)) {
                  const d = N[c];
                  this[c] = u[c] !== void 0 ? d.processor ? d.processor(u[c]) : u[c] : O(d);
                }
            }
            /**
             * Report nonstrict (non-LaTeX-compatible) input.
             * Can safely not be called if `this.strict` is false in JavaScript.
             */
            reportNonstrict(u, c, d) {
              let m = this.strict;
              if (typeof m == "function" && (m = m(u, c, d)), !(!m || m === "ignore")) {
                if (m === true || m === "error")
                  throw new s("LaTeX-incompatible input and strict mode is set to 'error': " + (c + " [" + u + "]"), d);
                m === "warn" ? typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (c + " [" + u + "]")) : typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + m + "': " + c + " [" + u + "]"));
              }
            }
            /**
             * Check whether to apply strict (LaTeX-adhering) behavior for unusual
             * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
             * instead, "error" translates to a return value of `true`, while "ignore"
             * translates to a return value of `false`.  May still print a warning:
             * "warn" prints a warning and returns `false`.
             * This is for the second category of `errorCode`s listed in the README.
             */
            useStrictBehavior(u, c, d) {
              let m = this.strict;
              if (typeof m == "function")
                try {
                  m = m(u, c, d);
                } catch {
                  m = "error";
                }
              return !m || m === "ignore" ? false : m === true || m === "error" ? true : m === "warn" ? (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (c + " [" + u + "]")), false) : (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + m + "': " + c + " [" + u + "]")), false);
            }
            /**
             * Check whether to test potentially dangerous input, and return
             * `true` (trusted) or `false` (untrusted).  The sole argument `context`
             * should be an object with `command` field specifying the relevant LaTeX
             * command (as a string starting with `\`), and any other arguments, etc.
             * If `context` has a `url` field, a `protocol` field will automatically
             * get added by this function (changing the specified object).
             */
            isTrusted(u) {
              if (u.url && !u.protocol) {
                const d = D.protocolFromUrl(u.url);
                if (d == null)
                  return false;
                u.protocol = d;
              }
              return !!(typeof this.trust == "function" ? this.trust(u) : this.trust);
            }
          }
          class z {
            constructor(u, c, d) {
              this.id = void 0, this.size = void 0, this.cramped = void 0, this.id = u, this.size = c, this.cramped = d;
            }
            /**
             * Get the style of a superscript given a base in the current style.
             */
            sup() {
              return $[X[this.id]];
            }
            /**
             * Get the style of a subscript given a base in the current style.
             */
            sub() {
              return $[j[this.id]];
            }
            /**
             * Get the style of a fraction numerator given the fraction in the current
             * style.
             */
            fracNum() {
              return $[Q[this.id]];
            }
            /**
             * Get the style of a fraction denominator given the fraction in the current
             * style.
             */
            fracDen() {
              return $[ee[this.id]];
            }
            /**
             * Get the cramped version of a style (in particular, cramping a cramped style
             * doesn't change the style).
             */
            cramp() {
              return $[le[this.id]];
            }
            /**
             * Get a text or display version of this style.
             */
            text() {
              return $[ae[this.id]];
            }
            /**
             * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
             */
            isTight() {
              return this.size >= 2;
            }
          }
          const R = 0, J = 1, K = 2, V = 3, te = 4, Z = 5, se = 6, fe = 7, $ = [new z(R, 0, false), new z(J, 0, true), new z(K, 1, false), new z(V, 1, true), new z(te, 2, false), new z(Z, 2, true), new z(se, 3, false), new z(fe, 3, true)], X = [te, Z, te, Z, se, fe, se, fe], j = [Z, Z, Z, Z, fe, fe, fe, fe], Q = [K, V, te, Z, se, fe, se, fe], ee = [V, V, Z, Z, fe, fe, fe, fe], le = [J, J, V, V, Z, Z, fe, fe], ae = [R, J, K, V, K, V, K, V];
          var ne = {
            DISPLAY: $[R],
            TEXT: $[K],
            SCRIPT: $[te],
            SCRIPTSCRIPT: $[se]
          };
          const P = [{
            // Latin characters beyond the Latin-1 characters we have metrics for.
            // Needed for Czech, Hungarian and Turkish text, for example.
            name: "latin",
            blocks: [
              [256, 591],
              // Latin Extended-A and Latin Extended-B
              [768, 879]
              // Combining Diacritical marks
            ]
          }, {
            // The Cyrillic script used by Russian and related languages.
            // A Cyrillic subset used to be supported as explicitly defined
            // symbols in symbols.js
            name: "cyrillic",
            blocks: [[1024, 1279]]
          }, {
            // Armenian
            name: "armenian",
            blocks: [[1328, 1423]]
          }, {
            // The Brahmic scripts of South and Southeast Asia
            // Devanagari (0900â€“097F)
            // Bengali (0980â€“09FF)
            // Gurmukhi (0A00â€“0A7F)
            // Gujarati (0A80â€“0AFF)
            // Oriya (0B00â€“0B7F)
            // Tamil (0B80â€“0BFF)
            // Telugu (0C00â€“0C7F)
            // Kannada (0C80â€“0CFF)
            // Malayalam (0D00â€“0D7F)
            // Sinhala (0D80â€“0DFF)
            // Thai (0E00â€“0E7F)
            // Lao (0E80â€“0EFF)
            // Tibetan (0F00â€“0FFF)
            // Myanmar (1000â€“109F)
            name: "brahmic",
            blocks: [[2304, 4255]]
          }, {
            name: "georgian",
            blocks: [[4256, 4351]]
          }, {
            // Chinese and Japanese.
            // The "k" in cjk is for Korean, but we've separated Korean out
            name: "cjk",
            blocks: [
              [12288, 12543],
              // CJK symbols and punctuation, Hiragana, Katakana
              [19968, 40879],
              // CJK ideograms
              [65280, 65376]
              // Fullwidth punctuation
              // TODO: add halfwidth Katakana and Romanji glyphs
            ]
          }, {
            // Korean
            name: "hangul",
            blocks: [[44032, 55215]]
          }];
          function he(a) {
            for (let u = 0; u < P.length; u++) {
              const c = P[u];
              for (let d = 0; d < c.blocks.length; d++) {
                const m = c.blocks[d];
                if (a >= m[0] && a <= m[1])
                  return c.name;
              }
            }
            return null;
          }
          const ge = [];
          P.forEach((a) => a.blocks.forEach((u) => ge.push(...u)));
          function De(a) {
            for (let u = 0; u < ge.length; u += 2)
              if (a >= ge[u] && a <= ge[u + 1])
                return true;
            return false;
          }
          const He = 80, Y = function(a, u) {
            return "M95," + (622 + a + u) + `
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l` + a / 2.075 + " -" + a + `
c5.3,-9.3,12,-14,20,-14
H400000v` + (40 + a) + `H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M` + (834 + a) + " " + u + "h400000v" + (40 + a) + "h-400000z";
          }, Me = function(a, u) {
            return "M263," + (601 + a + u) + `c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l` + a / 2.084 + " -" + a + `
c4.7,-7.3,11,-11,19,-11
H40000v` + (40 + a) + `H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M` + (1001 + a) + " " + u + "h400000v" + (40 + a) + "h-400000z";
          }, _e = function(a, u) {
            return "M983 " + (10 + a + u) + `
l` + a / 3.13 + " -" + a + `
c4,-6.7,10,-10,18,-10 H400000v` + (40 + a) + `
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M` + (1001 + a) + " " + u + "h400000v" + (40 + a) + "h-400000z";
          }, Te = function(a, u) {
            return "M424," + (2398 + a + u) + `
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l` + a / 4.223 + " -" + a + `c4,-6.7,10,-10,18,-10 H400000
v` + (40 + a) + `H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M` + (1001 + a) + " " + u + `
h400000v` + (40 + a) + "h-400000z";
          }, Ke = function(a, u) {
            return "M473," + (2713 + a + u) + `
c339.3,-1799.3,509.3,-2700,510,-2702 l` + a / 5.298 + " -" + a + `
c3.3,-7.3,9.3,-11,18,-11 H400000v` + (40 + a) + `H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM` + (1001 + a) + " " + u + "h400000v" + (40 + a) + "H1017.7z";
          }, vt = function(a) {
            const u = a / 2;
            return "M400000 " + a + " H0 L" + u + " 0 l65 45 L145 " + (a - 80) + " H400000z";
          }, xn = function(a, u, c) {
            const d = c - 54 - u - a;
            return "M702 " + (a + u) + "H400000" + (40 + a) + `
H742v` + d + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ` + u + "H400000v" + (40 + a) + "H742z";
          }, wn = function(a, u, c) {
            u = 1e3 * u;
            let d = "";
            switch (a) {
              case "sqrtMain":
                d = Y(u, He);
                break;
              case "sqrtSize1":
                d = Me(u, He);
                break;
              case "sqrtSize2":
                d = _e(u, He);
                break;
              case "sqrtSize3":
                d = Te(u, He);
                break;
              case "sqrtSize4":
                d = Ke(u, He);
                break;
              case "sqrtTall":
                d = xn(u, He, c);
            }
            return d;
          }, kl = function(a, u) {
            switch (a) {
              case "âœ":
                return "M291 0 H417 V" + u + " H291z M291 0 H417 V" + u + " H291z";
              case "âˆ£":
                return "M145 0 H188 V" + u + " H145z M145 0 H188 V" + u + " H145z";
              case "âˆ¥":
                return "M145 0 H188 V" + u + " H145z M145 0 H188 V" + u + " H145z" + ("M367 0 H410 V" + u + " H367z M367 0 H410 V" + u + " H367z");
              case "âŸ":
                return "M457 0 H583 V" + u + " H457z M457 0 H583 V" + u + " H457z";
              case "â¢":
                return "M319 0 H403 V" + u + " H319z M319 0 H403 V" + u + " H319z";
              case "â¥":
                return "M263 0 H347 V" + u + " H263z M263 0 H347 V" + u + " H263z";
              case "âª":
                return "M384 0 H504 V" + u + " H384z M384 0 H504 V" + u + " H384z";
              case "â":
                return "M312 0 H355 V" + u + " H312z M312 0 H355 V" + u + " H312z";
              case "â€–":
                return "M257 0 H300 V" + u + " H257z M257 0 H300 V" + u + " H257z" + ("M478 0 H521 V" + u + " H478z M478 0 H521 V" + u + " H478z");
              default:
                return "";
            }
          }, _l = {
            // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
            doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
            // doublerightarrow is from glyph U+21D2 in font KaTeX Main
            doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
            // leftarrow is from glyph U+2190 in font KaTeX Main
            leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
            // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
            leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
            leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
            // overgroup is from the MnSymbol package (public domain)
            leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
            leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
            // Harpoons are from glyph U+21BD in font KaTeX Main
            leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
            leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
            leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
            leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
            // hook is from glyph U+21A9 in font KaTeX Main
            lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
            leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
            leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
            // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
            leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
            longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
            midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
            midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
            oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
            oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
            oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
            oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
            rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
            rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
            rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
            rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
            rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
            rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
            rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
            rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
            rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
            righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
            rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
            rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
            // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
            twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
            twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
            // tilde1 is a modified version of a glyph from the MnSymbol package
            tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
            // ditto tilde2, tilde3, & tilde4
            tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
            tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
            tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
            // vec is from glyph U+20D7 in font KaTeX Main
            vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
            // widehat1 is a modified version of a glyph from the MnSymbol package
            widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
            // ditto widehat2, widehat3, & widehat4
            widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
            widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
            widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
            // widecheck paths are all inverted versions of widehat
            widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
            widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
            widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
            widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
            // The next ten paths support reaction arrows from the mhchem package.
            // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
            // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
            baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
            // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
            rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
            // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
            // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
            baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
            rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
            shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
            shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
          }, a2 = function(a, u) {
            switch (a) {
              case "lbrack":
                return "M403 1759 V84 H666 V0 H319 V1759 v" + u + ` v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v` + u + " v1759 h84z";
              case "rbrack":
                return "M347 1759 V0 H0 V84 H263 V1759 v" + u + ` v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v` + u + " v1759 h84z";
              case "vert":
                return "M145 15 v585 v" + u + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -u + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + u + " v585 h43z";
              case "doublevert":
                return "M145 15 v585 v" + u + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -u + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + u + ` v585 h43z
M367 15 v585 v` + u + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -u + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v` + u + " v585 h43z";
              case "lfloor":
                return "M319 602 V0 H403 V602 v" + u + ` v1715 h263 v84 H319z
MM319 602 V0 H403 V602 v` + u + " v1715 H319z";
              case "rfloor":
                return "M319 602 V0 H403 V602 v" + u + ` v1799 H0 v-84 H319z
MM319 602 V0 H403 V602 v` + u + " v1715 H319z";
              case "lceil":
                return "M403 1759 V84 H666 V0 H319 V1759 v" + u + ` v602 h84z
M403 1759 V0 H319 V1759 v` + u + " v602 h84z";
              case "rceil":
                return "M347 1759 V0 H0 V84 H263 V1759 v" + u + ` v602 h84z
M347 1759 V0 h-84 V1759 v` + u + " v602 h84z";
              case "lparen":
                return `M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
-36,557 l0,` + (u + 84) + `c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
l0,-` + (u + 92) + `c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z`;
              case "rparen":
                return `M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,` + (u + 9) + `
c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
l0,-` + (u + 144) + `c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z`;
              default:
                throw new Error("Unknown stretchy delimiter.");
            }
          };
          class fi {
            // HtmlDomNode
            // Never used; needed for satisfying interface.
            constructor(u) {
              this.children = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.children = u, this.classes = [], this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = {};
            }
            hasClass(u) {
              return D.contains(this.classes, u);
            }
            /** Convert the fragment into a node. */
            toNode() {
              const u = document.createDocumentFragment();
              for (let c = 0; c < this.children.length; c++)
                u.appendChild(this.children[c].toNode());
              return u;
            }
            /** Convert the fragment into HTML markup. */
            toMarkup() {
              let u = "";
              for (let c = 0; c < this.children.length; c++)
                u += this.children[c].toMarkup();
              return u;
            }
            /**
             * Converts the math node into a string, similar to innerText. Applies to
             * MathDomNode's only.
             */
            toText() {
              const u = (c) => c.toText();
              return this.children.map(u).join("");
            }
          }
          var sn = {
            "AMS-Regular": {
              32: [0, 0, 0, 0, 0.25],
              65: [0, 0.68889, 0, 0, 0.72222],
              66: [0, 0.68889, 0, 0, 0.66667],
              67: [0, 0.68889, 0, 0, 0.72222],
              68: [0, 0.68889, 0, 0, 0.72222],
              69: [0, 0.68889, 0, 0, 0.66667],
              70: [0, 0.68889, 0, 0, 0.61111],
              71: [0, 0.68889, 0, 0, 0.77778],
              72: [0, 0.68889, 0, 0, 0.77778],
              73: [0, 0.68889, 0, 0, 0.38889],
              74: [0.16667, 0.68889, 0, 0, 0.5],
              75: [0, 0.68889, 0, 0, 0.77778],
              76: [0, 0.68889, 0, 0, 0.66667],
              77: [0, 0.68889, 0, 0, 0.94445],
              78: [0, 0.68889, 0, 0, 0.72222],
              79: [0.16667, 0.68889, 0, 0, 0.77778],
              80: [0, 0.68889, 0, 0, 0.61111],
              81: [0.16667, 0.68889, 0, 0, 0.77778],
              82: [0, 0.68889, 0, 0, 0.72222],
              83: [0, 0.68889, 0, 0, 0.55556],
              84: [0, 0.68889, 0, 0, 0.66667],
              85: [0, 0.68889, 0, 0, 0.72222],
              86: [0, 0.68889, 0, 0, 0.72222],
              87: [0, 0.68889, 0, 0, 1],
              88: [0, 0.68889, 0, 0, 0.72222],
              89: [0, 0.68889, 0, 0, 0.72222],
              90: [0, 0.68889, 0, 0, 0.66667],
              107: [0, 0.68889, 0, 0, 0.55556],
              160: [0, 0, 0, 0, 0.25],
              165: [0, 0.675, 0.025, 0, 0.75],
              174: [0.15559, 0.69224, 0, 0, 0.94666],
              240: [0, 0.68889, 0, 0, 0.55556],
              295: [0, 0.68889, 0, 0, 0.54028],
              710: [0, 0.825, 0, 0, 2.33334],
              732: [0, 0.9, 0, 0, 2.33334],
              770: [0, 0.825, 0, 0, 2.33334],
              771: [0, 0.9, 0, 0, 2.33334],
              989: [0.08167, 0.58167, 0, 0, 0.77778],
              1008: [0, 0.43056, 0.04028, 0, 0.66667],
              8245: [0, 0.54986, 0, 0, 0.275],
              8463: [0, 0.68889, 0, 0, 0.54028],
              8487: [0, 0.68889, 0, 0, 0.72222],
              8498: [0, 0.68889, 0, 0, 0.55556],
              8502: [0, 0.68889, 0, 0, 0.66667],
              8503: [0, 0.68889, 0, 0, 0.44445],
              8504: [0, 0.68889, 0, 0, 0.66667],
              8513: [0, 0.68889, 0, 0, 0.63889],
              8592: [-0.03598, 0.46402, 0, 0, 0.5],
              8594: [-0.03598, 0.46402, 0, 0, 0.5],
              8602: [-0.13313, 0.36687, 0, 0, 1],
              8603: [-0.13313, 0.36687, 0, 0, 1],
              8606: [0.01354, 0.52239, 0, 0, 1],
              8608: [0.01354, 0.52239, 0, 0, 1],
              8610: [0.01354, 0.52239, 0, 0, 1.11111],
              8611: [0.01354, 0.52239, 0, 0, 1.11111],
              8619: [0, 0.54986, 0, 0, 1],
              8620: [0, 0.54986, 0, 0, 1],
              8621: [-0.13313, 0.37788, 0, 0, 1.38889],
              8622: [-0.13313, 0.36687, 0, 0, 1],
              8624: [0, 0.69224, 0, 0, 0.5],
              8625: [0, 0.69224, 0, 0, 0.5],
              8630: [0, 0.43056, 0, 0, 1],
              8631: [0, 0.43056, 0, 0, 1],
              8634: [0.08198, 0.58198, 0, 0, 0.77778],
              8635: [0.08198, 0.58198, 0, 0, 0.77778],
              8638: [0.19444, 0.69224, 0, 0, 0.41667],
              8639: [0.19444, 0.69224, 0, 0, 0.41667],
              8642: [0.19444, 0.69224, 0, 0, 0.41667],
              8643: [0.19444, 0.69224, 0, 0, 0.41667],
              8644: [0.1808, 0.675, 0, 0, 1],
              8646: [0.1808, 0.675, 0, 0, 1],
              8647: [0.1808, 0.675, 0, 0, 1],
              8648: [0.19444, 0.69224, 0, 0, 0.83334],
              8649: [0.1808, 0.675, 0, 0, 1],
              8650: [0.19444, 0.69224, 0, 0, 0.83334],
              8651: [0.01354, 0.52239, 0, 0, 1],
              8652: [0.01354, 0.52239, 0, 0, 1],
              8653: [-0.13313, 0.36687, 0, 0, 1],
              8654: [-0.13313, 0.36687, 0, 0, 1],
              8655: [-0.13313, 0.36687, 0, 0, 1],
              8666: [0.13667, 0.63667, 0, 0, 1],
              8667: [0.13667, 0.63667, 0, 0, 1],
              8669: [-0.13313, 0.37788, 0, 0, 1],
              8672: [-0.064, 0.437, 0, 0, 1.334],
              8674: [-0.064, 0.437, 0, 0, 1.334],
              8705: [0, 0.825, 0, 0, 0.5],
              8708: [0, 0.68889, 0, 0, 0.55556],
              8709: [0.08167, 0.58167, 0, 0, 0.77778],
              8717: [0, 0.43056, 0, 0, 0.42917],
              8722: [-0.03598, 0.46402, 0, 0, 0.5],
              8724: [0.08198, 0.69224, 0, 0, 0.77778],
              8726: [0.08167, 0.58167, 0, 0, 0.77778],
              8733: [0, 0.69224, 0, 0, 0.77778],
              8736: [0, 0.69224, 0, 0, 0.72222],
              8737: [0, 0.69224, 0, 0, 0.72222],
              8738: [0.03517, 0.52239, 0, 0, 0.72222],
              8739: [0.08167, 0.58167, 0, 0, 0.22222],
              8740: [0.25142, 0.74111, 0, 0, 0.27778],
              8741: [0.08167, 0.58167, 0, 0, 0.38889],
              8742: [0.25142, 0.74111, 0, 0, 0.5],
              8756: [0, 0.69224, 0, 0, 0.66667],
              8757: [0, 0.69224, 0, 0, 0.66667],
              8764: [-0.13313, 0.36687, 0, 0, 0.77778],
              8765: [-0.13313, 0.37788, 0, 0, 0.77778],
              8769: [-0.13313, 0.36687, 0, 0, 0.77778],
              8770: [-0.03625, 0.46375, 0, 0, 0.77778],
              8774: [0.30274, 0.79383, 0, 0, 0.77778],
              8776: [-0.01688, 0.48312, 0, 0, 0.77778],
              8778: [0.08167, 0.58167, 0, 0, 0.77778],
              8782: [0.06062, 0.54986, 0, 0, 0.77778],
              8783: [0.06062, 0.54986, 0, 0, 0.77778],
              8785: [0.08198, 0.58198, 0, 0, 0.77778],
              8786: [0.08198, 0.58198, 0, 0, 0.77778],
              8787: [0.08198, 0.58198, 0, 0, 0.77778],
              8790: [0, 0.69224, 0, 0, 0.77778],
              8791: [0.22958, 0.72958, 0, 0, 0.77778],
              8796: [0.08198, 0.91667, 0, 0, 0.77778],
              8806: [0.25583, 0.75583, 0, 0, 0.77778],
              8807: [0.25583, 0.75583, 0, 0, 0.77778],
              8808: [0.25142, 0.75726, 0, 0, 0.77778],
              8809: [0.25142, 0.75726, 0, 0, 0.77778],
              8812: [0.25583, 0.75583, 0, 0, 0.5],
              8814: [0.20576, 0.70576, 0, 0, 0.77778],
              8815: [0.20576, 0.70576, 0, 0, 0.77778],
              8816: [0.30274, 0.79383, 0, 0, 0.77778],
              8817: [0.30274, 0.79383, 0, 0, 0.77778],
              8818: [0.22958, 0.72958, 0, 0, 0.77778],
              8819: [0.22958, 0.72958, 0, 0, 0.77778],
              8822: [0.1808, 0.675, 0, 0, 0.77778],
              8823: [0.1808, 0.675, 0, 0, 0.77778],
              8828: [0.13667, 0.63667, 0, 0, 0.77778],
              8829: [0.13667, 0.63667, 0, 0, 0.77778],
              8830: [0.22958, 0.72958, 0, 0, 0.77778],
              8831: [0.22958, 0.72958, 0, 0, 0.77778],
              8832: [0.20576, 0.70576, 0, 0, 0.77778],
              8833: [0.20576, 0.70576, 0, 0, 0.77778],
              8840: [0.30274, 0.79383, 0, 0, 0.77778],
              8841: [0.30274, 0.79383, 0, 0, 0.77778],
              8842: [0.13597, 0.63597, 0, 0, 0.77778],
              8843: [0.13597, 0.63597, 0, 0, 0.77778],
              8847: [0.03517, 0.54986, 0, 0, 0.77778],
              8848: [0.03517, 0.54986, 0, 0, 0.77778],
              8858: [0.08198, 0.58198, 0, 0, 0.77778],
              8859: [0.08198, 0.58198, 0, 0, 0.77778],
              8861: [0.08198, 0.58198, 0, 0, 0.77778],
              8862: [0, 0.675, 0, 0, 0.77778],
              8863: [0, 0.675, 0, 0, 0.77778],
              8864: [0, 0.675, 0, 0, 0.77778],
              8865: [0, 0.675, 0, 0, 0.77778],
              8872: [0, 0.69224, 0, 0, 0.61111],
              8873: [0, 0.69224, 0, 0, 0.72222],
              8874: [0, 0.69224, 0, 0, 0.88889],
              8876: [0, 0.68889, 0, 0, 0.61111],
              8877: [0, 0.68889, 0, 0, 0.61111],
              8878: [0, 0.68889, 0, 0, 0.72222],
              8879: [0, 0.68889, 0, 0, 0.72222],
              8882: [0.03517, 0.54986, 0, 0, 0.77778],
              8883: [0.03517, 0.54986, 0, 0, 0.77778],
              8884: [0.13667, 0.63667, 0, 0, 0.77778],
              8885: [0.13667, 0.63667, 0, 0, 0.77778],
              8888: [0, 0.54986, 0, 0, 1.11111],
              8890: [0.19444, 0.43056, 0, 0, 0.55556],
              8891: [0.19444, 0.69224, 0, 0, 0.61111],
              8892: [0.19444, 0.69224, 0, 0, 0.61111],
              8901: [0, 0.54986, 0, 0, 0.27778],
              8903: [0.08167, 0.58167, 0, 0, 0.77778],
              8905: [0.08167, 0.58167, 0, 0, 0.77778],
              8906: [0.08167, 0.58167, 0, 0, 0.77778],
              8907: [0, 0.69224, 0, 0, 0.77778],
              8908: [0, 0.69224, 0, 0, 0.77778],
              8909: [-0.03598, 0.46402, 0, 0, 0.77778],
              8910: [0, 0.54986, 0, 0, 0.76042],
              8911: [0, 0.54986, 0, 0, 0.76042],
              8912: [0.03517, 0.54986, 0, 0, 0.77778],
              8913: [0.03517, 0.54986, 0, 0, 0.77778],
              8914: [0, 0.54986, 0, 0, 0.66667],
              8915: [0, 0.54986, 0, 0, 0.66667],
              8916: [0, 0.69224, 0, 0, 0.66667],
              8918: [0.0391, 0.5391, 0, 0, 0.77778],
              8919: [0.0391, 0.5391, 0, 0, 0.77778],
              8920: [0.03517, 0.54986, 0, 0, 1.33334],
              8921: [0.03517, 0.54986, 0, 0, 1.33334],
              8922: [0.38569, 0.88569, 0, 0, 0.77778],
              8923: [0.38569, 0.88569, 0, 0, 0.77778],
              8926: [0.13667, 0.63667, 0, 0, 0.77778],
              8927: [0.13667, 0.63667, 0, 0, 0.77778],
              8928: [0.30274, 0.79383, 0, 0, 0.77778],
              8929: [0.30274, 0.79383, 0, 0, 0.77778],
              8934: [0.23222, 0.74111, 0, 0, 0.77778],
              8935: [0.23222, 0.74111, 0, 0, 0.77778],
              8936: [0.23222, 0.74111, 0, 0, 0.77778],
              8937: [0.23222, 0.74111, 0, 0, 0.77778],
              8938: [0.20576, 0.70576, 0, 0, 0.77778],
              8939: [0.20576, 0.70576, 0, 0, 0.77778],
              8940: [0.30274, 0.79383, 0, 0, 0.77778],
              8941: [0.30274, 0.79383, 0, 0, 0.77778],
              8994: [0.19444, 0.69224, 0, 0, 0.77778],
              8995: [0.19444, 0.69224, 0, 0, 0.77778],
              9416: [0.15559, 0.69224, 0, 0, 0.90222],
              9484: [0, 0.69224, 0, 0, 0.5],
              9488: [0, 0.69224, 0, 0, 0.5],
              9492: [0, 0.37788, 0, 0, 0.5],
              9496: [0, 0.37788, 0, 0, 0.5],
              9585: [0.19444, 0.68889, 0, 0, 0.88889],
              9586: [0.19444, 0.74111, 0, 0, 0.88889],
              9632: [0, 0.675, 0, 0, 0.77778],
              9633: [0, 0.675, 0, 0, 0.77778],
              9650: [0, 0.54986, 0, 0, 0.72222],
              9651: [0, 0.54986, 0, 0, 0.72222],
              9654: [0.03517, 0.54986, 0, 0, 0.77778],
              9660: [0, 0.54986, 0, 0, 0.72222],
              9661: [0, 0.54986, 0, 0, 0.72222],
              9664: [0.03517, 0.54986, 0, 0, 0.77778],
              9674: [0.11111, 0.69224, 0, 0, 0.66667],
              9733: [0.19444, 0.69224, 0, 0, 0.94445],
              10003: [0, 0.69224, 0, 0, 0.83334],
              10016: [0, 0.69224, 0, 0, 0.83334],
              10731: [0.11111, 0.69224, 0, 0, 0.66667],
              10846: [0.19444, 0.75583, 0, 0, 0.61111],
              10877: [0.13667, 0.63667, 0, 0, 0.77778],
              10878: [0.13667, 0.63667, 0, 0, 0.77778],
              10885: [0.25583, 0.75583, 0, 0, 0.77778],
              10886: [0.25583, 0.75583, 0, 0, 0.77778],
              10887: [0.13597, 0.63597, 0, 0, 0.77778],
              10888: [0.13597, 0.63597, 0, 0, 0.77778],
              10889: [0.26167, 0.75726, 0, 0, 0.77778],
              10890: [0.26167, 0.75726, 0, 0, 0.77778],
              10891: [0.48256, 0.98256, 0, 0, 0.77778],
              10892: [0.48256, 0.98256, 0, 0, 0.77778],
              10901: [0.13667, 0.63667, 0, 0, 0.77778],
              10902: [0.13667, 0.63667, 0, 0, 0.77778],
              10933: [0.25142, 0.75726, 0, 0, 0.77778],
              10934: [0.25142, 0.75726, 0, 0, 0.77778],
              10935: [0.26167, 0.75726, 0, 0, 0.77778],
              10936: [0.26167, 0.75726, 0, 0, 0.77778],
              10937: [0.26167, 0.75726, 0, 0, 0.77778],
              10938: [0.26167, 0.75726, 0, 0, 0.77778],
              10949: [0.25583, 0.75583, 0, 0, 0.77778],
              10950: [0.25583, 0.75583, 0, 0, 0.77778],
              10955: [0.28481, 0.79383, 0, 0, 0.77778],
              10956: [0.28481, 0.79383, 0, 0, 0.77778],
              57350: [0.08167, 0.58167, 0, 0, 0.22222],
              57351: [0.08167, 0.58167, 0, 0, 0.38889],
              57352: [0.08167, 0.58167, 0, 0, 0.77778],
              57353: [0, 0.43056, 0.04028, 0, 0.66667],
              57356: [0.25142, 0.75726, 0, 0, 0.77778],
              57357: [0.25142, 0.75726, 0, 0, 0.77778],
              57358: [0.41951, 0.91951, 0, 0, 0.77778],
              57359: [0.30274, 0.79383, 0, 0, 0.77778],
              57360: [0.30274, 0.79383, 0, 0, 0.77778],
              57361: [0.41951, 0.91951, 0, 0, 0.77778],
              57366: [0.25142, 0.75726, 0, 0, 0.77778],
              57367: [0.25142, 0.75726, 0, 0, 0.77778],
              57368: [0.25142, 0.75726, 0, 0, 0.77778],
              57369: [0.25142, 0.75726, 0, 0, 0.77778],
              57370: [0.13597, 0.63597, 0, 0, 0.77778],
              57371: [0.13597, 0.63597, 0, 0, 0.77778]
            },
            "Caligraphic-Regular": {
              32: [0, 0, 0, 0, 0.25],
              65: [0, 0.68333, 0, 0.19445, 0.79847],
              66: [0, 0.68333, 0.03041, 0.13889, 0.65681],
              67: [0, 0.68333, 0.05834, 0.13889, 0.52653],
              68: [0, 0.68333, 0.02778, 0.08334, 0.77139],
              69: [0, 0.68333, 0.08944, 0.11111, 0.52778],
              70: [0, 0.68333, 0.09931, 0.11111, 0.71875],
              71: [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
              72: [0, 0.68333, 965e-5, 0.11111, 0.84452],
              73: [0, 0.68333, 0.07382, 0, 0.54452],
              74: [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
              75: [0, 0.68333, 0.01445, 0.05556, 0.76195],
              76: [0, 0.68333, 0, 0.13889, 0.68972],
              77: [0, 0.68333, 0, 0.13889, 1.2009],
              78: [0, 0.68333, 0.14736, 0.08334, 0.82049],
              79: [0, 0.68333, 0.02778, 0.11111, 0.79611],
              80: [0, 0.68333, 0.08222, 0.08334, 0.69556],
              81: [0.09722, 0.68333, 0, 0.11111, 0.81667],
              82: [0, 0.68333, 0, 0.08334, 0.8475],
              83: [0, 0.68333, 0.075, 0.13889, 0.60556],
              84: [0, 0.68333, 0.25417, 0, 0.54464],
              85: [0, 0.68333, 0.09931, 0.08334, 0.62583],
              86: [0, 0.68333, 0.08222, 0, 0.61278],
              87: [0, 0.68333, 0.08222, 0.08334, 0.98778],
              88: [0, 0.68333, 0.14643, 0.13889, 0.7133],
              89: [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
              90: [0, 0.68333, 0.07944, 0.13889, 0.72473],
              160: [0, 0, 0, 0, 0.25]
            },
            "Fraktur-Regular": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69141, 0, 0, 0.29574],
              34: [0, 0.69141, 0, 0, 0.21471],
              38: [0, 0.69141, 0, 0, 0.73786],
              39: [0, 0.69141, 0, 0, 0.21201],
              40: [0.24982, 0.74947, 0, 0, 0.38865],
              41: [0.24982, 0.74947, 0, 0, 0.38865],
              42: [0, 0.62119, 0, 0, 0.27764],
              43: [0.08319, 0.58283, 0, 0, 0.75623],
              44: [0, 0.10803, 0, 0, 0.27764],
              45: [0.08319, 0.58283, 0, 0, 0.75623],
              46: [0, 0.10803, 0, 0, 0.27764],
              47: [0.24982, 0.74947, 0, 0, 0.50181],
              48: [0, 0.47534, 0, 0, 0.50181],
              49: [0, 0.47534, 0, 0, 0.50181],
              50: [0, 0.47534, 0, 0, 0.50181],
              51: [0.18906, 0.47534, 0, 0, 0.50181],
              52: [0.18906, 0.47534, 0, 0, 0.50181],
              53: [0.18906, 0.47534, 0, 0, 0.50181],
              54: [0, 0.69141, 0, 0, 0.50181],
              55: [0.18906, 0.47534, 0, 0, 0.50181],
              56: [0, 0.69141, 0, 0, 0.50181],
              57: [0.18906, 0.47534, 0, 0, 0.50181],
              58: [0, 0.47534, 0, 0, 0.21606],
              59: [0.12604, 0.47534, 0, 0, 0.21606],
              61: [-0.13099, 0.36866, 0, 0, 0.75623],
              63: [0, 0.69141, 0, 0, 0.36245],
              65: [0, 0.69141, 0, 0, 0.7176],
              66: [0, 0.69141, 0, 0, 0.88397],
              67: [0, 0.69141, 0, 0, 0.61254],
              68: [0, 0.69141, 0, 0, 0.83158],
              69: [0, 0.69141, 0, 0, 0.66278],
              70: [0.12604, 0.69141, 0, 0, 0.61119],
              71: [0, 0.69141, 0, 0, 0.78539],
              72: [0.06302, 0.69141, 0, 0, 0.7203],
              73: [0, 0.69141, 0, 0, 0.55448],
              74: [0.12604, 0.69141, 0, 0, 0.55231],
              75: [0, 0.69141, 0, 0, 0.66845],
              76: [0, 0.69141, 0, 0, 0.66602],
              77: [0, 0.69141, 0, 0, 1.04953],
              78: [0, 0.69141, 0, 0, 0.83212],
              79: [0, 0.69141, 0, 0, 0.82699],
              80: [0.18906, 0.69141, 0, 0, 0.82753],
              81: [0.03781, 0.69141, 0, 0, 0.82699],
              82: [0, 0.69141, 0, 0, 0.82807],
              83: [0, 0.69141, 0, 0, 0.82861],
              84: [0, 0.69141, 0, 0, 0.66899],
              85: [0, 0.69141, 0, 0, 0.64576],
              86: [0, 0.69141, 0, 0, 0.83131],
              87: [0, 0.69141, 0, 0, 1.04602],
              88: [0, 0.69141, 0, 0, 0.71922],
              89: [0.18906, 0.69141, 0, 0, 0.83293],
              90: [0.12604, 0.69141, 0, 0, 0.60201],
              91: [0.24982, 0.74947, 0, 0, 0.27764],
              93: [0.24982, 0.74947, 0, 0, 0.27764],
              94: [0, 0.69141, 0, 0, 0.49965],
              97: [0, 0.47534, 0, 0, 0.50046],
              98: [0, 0.69141, 0, 0, 0.51315],
              99: [0, 0.47534, 0, 0, 0.38946],
              100: [0, 0.62119, 0, 0, 0.49857],
              101: [0, 0.47534, 0, 0, 0.40053],
              102: [0.18906, 0.69141, 0, 0, 0.32626],
              103: [0.18906, 0.47534, 0, 0, 0.5037],
              104: [0.18906, 0.69141, 0, 0, 0.52126],
              105: [0, 0.69141, 0, 0, 0.27899],
              106: [0, 0.69141, 0, 0, 0.28088],
              107: [0, 0.69141, 0, 0, 0.38946],
              108: [0, 0.69141, 0, 0, 0.27953],
              109: [0, 0.47534, 0, 0, 0.76676],
              110: [0, 0.47534, 0, 0, 0.52666],
              111: [0, 0.47534, 0, 0, 0.48885],
              112: [0.18906, 0.52396, 0, 0, 0.50046],
              113: [0.18906, 0.47534, 0, 0, 0.48912],
              114: [0, 0.47534, 0, 0, 0.38919],
              115: [0, 0.47534, 0, 0, 0.44266],
              116: [0, 0.62119, 0, 0, 0.33301],
              117: [0, 0.47534, 0, 0, 0.5172],
              118: [0, 0.52396, 0, 0, 0.5118],
              119: [0, 0.52396, 0, 0, 0.77351],
              120: [0.18906, 0.47534, 0, 0, 0.38865],
              121: [0.18906, 0.47534, 0, 0, 0.49884],
              122: [0.18906, 0.47534, 0, 0, 0.39054],
              160: [0, 0, 0, 0, 0.25],
              8216: [0, 0.69141, 0, 0, 0.21471],
              8217: [0, 0.69141, 0, 0, 0.21471],
              58112: [0, 0.62119, 0, 0, 0.49749],
              58113: [0, 0.62119, 0, 0, 0.4983],
              58114: [0.18906, 0.69141, 0, 0, 0.33328],
              58115: [0.18906, 0.69141, 0, 0, 0.32923],
              58116: [0.18906, 0.47534, 0, 0, 0.50343],
              58117: [0, 0.69141, 0, 0, 0.33301],
              58118: [0, 0.62119, 0, 0, 0.33409],
              58119: [0, 0.47534, 0, 0, 0.50073]
            },
            "Main-Bold": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69444, 0, 0, 0.35],
              34: [0, 0.69444, 0, 0, 0.60278],
              35: [0.19444, 0.69444, 0, 0, 0.95833],
              36: [0.05556, 0.75, 0, 0, 0.575],
              37: [0.05556, 0.75, 0, 0, 0.95833],
              38: [0, 0.69444, 0, 0, 0.89444],
              39: [0, 0.69444, 0, 0, 0.31944],
              40: [0.25, 0.75, 0, 0, 0.44722],
              41: [0.25, 0.75, 0, 0, 0.44722],
              42: [0, 0.75, 0, 0, 0.575],
              43: [0.13333, 0.63333, 0, 0, 0.89444],
              44: [0.19444, 0.15556, 0, 0, 0.31944],
              45: [0, 0.44444, 0, 0, 0.38333],
              46: [0, 0.15556, 0, 0, 0.31944],
              47: [0.25, 0.75, 0, 0, 0.575],
              48: [0, 0.64444, 0, 0, 0.575],
              49: [0, 0.64444, 0, 0, 0.575],
              50: [0, 0.64444, 0, 0, 0.575],
              51: [0, 0.64444, 0, 0, 0.575],
              52: [0, 0.64444, 0, 0, 0.575],
              53: [0, 0.64444, 0, 0, 0.575],
              54: [0, 0.64444, 0, 0, 0.575],
              55: [0, 0.64444, 0, 0, 0.575],
              56: [0, 0.64444, 0, 0, 0.575],
              57: [0, 0.64444, 0, 0, 0.575],
              58: [0, 0.44444, 0, 0, 0.31944],
              59: [0.19444, 0.44444, 0, 0, 0.31944],
              60: [0.08556, 0.58556, 0, 0, 0.89444],
              61: [-0.10889, 0.39111, 0, 0, 0.89444],
              62: [0.08556, 0.58556, 0, 0, 0.89444],
              63: [0, 0.69444, 0, 0, 0.54305],
              64: [0, 0.69444, 0, 0, 0.89444],
              65: [0, 0.68611, 0, 0, 0.86944],
              66: [0, 0.68611, 0, 0, 0.81805],
              67: [0, 0.68611, 0, 0, 0.83055],
              68: [0, 0.68611, 0, 0, 0.88194],
              69: [0, 0.68611, 0, 0, 0.75555],
              70: [0, 0.68611, 0, 0, 0.72361],
              71: [0, 0.68611, 0, 0, 0.90416],
              72: [0, 0.68611, 0, 0, 0.9],
              73: [0, 0.68611, 0, 0, 0.43611],
              74: [0, 0.68611, 0, 0, 0.59444],
              75: [0, 0.68611, 0, 0, 0.90138],
              76: [0, 0.68611, 0, 0, 0.69166],
              77: [0, 0.68611, 0, 0, 1.09166],
              78: [0, 0.68611, 0, 0, 0.9],
              79: [0, 0.68611, 0, 0, 0.86388],
              80: [0, 0.68611, 0, 0, 0.78611],
              81: [0.19444, 0.68611, 0, 0, 0.86388],
              82: [0, 0.68611, 0, 0, 0.8625],
              83: [0, 0.68611, 0, 0, 0.63889],
              84: [0, 0.68611, 0, 0, 0.8],
              85: [0, 0.68611, 0, 0, 0.88472],
              86: [0, 0.68611, 0.01597, 0, 0.86944],
              87: [0, 0.68611, 0.01597, 0, 1.18888],
              88: [0, 0.68611, 0, 0, 0.86944],
              89: [0, 0.68611, 0.02875, 0, 0.86944],
              90: [0, 0.68611, 0, 0, 0.70277],
              91: [0.25, 0.75, 0, 0, 0.31944],
              92: [0.25, 0.75, 0, 0, 0.575],
              93: [0.25, 0.75, 0, 0, 0.31944],
              94: [0, 0.69444, 0, 0, 0.575],
              95: [0.31, 0.13444, 0.03194, 0, 0.575],
              97: [0, 0.44444, 0, 0, 0.55902],
              98: [0, 0.69444, 0, 0, 0.63889],
              99: [0, 0.44444, 0, 0, 0.51111],
              100: [0, 0.69444, 0, 0, 0.63889],
              101: [0, 0.44444, 0, 0, 0.52708],
              102: [0, 0.69444, 0.10903, 0, 0.35139],
              103: [0.19444, 0.44444, 0.01597, 0, 0.575],
              104: [0, 0.69444, 0, 0, 0.63889],
              105: [0, 0.69444, 0, 0, 0.31944],
              106: [0.19444, 0.69444, 0, 0, 0.35139],
              107: [0, 0.69444, 0, 0, 0.60694],
              108: [0, 0.69444, 0, 0, 0.31944],
              109: [0, 0.44444, 0, 0, 0.95833],
              110: [0, 0.44444, 0, 0, 0.63889],
              111: [0, 0.44444, 0, 0, 0.575],
              112: [0.19444, 0.44444, 0, 0, 0.63889],
              113: [0.19444, 0.44444, 0, 0, 0.60694],
              114: [0, 0.44444, 0, 0, 0.47361],
              115: [0, 0.44444, 0, 0, 0.45361],
              116: [0, 0.63492, 0, 0, 0.44722],
              117: [0, 0.44444, 0, 0, 0.63889],
              118: [0, 0.44444, 0.01597, 0, 0.60694],
              119: [0, 0.44444, 0.01597, 0, 0.83055],
              120: [0, 0.44444, 0, 0, 0.60694],
              121: [0.19444, 0.44444, 0.01597, 0, 0.60694],
              122: [0, 0.44444, 0, 0, 0.51111],
              123: [0.25, 0.75, 0, 0, 0.575],
              124: [0.25, 0.75, 0, 0, 0.31944],
              125: [0.25, 0.75, 0, 0, 0.575],
              126: [0.35, 0.34444, 0, 0, 0.575],
              160: [0, 0, 0, 0, 0.25],
              163: [0, 0.69444, 0, 0, 0.86853],
              168: [0, 0.69444, 0, 0, 0.575],
              172: [0, 0.44444, 0, 0, 0.76666],
              176: [0, 0.69444, 0, 0, 0.86944],
              177: [0.13333, 0.63333, 0, 0, 0.89444],
              184: [0.17014, 0, 0, 0, 0.51111],
              198: [0, 0.68611, 0, 0, 1.04166],
              215: [0.13333, 0.63333, 0, 0, 0.89444],
              216: [0.04861, 0.73472, 0, 0, 0.89444],
              223: [0, 0.69444, 0, 0, 0.59722],
              230: [0, 0.44444, 0, 0, 0.83055],
              247: [0.13333, 0.63333, 0, 0, 0.89444],
              248: [0.09722, 0.54167, 0, 0, 0.575],
              305: [0, 0.44444, 0, 0, 0.31944],
              338: [0, 0.68611, 0, 0, 1.16944],
              339: [0, 0.44444, 0, 0, 0.89444],
              567: [0.19444, 0.44444, 0, 0, 0.35139],
              710: [0, 0.69444, 0, 0, 0.575],
              711: [0, 0.63194, 0, 0, 0.575],
              713: [0, 0.59611, 0, 0, 0.575],
              714: [0, 0.69444, 0, 0, 0.575],
              715: [0, 0.69444, 0, 0, 0.575],
              728: [0, 0.69444, 0, 0, 0.575],
              729: [0, 0.69444, 0, 0, 0.31944],
              730: [0, 0.69444, 0, 0, 0.86944],
              732: [0, 0.69444, 0, 0, 0.575],
              733: [0, 0.69444, 0, 0, 0.575],
              915: [0, 0.68611, 0, 0, 0.69166],
              916: [0, 0.68611, 0, 0, 0.95833],
              920: [0, 0.68611, 0, 0, 0.89444],
              923: [0, 0.68611, 0, 0, 0.80555],
              926: [0, 0.68611, 0, 0, 0.76666],
              928: [0, 0.68611, 0, 0, 0.9],
              931: [0, 0.68611, 0, 0, 0.83055],
              933: [0, 0.68611, 0, 0, 0.89444],
              934: [0, 0.68611, 0, 0, 0.83055],
              936: [0, 0.68611, 0, 0, 0.89444],
              937: [0, 0.68611, 0, 0, 0.83055],
              8211: [0, 0.44444, 0.03194, 0, 0.575],
              8212: [0, 0.44444, 0.03194, 0, 1.14999],
              8216: [0, 0.69444, 0, 0, 0.31944],
              8217: [0, 0.69444, 0, 0, 0.31944],
              8220: [0, 0.69444, 0, 0, 0.60278],
              8221: [0, 0.69444, 0, 0, 0.60278],
              8224: [0.19444, 0.69444, 0, 0, 0.51111],
              8225: [0.19444, 0.69444, 0, 0, 0.51111],
              8242: [0, 0.55556, 0, 0, 0.34444],
              8407: [0, 0.72444, 0.15486, 0, 0.575],
              8463: [0, 0.69444, 0, 0, 0.66759],
              8465: [0, 0.69444, 0, 0, 0.83055],
              8467: [0, 0.69444, 0, 0, 0.47361],
              8472: [0.19444, 0.44444, 0, 0, 0.74027],
              8476: [0, 0.69444, 0, 0, 0.83055],
              8501: [0, 0.69444, 0, 0, 0.70277],
              8592: [-0.10889, 0.39111, 0, 0, 1.14999],
              8593: [0.19444, 0.69444, 0, 0, 0.575],
              8594: [-0.10889, 0.39111, 0, 0, 1.14999],
              8595: [0.19444, 0.69444, 0, 0, 0.575],
              8596: [-0.10889, 0.39111, 0, 0, 1.14999],
              8597: [0.25, 0.75, 0, 0, 0.575],
              8598: [0.19444, 0.69444, 0, 0, 1.14999],
              8599: [0.19444, 0.69444, 0, 0, 1.14999],
              8600: [0.19444, 0.69444, 0, 0, 1.14999],
              8601: [0.19444, 0.69444, 0, 0, 1.14999],
              8636: [-0.10889, 0.39111, 0, 0, 1.14999],
              8637: [-0.10889, 0.39111, 0, 0, 1.14999],
              8640: [-0.10889, 0.39111, 0, 0, 1.14999],
              8641: [-0.10889, 0.39111, 0, 0, 1.14999],
              8656: [-0.10889, 0.39111, 0, 0, 1.14999],
              8657: [0.19444, 0.69444, 0, 0, 0.70277],
              8658: [-0.10889, 0.39111, 0, 0, 1.14999],
              8659: [0.19444, 0.69444, 0, 0, 0.70277],
              8660: [-0.10889, 0.39111, 0, 0, 1.14999],
              8661: [0.25, 0.75, 0, 0, 0.70277],
              8704: [0, 0.69444, 0, 0, 0.63889],
              8706: [0, 0.69444, 0.06389, 0, 0.62847],
              8707: [0, 0.69444, 0, 0, 0.63889],
              8709: [0.05556, 0.75, 0, 0, 0.575],
              8711: [0, 0.68611, 0, 0, 0.95833],
              8712: [0.08556, 0.58556, 0, 0, 0.76666],
              8715: [0.08556, 0.58556, 0, 0, 0.76666],
              8722: [0.13333, 0.63333, 0, 0, 0.89444],
              8723: [0.13333, 0.63333, 0, 0, 0.89444],
              8725: [0.25, 0.75, 0, 0, 0.575],
              8726: [0.25, 0.75, 0, 0, 0.575],
              8727: [-0.02778, 0.47222, 0, 0, 0.575],
              8728: [-0.02639, 0.47361, 0, 0, 0.575],
              8729: [-0.02639, 0.47361, 0, 0, 0.575],
              8730: [0.18, 0.82, 0, 0, 0.95833],
              8733: [0, 0.44444, 0, 0, 0.89444],
              8734: [0, 0.44444, 0, 0, 1.14999],
              8736: [0, 0.69224, 0, 0, 0.72222],
              8739: [0.25, 0.75, 0, 0, 0.31944],
              8741: [0.25, 0.75, 0, 0, 0.575],
              8743: [0, 0.55556, 0, 0, 0.76666],
              8744: [0, 0.55556, 0, 0, 0.76666],
              8745: [0, 0.55556, 0, 0, 0.76666],
              8746: [0, 0.55556, 0, 0, 0.76666],
              8747: [0.19444, 0.69444, 0.12778, 0, 0.56875],
              8764: [-0.10889, 0.39111, 0, 0, 0.89444],
              8768: [0.19444, 0.69444, 0, 0, 0.31944],
              8771: [222e-5, 0.50222, 0, 0, 0.89444],
              8773: [0.027, 0.638, 0, 0, 0.894],
              8776: [0.02444, 0.52444, 0, 0, 0.89444],
              8781: [222e-5, 0.50222, 0, 0, 0.89444],
              8801: [222e-5, 0.50222, 0, 0, 0.89444],
              8804: [0.19667, 0.69667, 0, 0, 0.89444],
              8805: [0.19667, 0.69667, 0, 0, 0.89444],
              8810: [0.08556, 0.58556, 0, 0, 1.14999],
              8811: [0.08556, 0.58556, 0, 0, 1.14999],
              8826: [0.08556, 0.58556, 0, 0, 0.89444],
              8827: [0.08556, 0.58556, 0, 0, 0.89444],
              8834: [0.08556, 0.58556, 0, 0, 0.89444],
              8835: [0.08556, 0.58556, 0, 0, 0.89444],
              8838: [0.19667, 0.69667, 0, 0, 0.89444],
              8839: [0.19667, 0.69667, 0, 0, 0.89444],
              8846: [0, 0.55556, 0, 0, 0.76666],
              8849: [0.19667, 0.69667, 0, 0, 0.89444],
              8850: [0.19667, 0.69667, 0, 0, 0.89444],
              8851: [0, 0.55556, 0, 0, 0.76666],
              8852: [0, 0.55556, 0, 0, 0.76666],
              8853: [0.13333, 0.63333, 0, 0, 0.89444],
              8854: [0.13333, 0.63333, 0, 0, 0.89444],
              8855: [0.13333, 0.63333, 0, 0, 0.89444],
              8856: [0.13333, 0.63333, 0, 0, 0.89444],
              8857: [0.13333, 0.63333, 0, 0, 0.89444],
              8866: [0, 0.69444, 0, 0, 0.70277],
              8867: [0, 0.69444, 0, 0, 0.70277],
              8868: [0, 0.69444, 0, 0, 0.89444],
              8869: [0, 0.69444, 0, 0, 0.89444],
              8900: [-0.02639, 0.47361, 0, 0, 0.575],
              8901: [-0.02639, 0.47361, 0, 0, 0.31944],
              8902: [-0.02778, 0.47222, 0, 0, 0.575],
              8968: [0.25, 0.75, 0, 0, 0.51111],
              8969: [0.25, 0.75, 0, 0, 0.51111],
              8970: [0.25, 0.75, 0, 0, 0.51111],
              8971: [0.25, 0.75, 0, 0, 0.51111],
              8994: [-0.13889, 0.36111, 0, 0, 1.14999],
              8995: [-0.13889, 0.36111, 0, 0, 1.14999],
              9651: [0.19444, 0.69444, 0, 0, 1.02222],
              9657: [-0.02778, 0.47222, 0, 0, 0.575],
              9661: [0.19444, 0.69444, 0, 0, 1.02222],
              9667: [-0.02778, 0.47222, 0, 0, 0.575],
              9711: [0.19444, 0.69444, 0, 0, 1.14999],
              9824: [0.12963, 0.69444, 0, 0, 0.89444],
              9825: [0.12963, 0.69444, 0, 0, 0.89444],
              9826: [0.12963, 0.69444, 0, 0, 0.89444],
              9827: [0.12963, 0.69444, 0, 0, 0.89444],
              9837: [0, 0.75, 0, 0, 0.44722],
              9838: [0.19444, 0.69444, 0, 0, 0.44722],
              9839: [0.19444, 0.69444, 0, 0, 0.44722],
              10216: [0.25, 0.75, 0, 0, 0.44722],
              10217: [0.25, 0.75, 0, 0, 0.44722],
              10815: [0, 0.68611, 0, 0, 0.9],
              10927: [0.19667, 0.69667, 0, 0, 0.89444],
              10928: [0.19667, 0.69667, 0, 0, 0.89444],
              57376: [0.19444, 0.69444, 0, 0, 0]
            },
            "Main-BoldItalic": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69444, 0.11417, 0, 0.38611],
              34: [0, 0.69444, 0.07939, 0, 0.62055],
              35: [0.19444, 0.69444, 0.06833, 0, 0.94444],
              37: [0.05556, 0.75, 0.12861, 0, 0.94444],
              38: [0, 0.69444, 0.08528, 0, 0.88555],
              39: [0, 0.69444, 0.12945, 0, 0.35555],
              40: [0.25, 0.75, 0.15806, 0, 0.47333],
              41: [0.25, 0.75, 0.03306, 0, 0.47333],
              42: [0, 0.75, 0.14333, 0, 0.59111],
              43: [0.10333, 0.60333, 0.03306, 0, 0.88555],
              44: [0.19444, 0.14722, 0, 0, 0.35555],
              45: [0, 0.44444, 0.02611, 0, 0.41444],
              46: [0, 0.14722, 0, 0, 0.35555],
              47: [0.25, 0.75, 0.15806, 0, 0.59111],
              48: [0, 0.64444, 0.13167, 0, 0.59111],
              49: [0, 0.64444, 0.13167, 0, 0.59111],
              50: [0, 0.64444, 0.13167, 0, 0.59111],
              51: [0, 0.64444, 0.13167, 0, 0.59111],
              52: [0.19444, 0.64444, 0.13167, 0, 0.59111],
              53: [0, 0.64444, 0.13167, 0, 0.59111],
              54: [0, 0.64444, 0.13167, 0, 0.59111],
              55: [0.19444, 0.64444, 0.13167, 0, 0.59111],
              56: [0, 0.64444, 0.13167, 0, 0.59111],
              57: [0, 0.64444, 0.13167, 0, 0.59111],
              58: [0, 0.44444, 0.06695, 0, 0.35555],
              59: [0.19444, 0.44444, 0.06695, 0, 0.35555],
              61: [-0.10889, 0.39111, 0.06833, 0, 0.88555],
              63: [0, 0.69444, 0.11472, 0, 0.59111],
              64: [0, 0.69444, 0.09208, 0, 0.88555],
              65: [0, 0.68611, 0, 0, 0.86555],
              66: [0, 0.68611, 0.0992, 0, 0.81666],
              67: [0, 0.68611, 0.14208, 0, 0.82666],
              68: [0, 0.68611, 0.09062, 0, 0.87555],
              69: [0, 0.68611, 0.11431, 0, 0.75666],
              70: [0, 0.68611, 0.12903, 0, 0.72722],
              71: [0, 0.68611, 0.07347, 0, 0.89527],
              72: [0, 0.68611, 0.17208, 0, 0.8961],
              73: [0, 0.68611, 0.15681, 0, 0.47166],
              74: [0, 0.68611, 0.145, 0, 0.61055],
              75: [0, 0.68611, 0.14208, 0, 0.89499],
              76: [0, 0.68611, 0, 0, 0.69777],
              77: [0, 0.68611, 0.17208, 0, 1.07277],
              78: [0, 0.68611, 0.17208, 0, 0.8961],
              79: [0, 0.68611, 0.09062, 0, 0.85499],
              80: [0, 0.68611, 0.0992, 0, 0.78721],
              81: [0.19444, 0.68611, 0.09062, 0, 0.85499],
              82: [0, 0.68611, 0.02559, 0, 0.85944],
              83: [0, 0.68611, 0.11264, 0, 0.64999],
              84: [0, 0.68611, 0.12903, 0, 0.7961],
              85: [0, 0.68611, 0.17208, 0, 0.88083],
              86: [0, 0.68611, 0.18625, 0, 0.86555],
              87: [0, 0.68611, 0.18625, 0, 1.15999],
              88: [0, 0.68611, 0.15681, 0, 0.86555],
              89: [0, 0.68611, 0.19803, 0, 0.86555],
              90: [0, 0.68611, 0.14208, 0, 0.70888],
              91: [0.25, 0.75, 0.1875, 0, 0.35611],
              93: [0.25, 0.75, 0.09972, 0, 0.35611],
              94: [0, 0.69444, 0.06709, 0, 0.59111],
              95: [0.31, 0.13444, 0.09811, 0, 0.59111],
              97: [0, 0.44444, 0.09426, 0, 0.59111],
              98: [0, 0.69444, 0.07861, 0, 0.53222],
              99: [0, 0.44444, 0.05222, 0, 0.53222],
              100: [0, 0.69444, 0.10861, 0, 0.59111],
              101: [0, 0.44444, 0.085, 0, 0.53222],
              102: [0.19444, 0.69444, 0.21778, 0, 0.4],
              103: [0.19444, 0.44444, 0.105, 0, 0.53222],
              104: [0, 0.69444, 0.09426, 0, 0.59111],
              105: [0, 0.69326, 0.11387, 0, 0.35555],
              106: [0.19444, 0.69326, 0.1672, 0, 0.35555],
              107: [0, 0.69444, 0.11111, 0, 0.53222],
              108: [0, 0.69444, 0.10861, 0, 0.29666],
              109: [0, 0.44444, 0.09426, 0, 0.94444],
              110: [0, 0.44444, 0.09426, 0, 0.64999],
              111: [0, 0.44444, 0.07861, 0, 0.59111],
              112: [0.19444, 0.44444, 0.07861, 0, 0.59111],
              113: [0.19444, 0.44444, 0.105, 0, 0.53222],
              114: [0, 0.44444, 0.11111, 0, 0.50167],
              115: [0, 0.44444, 0.08167, 0, 0.48694],
              116: [0, 0.63492, 0.09639, 0, 0.385],
              117: [0, 0.44444, 0.09426, 0, 0.62055],
              118: [0, 0.44444, 0.11111, 0, 0.53222],
              119: [0, 0.44444, 0.11111, 0, 0.76777],
              120: [0, 0.44444, 0.12583, 0, 0.56055],
              121: [0.19444, 0.44444, 0.105, 0, 0.56166],
              122: [0, 0.44444, 0.13889, 0, 0.49055],
              126: [0.35, 0.34444, 0.11472, 0, 0.59111],
              160: [0, 0, 0, 0, 0.25],
              168: [0, 0.69444, 0.11473, 0, 0.59111],
              176: [0, 0.69444, 0, 0, 0.94888],
              184: [0.17014, 0, 0, 0, 0.53222],
              198: [0, 0.68611, 0.11431, 0, 1.02277],
              216: [0.04861, 0.73472, 0.09062, 0, 0.88555],
              223: [0.19444, 0.69444, 0.09736, 0, 0.665],
              230: [0, 0.44444, 0.085, 0, 0.82666],
              248: [0.09722, 0.54167, 0.09458, 0, 0.59111],
              305: [0, 0.44444, 0.09426, 0, 0.35555],
              338: [0, 0.68611, 0.11431, 0, 1.14054],
              339: [0, 0.44444, 0.085, 0, 0.82666],
              567: [0.19444, 0.44444, 0.04611, 0, 0.385],
              710: [0, 0.69444, 0.06709, 0, 0.59111],
              711: [0, 0.63194, 0.08271, 0, 0.59111],
              713: [0, 0.59444, 0.10444, 0, 0.59111],
              714: [0, 0.69444, 0.08528, 0, 0.59111],
              715: [0, 0.69444, 0, 0, 0.59111],
              728: [0, 0.69444, 0.10333, 0, 0.59111],
              729: [0, 0.69444, 0.12945, 0, 0.35555],
              730: [0, 0.69444, 0, 0, 0.94888],
              732: [0, 0.69444, 0.11472, 0, 0.59111],
              733: [0, 0.69444, 0.11472, 0, 0.59111],
              915: [0, 0.68611, 0.12903, 0, 0.69777],
              916: [0, 0.68611, 0, 0, 0.94444],
              920: [0, 0.68611, 0.09062, 0, 0.88555],
              923: [0, 0.68611, 0, 0, 0.80666],
              926: [0, 0.68611, 0.15092, 0, 0.76777],
              928: [0, 0.68611, 0.17208, 0, 0.8961],
              931: [0, 0.68611, 0.11431, 0, 0.82666],
              933: [0, 0.68611, 0.10778, 0, 0.88555],
              934: [0, 0.68611, 0.05632, 0, 0.82666],
              936: [0, 0.68611, 0.10778, 0, 0.88555],
              937: [0, 0.68611, 0.0992, 0, 0.82666],
              8211: [0, 0.44444, 0.09811, 0, 0.59111],
              8212: [0, 0.44444, 0.09811, 0, 1.18221],
              8216: [0, 0.69444, 0.12945, 0, 0.35555],
              8217: [0, 0.69444, 0.12945, 0, 0.35555],
              8220: [0, 0.69444, 0.16772, 0, 0.62055],
              8221: [0, 0.69444, 0.07939, 0, 0.62055]
            },
            "Main-Italic": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69444, 0.12417, 0, 0.30667],
              34: [0, 0.69444, 0.06961, 0, 0.51444],
              35: [0.19444, 0.69444, 0.06616, 0, 0.81777],
              37: [0.05556, 0.75, 0.13639, 0, 0.81777],
              38: [0, 0.69444, 0.09694, 0, 0.76666],
              39: [0, 0.69444, 0.12417, 0, 0.30667],
              40: [0.25, 0.75, 0.16194, 0, 0.40889],
              41: [0.25, 0.75, 0.03694, 0, 0.40889],
              42: [0, 0.75, 0.14917, 0, 0.51111],
              43: [0.05667, 0.56167, 0.03694, 0, 0.76666],
              44: [0.19444, 0.10556, 0, 0, 0.30667],
              45: [0, 0.43056, 0.02826, 0, 0.35778],
              46: [0, 0.10556, 0, 0, 0.30667],
              47: [0.25, 0.75, 0.16194, 0, 0.51111],
              48: [0, 0.64444, 0.13556, 0, 0.51111],
              49: [0, 0.64444, 0.13556, 0, 0.51111],
              50: [0, 0.64444, 0.13556, 0, 0.51111],
              51: [0, 0.64444, 0.13556, 0, 0.51111],
              52: [0.19444, 0.64444, 0.13556, 0, 0.51111],
              53: [0, 0.64444, 0.13556, 0, 0.51111],
              54: [0, 0.64444, 0.13556, 0, 0.51111],
              55: [0.19444, 0.64444, 0.13556, 0, 0.51111],
              56: [0, 0.64444, 0.13556, 0, 0.51111],
              57: [0, 0.64444, 0.13556, 0, 0.51111],
              58: [0, 0.43056, 0.0582, 0, 0.30667],
              59: [0.19444, 0.43056, 0.0582, 0, 0.30667],
              61: [-0.13313, 0.36687, 0.06616, 0, 0.76666],
              63: [0, 0.69444, 0.1225, 0, 0.51111],
              64: [0, 0.69444, 0.09597, 0, 0.76666],
              65: [0, 0.68333, 0, 0, 0.74333],
              66: [0, 0.68333, 0.10257, 0, 0.70389],
              67: [0, 0.68333, 0.14528, 0, 0.71555],
              68: [0, 0.68333, 0.09403, 0, 0.755],
              69: [0, 0.68333, 0.12028, 0, 0.67833],
              70: [0, 0.68333, 0.13305, 0, 0.65277],
              71: [0, 0.68333, 0.08722, 0, 0.77361],
              72: [0, 0.68333, 0.16389, 0, 0.74333],
              73: [0, 0.68333, 0.15806, 0, 0.38555],
              74: [0, 0.68333, 0.14028, 0, 0.525],
              75: [0, 0.68333, 0.14528, 0, 0.76888],
              76: [0, 0.68333, 0, 0, 0.62722],
              77: [0, 0.68333, 0.16389, 0, 0.89666],
              78: [0, 0.68333, 0.16389, 0, 0.74333],
              79: [0, 0.68333, 0.09403, 0, 0.76666],
              80: [0, 0.68333, 0.10257, 0, 0.67833],
              81: [0.19444, 0.68333, 0.09403, 0, 0.76666],
              82: [0, 0.68333, 0.03868, 0, 0.72944],
              83: [0, 0.68333, 0.11972, 0, 0.56222],
              84: [0, 0.68333, 0.13305, 0, 0.71555],
              85: [0, 0.68333, 0.16389, 0, 0.74333],
              86: [0, 0.68333, 0.18361, 0, 0.74333],
              87: [0, 0.68333, 0.18361, 0, 0.99888],
              88: [0, 0.68333, 0.15806, 0, 0.74333],
              89: [0, 0.68333, 0.19383, 0, 0.74333],
              90: [0, 0.68333, 0.14528, 0, 0.61333],
              91: [0.25, 0.75, 0.1875, 0, 0.30667],
              93: [0.25, 0.75, 0.10528, 0, 0.30667],
              94: [0, 0.69444, 0.06646, 0, 0.51111],
              95: [0.31, 0.12056, 0.09208, 0, 0.51111],
              97: [0, 0.43056, 0.07671, 0, 0.51111],
              98: [0, 0.69444, 0.06312, 0, 0.46],
              99: [0, 0.43056, 0.05653, 0, 0.46],
              100: [0, 0.69444, 0.10333, 0, 0.51111],
              101: [0, 0.43056, 0.07514, 0, 0.46],
              102: [0.19444, 0.69444, 0.21194, 0, 0.30667],
              103: [0.19444, 0.43056, 0.08847, 0, 0.46],
              104: [0, 0.69444, 0.07671, 0, 0.51111],
              105: [0, 0.65536, 0.1019, 0, 0.30667],
              106: [0.19444, 0.65536, 0.14467, 0, 0.30667],
              107: [0, 0.69444, 0.10764, 0, 0.46],
              108: [0, 0.69444, 0.10333, 0, 0.25555],
              109: [0, 0.43056, 0.07671, 0, 0.81777],
              110: [0, 0.43056, 0.07671, 0, 0.56222],
              111: [0, 0.43056, 0.06312, 0, 0.51111],
              112: [0.19444, 0.43056, 0.06312, 0, 0.51111],
              113: [0.19444, 0.43056, 0.08847, 0, 0.46],
              114: [0, 0.43056, 0.10764, 0, 0.42166],
              115: [0, 0.43056, 0.08208, 0, 0.40889],
              116: [0, 0.61508, 0.09486, 0, 0.33222],
              117: [0, 0.43056, 0.07671, 0, 0.53666],
              118: [0, 0.43056, 0.10764, 0, 0.46],
              119: [0, 0.43056, 0.10764, 0, 0.66444],
              120: [0, 0.43056, 0.12042, 0, 0.46389],
              121: [0.19444, 0.43056, 0.08847, 0, 0.48555],
              122: [0, 0.43056, 0.12292, 0, 0.40889],
              126: [0.35, 0.31786, 0.11585, 0, 0.51111],
              160: [0, 0, 0, 0, 0.25],
              168: [0, 0.66786, 0.10474, 0, 0.51111],
              176: [0, 0.69444, 0, 0, 0.83129],
              184: [0.17014, 0, 0, 0, 0.46],
              198: [0, 0.68333, 0.12028, 0, 0.88277],
              216: [0.04861, 0.73194, 0.09403, 0, 0.76666],
              223: [0.19444, 0.69444, 0.10514, 0, 0.53666],
              230: [0, 0.43056, 0.07514, 0, 0.71555],
              248: [0.09722, 0.52778, 0.09194, 0, 0.51111],
              338: [0, 0.68333, 0.12028, 0, 0.98499],
              339: [0, 0.43056, 0.07514, 0, 0.71555],
              710: [0, 0.69444, 0.06646, 0, 0.51111],
              711: [0, 0.62847, 0.08295, 0, 0.51111],
              713: [0, 0.56167, 0.10333, 0, 0.51111],
              714: [0, 0.69444, 0.09694, 0, 0.51111],
              715: [0, 0.69444, 0, 0, 0.51111],
              728: [0, 0.69444, 0.10806, 0, 0.51111],
              729: [0, 0.66786, 0.11752, 0, 0.30667],
              730: [0, 0.69444, 0, 0, 0.83129],
              732: [0, 0.66786, 0.11585, 0, 0.51111],
              733: [0, 0.69444, 0.1225, 0, 0.51111],
              915: [0, 0.68333, 0.13305, 0, 0.62722],
              916: [0, 0.68333, 0, 0, 0.81777],
              920: [0, 0.68333, 0.09403, 0, 0.76666],
              923: [0, 0.68333, 0, 0, 0.69222],
              926: [0, 0.68333, 0.15294, 0, 0.66444],
              928: [0, 0.68333, 0.16389, 0, 0.74333],
              931: [0, 0.68333, 0.12028, 0, 0.71555],
              933: [0, 0.68333, 0.11111, 0, 0.76666],
              934: [0, 0.68333, 0.05986, 0, 0.71555],
              936: [0, 0.68333, 0.11111, 0, 0.76666],
              937: [0, 0.68333, 0.10257, 0, 0.71555],
              8211: [0, 0.43056, 0.09208, 0, 0.51111],
              8212: [0, 0.43056, 0.09208, 0, 1.02222],
              8216: [0, 0.69444, 0.12417, 0, 0.30667],
              8217: [0, 0.69444, 0.12417, 0, 0.30667],
              8220: [0, 0.69444, 0.1685, 0, 0.51444],
              8221: [0, 0.69444, 0.06961, 0, 0.51444],
              8463: [0, 0.68889, 0, 0, 0.54028]
            },
            "Main-Regular": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69444, 0, 0, 0.27778],
              34: [0, 0.69444, 0, 0, 0.5],
              35: [0.19444, 0.69444, 0, 0, 0.83334],
              36: [0.05556, 0.75, 0, 0, 0.5],
              37: [0.05556, 0.75, 0, 0, 0.83334],
              38: [0, 0.69444, 0, 0, 0.77778],
              39: [0, 0.69444, 0, 0, 0.27778],
              40: [0.25, 0.75, 0, 0, 0.38889],
              41: [0.25, 0.75, 0, 0, 0.38889],
              42: [0, 0.75, 0, 0, 0.5],
              43: [0.08333, 0.58333, 0, 0, 0.77778],
              44: [0.19444, 0.10556, 0, 0, 0.27778],
              45: [0, 0.43056, 0, 0, 0.33333],
              46: [0, 0.10556, 0, 0, 0.27778],
              47: [0.25, 0.75, 0, 0, 0.5],
              48: [0, 0.64444, 0, 0, 0.5],
              49: [0, 0.64444, 0, 0, 0.5],
              50: [0, 0.64444, 0, 0, 0.5],
              51: [0, 0.64444, 0, 0, 0.5],
              52: [0, 0.64444, 0, 0, 0.5],
              53: [0, 0.64444, 0, 0, 0.5],
              54: [0, 0.64444, 0, 0, 0.5],
              55: [0, 0.64444, 0, 0, 0.5],
              56: [0, 0.64444, 0, 0, 0.5],
              57: [0, 0.64444, 0, 0, 0.5],
              58: [0, 0.43056, 0, 0, 0.27778],
              59: [0.19444, 0.43056, 0, 0, 0.27778],
              60: [0.0391, 0.5391, 0, 0, 0.77778],
              61: [-0.13313, 0.36687, 0, 0, 0.77778],
              62: [0.0391, 0.5391, 0, 0, 0.77778],
              63: [0, 0.69444, 0, 0, 0.47222],
              64: [0, 0.69444, 0, 0, 0.77778],
              65: [0, 0.68333, 0, 0, 0.75],
              66: [0, 0.68333, 0, 0, 0.70834],
              67: [0, 0.68333, 0, 0, 0.72222],
              68: [0, 0.68333, 0, 0, 0.76389],
              69: [0, 0.68333, 0, 0, 0.68056],
              70: [0, 0.68333, 0, 0, 0.65278],
              71: [0, 0.68333, 0, 0, 0.78472],
              72: [0, 0.68333, 0, 0, 0.75],
              73: [0, 0.68333, 0, 0, 0.36111],
              74: [0, 0.68333, 0, 0, 0.51389],
              75: [0, 0.68333, 0, 0, 0.77778],
              76: [0, 0.68333, 0, 0, 0.625],
              77: [0, 0.68333, 0, 0, 0.91667],
              78: [0, 0.68333, 0, 0, 0.75],
              79: [0, 0.68333, 0, 0, 0.77778],
              80: [0, 0.68333, 0, 0, 0.68056],
              81: [0.19444, 0.68333, 0, 0, 0.77778],
              82: [0, 0.68333, 0, 0, 0.73611],
              83: [0, 0.68333, 0, 0, 0.55556],
              84: [0, 0.68333, 0, 0, 0.72222],
              85: [0, 0.68333, 0, 0, 0.75],
              86: [0, 0.68333, 0.01389, 0, 0.75],
              87: [0, 0.68333, 0.01389, 0, 1.02778],
              88: [0, 0.68333, 0, 0, 0.75],
              89: [0, 0.68333, 0.025, 0, 0.75],
              90: [0, 0.68333, 0, 0, 0.61111],
              91: [0.25, 0.75, 0, 0, 0.27778],
              92: [0.25, 0.75, 0, 0, 0.5],
              93: [0.25, 0.75, 0, 0, 0.27778],
              94: [0, 0.69444, 0, 0, 0.5],
              95: [0.31, 0.12056, 0.02778, 0, 0.5],
              97: [0, 0.43056, 0, 0, 0.5],
              98: [0, 0.69444, 0, 0, 0.55556],
              99: [0, 0.43056, 0, 0, 0.44445],
              100: [0, 0.69444, 0, 0, 0.55556],
              101: [0, 0.43056, 0, 0, 0.44445],
              102: [0, 0.69444, 0.07778, 0, 0.30556],
              103: [0.19444, 0.43056, 0.01389, 0, 0.5],
              104: [0, 0.69444, 0, 0, 0.55556],
              105: [0, 0.66786, 0, 0, 0.27778],
              106: [0.19444, 0.66786, 0, 0, 0.30556],
              107: [0, 0.69444, 0, 0, 0.52778],
              108: [0, 0.69444, 0, 0, 0.27778],
              109: [0, 0.43056, 0, 0, 0.83334],
              110: [0, 0.43056, 0, 0, 0.55556],
              111: [0, 0.43056, 0, 0, 0.5],
              112: [0.19444, 0.43056, 0, 0, 0.55556],
              113: [0.19444, 0.43056, 0, 0, 0.52778],
              114: [0, 0.43056, 0, 0, 0.39167],
              115: [0, 0.43056, 0, 0, 0.39445],
              116: [0, 0.61508, 0, 0, 0.38889],
              117: [0, 0.43056, 0, 0, 0.55556],
              118: [0, 0.43056, 0.01389, 0, 0.52778],
              119: [0, 0.43056, 0.01389, 0, 0.72222],
              120: [0, 0.43056, 0, 0, 0.52778],
              121: [0.19444, 0.43056, 0.01389, 0, 0.52778],
              122: [0, 0.43056, 0, 0, 0.44445],
              123: [0.25, 0.75, 0, 0, 0.5],
              124: [0.25, 0.75, 0, 0, 0.27778],
              125: [0.25, 0.75, 0, 0, 0.5],
              126: [0.35, 0.31786, 0, 0, 0.5],
              160: [0, 0, 0, 0, 0.25],
              163: [0, 0.69444, 0, 0, 0.76909],
              167: [0.19444, 0.69444, 0, 0, 0.44445],
              168: [0, 0.66786, 0, 0, 0.5],
              172: [0, 0.43056, 0, 0, 0.66667],
              176: [0, 0.69444, 0, 0, 0.75],
              177: [0.08333, 0.58333, 0, 0, 0.77778],
              182: [0.19444, 0.69444, 0, 0, 0.61111],
              184: [0.17014, 0, 0, 0, 0.44445],
              198: [0, 0.68333, 0, 0, 0.90278],
              215: [0.08333, 0.58333, 0, 0, 0.77778],
              216: [0.04861, 0.73194, 0, 0, 0.77778],
              223: [0, 0.69444, 0, 0, 0.5],
              230: [0, 0.43056, 0, 0, 0.72222],
              247: [0.08333, 0.58333, 0, 0, 0.77778],
              248: [0.09722, 0.52778, 0, 0, 0.5],
              305: [0, 0.43056, 0, 0, 0.27778],
              338: [0, 0.68333, 0, 0, 1.01389],
              339: [0, 0.43056, 0, 0, 0.77778],
              567: [0.19444, 0.43056, 0, 0, 0.30556],
              710: [0, 0.69444, 0, 0, 0.5],
              711: [0, 0.62847, 0, 0, 0.5],
              713: [0, 0.56778, 0, 0, 0.5],
              714: [0, 0.69444, 0, 0, 0.5],
              715: [0, 0.69444, 0, 0, 0.5],
              728: [0, 0.69444, 0, 0, 0.5],
              729: [0, 0.66786, 0, 0, 0.27778],
              730: [0, 0.69444, 0, 0, 0.75],
              732: [0, 0.66786, 0, 0, 0.5],
              733: [0, 0.69444, 0, 0, 0.5],
              915: [0, 0.68333, 0, 0, 0.625],
              916: [0, 0.68333, 0, 0, 0.83334],
              920: [0, 0.68333, 0, 0, 0.77778],
              923: [0, 0.68333, 0, 0, 0.69445],
              926: [0, 0.68333, 0, 0, 0.66667],
              928: [0, 0.68333, 0, 0, 0.75],
              931: [0, 0.68333, 0, 0, 0.72222],
              933: [0, 0.68333, 0, 0, 0.77778],
              934: [0, 0.68333, 0, 0, 0.72222],
              936: [0, 0.68333, 0, 0, 0.77778],
              937: [0, 0.68333, 0, 0, 0.72222],
              8211: [0, 0.43056, 0.02778, 0, 0.5],
              8212: [0, 0.43056, 0.02778, 0, 1],
              8216: [0, 0.69444, 0, 0, 0.27778],
              8217: [0, 0.69444, 0, 0, 0.27778],
              8220: [0, 0.69444, 0, 0, 0.5],
              8221: [0, 0.69444, 0, 0, 0.5],
              8224: [0.19444, 0.69444, 0, 0, 0.44445],
              8225: [0.19444, 0.69444, 0, 0, 0.44445],
              8230: [0, 0.123, 0, 0, 1.172],
              8242: [0, 0.55556, 0, 0, 0.275],
              8407: [0, 0.71444, 0.15382, 0, 0.5],
              8463: [0, 0.68889, 0, 0, 0.54028],
              8465: [0, 0.69444, 0, 0, 0.72222],
              8467: [0, 0.69444, 0, 0.11111, 0.41667],
              8472: [0.19444, 0.43056, 0, 0.11111, 0.63646],
              8476: [0, 0.69444, 0, 0, 0.72222],
              8501: [0, 0.69444, 0, 0, 0.61111],
              8592: [-0.13313, 0.36687, 0, 0, 1],
              8593: [0.19444, 0.69444, 0, 0, 0.5],
              8594: [-0.13313, 0.36687, 0, 0, 1],
              8595: [0.19444, 0.69444, 0, 0, 0.5],
              8596: [-0.13313, 0.36687, 0, 0, 1],
              8597: [0.25, 0.75, 0, 0, 0.5],
              8598: [0.19444, 0.69444, 0, 0, 1],
              8599: [0.19444, 0.69444, 0, 0, 1],
              8600: [0.19444, 0.69444, 0, 0, 1],
              8601: [0.19444, 0.69444, 0, 0, 1],
              8614: [0.011, 0.511, 0, 0, 1],
              8617: [0.011, 0.511, 0, 0, 1.126],
              8618: [0.011, 0.511, 0, 0, 1.126],
              8636: [-0.13313, 0.36687, 0, 0, 1],
              8637: [-0.13313, 0.36687, 0, 0, 1],
              8640: [-0.13313, 0.36687, 0, 0, 1],
              8641: [-0.13313, 0.36687, 0, 0, 1],
              8652: [0.011, 0.671, 0, 0, 1],
              8656: [-0.13313, 0.36687, 0, 0, 1],
              8657: [0.19444, 0.69444, 0, 0, 0.61111],
              8658: [-0.13313, 0.36687, 0, 0, 1],
              8659: [0.19444, 0.69444, 0, 0, 0.61111],
              8660: [-0.13313, 0.36687, 0, 0, 1],
              8661: [0.25, 0.75, 0, 0, 0.61111],
              8704: [0, 0.69444, 0, 0, 0.55556],
              8706: [0, 0.69444, 0.05556, 0.08334, 0.5309],
              8707: [0, 0.69444, 0, 0, 0.55556],
              8709: [0.05556, 0.75, 0, 0, 0.5],
              8711: [0, 0.68333, 0, 0, 0.83334],
              8712: [0.0391, 0.5391, 0, 0, 0.66667],
              8715: [0.0391, 0.5391, 0, 0, 0.66667],
              8722: [0.08333, 0.58333, 0, 0, 0.77778],
              8723: [0.08333, 0.58333, 0, 0, 0.77778],
              8725: [0.25, 0.75, 0, 0, 0.5],
              8726: [0.25, 0.75, 0, 0, 0.5],
              8727: [-0.03472, 0.46528, 0, 0, 0.5],
              8728: [-0.05555, 0.44445, 0, 0, 0.5],
              8729: [-0.05555, 0.44445, 0, 0, 0.5],
              8730: [0.2, 0.8, 0, 0, 0.83334],
              8733: [0, 0.43056, 0, 0, 0.77778],
              8734: [0, 0.43056, 0, 0, 1],
              8736: [0, 0.69224, 0, 0, 0.72222],
              8739: [0.25, 0.75, 0, 0, 0.27778],
              8741: [0.25, 0.75, 0, 0, 0.5],
              8743: [0, 0.55556, 0, 0, 0.66667],
              8744: [0, 0.55556, 0, 0, 0.66667],
              8745: [0, 0.55556, 0, 0, 0.66667],
              8746: [0, 0.55556, 0, 0, 0.66667],
              8747: [0.19444, 0.69444, 0.11111, 0, 0.41667],
              8764: [-0.13313, 0.36687, 0, 0, 0.77778],
              8768: [0.19444, 0.69444, 0, 0, 0.27778],
              8771: [-0.03625, 0.46375, 0, 0, 0.77778],
              8773: [-0.022, 0.589, 0, 0, 0.778],
              8776: [-0.01688, 0.48312, 0, 0, 0.77778],
              8781: [-0.03625, 0.46375, 0, 0, 0.77778],
              8784: [-0.133, 0.673, 0, 0, 0.778],
              8801: [-0.03625, 0.46375, 0, 0, 0.77778],
              8804: [0.13597, 0.63597, 0, 0, 0.77778],
              8805: [0.13597, 0.63597, 0, 0, 0.77778],
              8810: [0.0391, 0.5391, 0, 0, 1],
              8811: [0.0391, 0.5391, 0, 0, 1],
              8826: [0.0391, 0.5391, 0, 0, 0.77778],
              8827: [0.0391, 0.5391, 0, 0, 0.77778],
              8834: [0.0391, 0.5391, 0, 0, 0.77778],
              8835: [0.0391, 0.5391, 0, 0, 0.77778],
              8838: [0.13597, 0.63597, 0, 0, 0.77778],
              8839: [0.13597, 0.63597, 0, 0, 0.77778],
              8846: [0, 0.55556, 0, 0, 0.66667],
              8849: [0.13597, 0.63597, 0, 0, 0.77778],
              8850: [0.13597, 0.63597, 0, 0, 0.77778],
              8851: [0, 0.55556, 0, 0, 0.66667],
              8852: [0, 0.55556, 0, 0, 0.66667],
              8853: [0.08333, 0.58333, 0, 0, 0.77778],
              8854: [0.08333, 0.58333, 0, 0, 0.77778],
              8855: [0.08333, 0.58333, 0, 0, 0.77778],
              8856: [0.08333, 0.58333, 0, 0, 0.77778],
              8857: [0.08333, 0.58333, 0, 0, 0.77778],
              8866: [0, 0.69444, 0, 0, 0.61111],
              8867: [0, 0.69444, 0, 0, 0.61111],
              8868: [0, 0.69444, 0, 0, 0.77778],
              8869: [0, 0.69444, 0, 0, 0.77778],
              8872: [0.249, 0.75, 0, 0, 0.867],
              8900: [-0.05555, 0.44445, 0, 0, 0.5],
              8901: [-0.05555, 0.44445, 0, 0, 0.27778],
              8902: [-0.03472, 0.46528, 0, 0, 0.5],
              8904: [5e-3, 0.505, 0, 0, 0.9],
              8942: [0.03, 0.903, 0, 0, 0.278],
              8943: [-0.19, 0.313, 0, 0, 1.172],
              8945: [-0.1, 0.823, 0, 0, 1.282],
              8968: [0.25, 0.75, 0, 0, 0.44445],
              8969: [0.25, 0.75, 0, 0, 0.44445],
              8970: [0.25, 0.75, 0, 0, 0.44445],
              8971: [0.25, 0.75, 0, 0, 0.44445],
              8994: [-0.14236, 0.35764, 0, 0, 1],
              8995: [-0.14236, 0.35764, 0, 0, 1],
              9136: [0.244, 0.744, 0, 0, 0.412],
              9137: [0.244, 0.745, 0, 0, 0.412],
              9651: [0.19444, 0.69444, 0, 0, 0.88889],
              9657: [-0.03472, 0.46528, 0, 0, 0.5],
              9661: [0.19444, 0.69444, 0, 0, 0.88889],
              9667: [-0.03472, 0.46528, 0, 0, 0.5],
              9711: [0.19444, 0.69444, 0, 0, 1],
              9824: [0.12963, 0.69444, 0, 0, 0.77778],
              9825: [0.12963, 0.69444, 0, 0, 0.77778],
              9826: [0.12963, 0.69444, 0, 0, 0.77778],
              9827: [0.12963, 0.69444, 0, 0, 0.77778],
              9837: [0, 0.75, 0, 0, 0.38889],
              9838: [0.19444, 0.69444, 0, 0, 0.38889],
              9839: [0.19444, 0.69444, 0, 0, 0.38889],
              10216: [0.25, 0.75, 0, 0, 0.38889],
              10217: [0.25, 0.75, 0, 0, 0.38889],
              10222: [0.244, 0.744, 0, 0, 0.412],
              10223: [0.244, 0.745, 0, 0, 0.412],
              10229: [0.011, 0.511, 0, 0, 1.609],
              10230: [0.011, 0.511, 0, 0, 1.638],
              10231: [0.011, 0.511, 0, 0, 1.859],
              10232: [0.024, 0.525, 0, 0, 1.609],
              10233: [0.024, 0.525, 0, 0, 1.638],
              10234: [0.024, 0.525, 0, 0, 1.858],
              10236: [0.011, 0.511, 0, 0, 1.638],
              10815: [0, 0.68333, 0, 0, 0.75],
              10927: [0.13597, 0.63597, 0, 0, 0.77778],
              10928: [0.13597, 0.63597, 0, 0, 0.77778],
              57376: [0.19444, 0.69444, 0, 0, 0]
            },
            "Math-BoldItalic": {
              32: [0, 0, 0, 0, 0.25],
              48: [0, 0.44444, 0, 0, 0.575],
              49: [0, 0.44444, 0, 0, 0.575],
              50: [0, 0.44444, 0, 0, 0.575],
              51: [0.19444, 0.44444, 0, 0, 0.575],
              52: [0.19444, 0.44444, 0, 0, 0.575],
              53: [0.19444, 0.44444, 0, 0, 0.575],
              54: [0, 0.64444, 0, 0, 0.575],
              55: [0.19444, 0.44444, 0, 0, 0.575],
              56: [0, 0.64444, 0, 0, 0.575],
              57: [0.19444, 0.44444, 0, 0, 0.575],
              65: [0, 0.68611, 0, 0, 0.86944],
              66: [0, 0.68611, 0.04835, 0, 0.8664],
              67: [0, 0.68611, 0.06979, 0, 0.81694],
              68: [0, 0.68611, 0.03194, 0, 0.93812],
              69: [0, 0.68611, 0.05451, 0, 0.81007],
              70: [0, 0.68611, 0.15972, 0, 0.68889],
              71: [0, 0.68611, 0, 0, 0.88673],
              72: [0, 0.68611, 0.08229, 0, 0.98229],
              73: [0, 0.68611, 0.07778, 0, 0.51111],
              74: [0, 0.68611, 0.10069, 0, 0.63125],
              75: [0, 0.68611, 0.06979, 0, 0.97118],
              76: [0, 0.68611, 0, 0, 0.75555],
              77: [0, 0.68611, 0.11424, 0, 1.14201],
              78: [0, 0.68611, 0.11424, 0, 0.95034],
              79: [0, 0.68611, 0.03194, 0, 0.83666],
              80: [0, 0.68611, 0.15972, 0, 0.72309],
              81: [0.19444, 0.68611, 0, 0, 0.86861],
              82: [0, 0.68611, 421e-5, 0, 0.87235],
              83: [0, 0.68611, 0.05382, 0, 0.69271],
              84: [0, 0.68611, 0.15972, 0, 0.63663],
              85: [0, 0.68611, 0.11424, 0, 0.80027],
              86: [0, 0.68611, 0.25555, 0, 0.67778],
              87: [0, 0.68611, 0.15972, 0, 1.09305],
              88: [0, 0.68611, 0.07778, 0, 0.94722],
              89: [0, 0.68611, 0.25555, 0, 0.67458],
              90: [0, 0.68611, 0.06979, 0, 0.77257],
              97: [0, 0.44444, 0, 0, 0.63287],
              98: [0, 0.69444, 0, 0, 0.52083],
              99: [0, 0.44444, 0, 0, 0.51342],
              100: [0, 0.69444, 0, 0, 0.60972],
              101: [0, 0.44444, 0, 0, 0.55361],
              102: [0.19444, 0.69444, 0.11042, 0, 0.56806],
              103: [0.19444, 0.44444, 0.03704, 0, 0.5449],
              104: [0, 0.69444, 0, 0, 0.66759],
              105: [0, 0.69326, 0, 0, 0.4048],
              106: [0.19444, 0.69326, 0.0622, 0, 0.47083],
              107: [0, 0.69444, 0.01852, 0, 0.6037],
              108: [0, 0.69444, 88e-4, 0, 0.34815],
              109: [0, 0.44444, 0, 0, 1.0324],
              110: [0, 0.44444, 0, 0, 0.71296],
              111: [0, 0.44444, 0, 0, 0.58472],
              112: [0.19444, 0.44444, 0, 0, 0.60092],
              113: [0.19444, 0.44444, 0.03704, 0, 0.54213],
              114: [0, 0.44444, 0.03194, 0, 0.5287],
              115: [0, 0.44444, 0, 0, 0.53125],
              116: [0, 0.63492, 0, 0, 0.41528],
              117: [0, 0.44444, 0, 0, 0.68102],
              118: [0, 0.44444, 0.03704, 0, 0.56666],
              119: [0, 0.44444, 0.02778, 0, 0.83148],
              120: [0, 0.44444, 0, 0, 0.65903],
              121: [0.19444, 0.44444, 0.03704, 0, 0.59028],
              122: [0, 0.44444, 0.04213, 0, 0.55509],
              160: [0, 0, 0, 0, 0.25],
              915: [0, 0.68611, 0.15972, 0, 0.65694],
              916: [0, 0.68611, 0, 0, 0.95833],
              920: [0, 0.68611, 0.03194, 0, 0.86722],
              923: [0, 0.68611, 0, 0, 0.80555],
              926: [0, 0.68611, 0.07458, 0, 0.84125],
              928: [0, 0.68611, 0.08229, 0, 0.98229],
              931: [0, 0.68611, 0.05451, 0, 0.88507],
              933: [0, 0.68611, 0.15972, 0, 0.67083],
              934: [0, 0.68611, 0, 0, 0.76666],
              936: [0, 0.68611, 0.11653, 0, 0.71402],
              937: [0, 0.68611, 0.04835, 0, 0.8789],
              945: [0, 0.44444, 0, 0, 0.76064],
              946: [0.19444, 0.69444, 0.03403, 0, 0.65972],
              947: [0.19444, 0.44444, 0.06389, 0, 0.59003],
              948: [0, 0.69444, 0.03819, 0, 0.52222],
              949: [0, 0.44444, 0, 0, 0.52882],
              950: [0.19444, 0.69444, 0.06215, 0, 0.50833],
              951: [0.19444, 0.44444, 0.03704, 0, 0.6],
              952: [0, 0.69444, 0.03194, 0, 0.5618],
              953: [0, 0.44444, 0, 0, 0.41204],
              954: [0, 0.44444, 0, 0, 0.66759],
              955: [0, 0.69444, 0, 0, 0.67083],
              956: [0.19444, 0.44444, 0, 0, 0.70787],
              957: [0, 0.44444, 0.06898, 0, 0.57685],
              958: [0.19444, 0.69444, 0.03021, 0, 0.50833],
              959: [0, 0.44444, 0, 0, 0.58472],
              960: [0, 0.44444, 0.03704, 0, 0.68241],
              961: [0.19444, 0.44444, 0, 0, 0.6118],
              962: [0.09722, 0.44444, 0.07917, 0, 0.42361],
              963: [0, 0.44444, 0.03704, 0, 0.68588],
              964: [0, 0.44444, 0.13472, 0, 0.52083],
              965: [0, 0.44444, 0.03704, 0, 0.63055],
              966: [0.19444, 0.44444, 0, 0, 0.74722],
              967: [0.19444, 0.44444, 0, 0, 0.71805],
              968: [0.19444, 0.69444, 0.03704, 0, 0.75833],
              969: [0, 0.44444, 0.03704, 0, 0.71782],
              977: [0, 0.69444, 0, 0, 0.69155],
              981: [0.19444, 0.69444, 0, 0, 0.7125],
              982: [0, 0.44444, 0.03194, 0, 0.975],
              1009: [0.19444, 0.44444, 0, 0, 0.6118],
              1013: [0, 0.44444, 0, 0, 0.48333],
              57649: [0, 0.44444, 0, 0, 0.39352],
              57911: [0.19444, 0.44444, 0, 0, 0.43889]
            },
            "Math-Italic": {
              32: [0, 0, 0, 0, 0.25],
              48: [0, 0.43056, 0, 0, 0.5],
              49: [0, 0.43056, 0, 0, 0.5],
              50: [0, 0.43056, 0, 0, 0.5],
              51: [0.19444, 0.43056, 0, 0, 0.5],
              52: [0.19444, 0.43056, 0, 0, 0.5],
              53: [0.19444, 0.43056, 0, 0, 0.5],
              54: [0, 0.64444, 0, 0, 0.5],
              55: [0.19444, 0.43056, 0, 0, 0.5],
              56: [0, 0.64444, 0, 0, 0.5],
              57: [0.19444, 0.43056, 0, 0, 0.5],
              65: [0, 0.68333, 0, 0.13889, 0.75],
              66: [0, 0.68333, 0.05017, 0.08334, 0.75851],
              67: [0, 0.68333, 0.07153, 0.08334, 0.71472],
              68: [0, 0.68333, 0.02778, 0.05556, 0.82792],
              69: [0, 0.68333, 0.05764, 0.08334, 0.7382],
              70: [0, 0.68333, 0.13889, 0.08334, 0.64306],
              71: [0, 0.68333, 0, 0.08334, 0.78625],
              72: [0, 0.68333, 0.08125, 0.05556, 0.83125],
              73: [0, 0.68333, 0.07847, 0.11111, 0.43958],
              74: [0, 0.68333, 0.09618, 0.16667, 0.55451],
              75: [0, 0.68333, 0.07153, 0.05556, 0.84931],
              76: [0, 0.68333, 0, 0.02778, 0.68056],
              77: [0, 0.68333, 0.10903, 0.08334, 0.97014],
              78: [0, 0.68333, 0.10903, 0.08334, 0.80347],
              79: [0, 0.68333, 0.02778, 0.08334, 0.76278],
              80: [0, 0.68333, 0.13889, 0.08334, 0.64201],
              81: [0.19444, 0.68333, 0, 0.08334, 0.79056],
              82: [0, 0.68333, 773e-5, 0.08334, 0.75929],
              83: [0, 0.68333, 0.05764, 0.08334, 0.6132],
              84: [0, 0.68333, 0.13889, 0.08334, 0.58438],
              85: [0, 0.68333, 0.10903, 0.02778, 0.68278],
              86: [0, 0.68333, 0.22222, 0, 0.58333],
              87: [0, 0.68333, 0.13889, 0, 0.94445],
              88: [0, 0.68333, 0.07847, 0.08334, 0.82847],
              89: [0, 0.68333, 0.22222, 0, 0.58056],
              90: [0, 0.68333, 0.07153, 0.08334, 0.68264],
              97: [0, 0.43056, 0, 0, 0.52859],
              98: [0, 0.69444, 0, 0, 0.42917],
              99: [0, 0.43056, 0, 0.05556, 0.43276],
              100: [0, 0.69444, 0, 0.16667, 0.52049],
              101: [0, 0.43056, 0, 0.05556, 0.46563],
              102: [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
              103: [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
              104: [0, 0.69444, 0, 0, 0.57616],
              105: [0, 0.65952, 0, 0, 0.34451],
              106: [0.19444, 0.65952, 0.05724, 0, 0.41181],
              107: [0, 0.69444, 0.03148, 0, 0.5206],
              108: [0, 0.69444, 0.01968, 0.08334, 0.29838],
              109: [0, 0.43056, 0, 0, 0.87801],
              110: [0, 0.43056, 0, 0, 0.60023],
              111: [0, 0.43056, 0, 0.05556, 0.48472],
              112: [0.19444, 0.43056, 0, 0.08334, 0.50313],
              113: [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
              114: [0, 0.43056, 0.02778, 0.05556, 0.45116],
              115: [0, 0.43056, 0, 0.05556, 0.46875],
              116: [0, 0.61508, 0, 0.08334, 0.36111],
              117: [0, 0.43056, 0, 0.02778, 0.57246],
              118: [0, 0.43056, 0.03588, 0.02778, 0.48472],
              119: [0, 0.43056, 0.02691, 0.08334, 0.71592],
              120: [0, 0.43056, 0, 0.02778, 0.57153],
              121: [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
              122: [0, 0.43056, 0.04398, 0.05556, 0.46505],
              160: [0, 0, 0, 0, 0.25],
              915: [0, 0.68333, 0.13889, 0.08334, 0.61528],
              916: [0, 0.68333, 0, 0.16667, 0.83334],
              920: [0, 0.68333, 0.02778, 0.08334, 0.76278],
              923: [0, 0.68333, 0, 0.16667, 0.69445],
              926: [0, 0.68333, 0.07569, 0.08334, 0.74236],
              928: [0, 0.68333, 0.08125, 0.05556, 0.83125],
              931: [0, 0.68333, 0.05764, 0.08334, 0.77986],
              933: [0, 0.68333, 0.13889, 0.05556, 0.58333],
              934: [0, 0.68333, 0, 0.08334, 0.66667],
              936: [0, 0.68333, 0.11, 0.05556, 0.61222],
              937: [0, 0.68333, 0.05017, 0.08334, 0.7724],
              945: [0, 0.43056, 37e-4, 0.02778, 0.6397],
              946: [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
              947: [0.19444, 0.43056, 0.05556, 0, 0.51773],
              948: [0, 0.69444, 0.03785, 0.05556, 0.44444],
              949: [0, 0.43056, 0, 0.08334, 0.46632],
              950: [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
              951: [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
              952: [0, 0.69444, 0.02778, 0.08334, 0.46944],
              953: [0, 0.43056, 0, 0.05556, 0.35394],
              954: [0, 0.43056, 0, 0, 0.57616],
              955: [0, 0.69444, 0, 0, 0.58334],
              956: [0.19444, 0.43056, 0, 0.02778, 0.60255],
              957: [0, 0.43056, 0.06366, 0.02778, 0.49398],
              958: [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
              959: [0, 0.43056, 0, 0.05556, 0.48472],
              960: [0, 0.43056, 0.03588, 0, 0.57003],
              961: [0.19444, 0.43056, 0, 0.08334, 0.51702],
              962: [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
              963: [0, 0.43056, 0.03588, 0, 0.57141],
              964: [0, 0.43056, 0.1132, 0.02778, 0.43715],
              965: [0, 0.43056, 0.03588, 0.02778, 0.54028],
              966: [0.19444, 0.43056, 0, 0.08334, 0.65417],
              967: [0.19444, 0.43056, 0, 0.05556, 0.62569],
              968: [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
              969: [0, 0.43056, 0.03588, 0, 0.62245],
              977: [0, 0.69444, 0, 0.08334, 0.59144],
              981: [0.19444, 0.69444, 0, 0.08334, 0.59583],
              982: [0, 0.43056, 0.02778, 0, 0.82813],
              1009: [0.19444, 0.43056, 0, 0.08334, 0.51702],
              1013: [0, 0.43056, 0, 0.05556, 0.4059],
              57649: [0, 0.43056, 0, 0.02778, 0.32246],
              57911: [0.19444, 0.43056, 0, 0.08334, 0.38403]
            },
            "SansSerif-Bold": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69444, 0, 0, 0.36667],
              34: [0, 0.69444, 0, 0, 0.55834],
              35: [0.19444, 0.69444, 0, 0, 0.91667],
              36: [0.05556, 0.75, 0, 0, 0.55],
              37: [0.05556, 0.75, 0, 0, 1.02912],
              38: [0, 0.69444, 0, 0, 0.83056],
              39: [0, 0.69444, 0, 0, 0.30556],
              40: [0.25, 0.75, 0, 0, 0.42778],
              41: [0.25, 0.75, 0, 0, 0.42778],
              42: [0, 0.75, 0, 0, 0.55],
              43: [0.11667, 0.61667, 0, 0, 0.85556],
              44: [0.10556, 0.13056, 0, 0, 0.30556],
              45: [0, 0.45833, 0, 0, 0.36667],
              46: [0, 0.13056, 0, 0, 0.30556],
              47: [0.25, 0.75, 0, 0, 0.55],
              48: [0, 0.69444, 0, 0, 0.55],
              49: [0, 0.69444, 0, 0, 0.55],
              50: [0, 0.69444, 0, 0, 0.55],
              51: [0, 0.69444, 0, 0, 0.55],
              52: [0, 0.69444, 0, 0, 0.55],
              53: [0, 0.69444, 0, 0, 0.55],
              54: [0, 0.69444, 0, 0, 0.55],
              55: [0, 0.69444, 0, 0, 0.55],
              56: [0, 0.69444, 0, 0, 0.55],
              57: [0, 0.69444, 0, 0, 0.55],
              58: [0, 0.45833, 0, 0, 0.30556],
              59: [0.10556, 0.45833, 0, 0, 0.30556],
              61: [-0.09375, 0.40625, 0, 0, 0.85556],
              63: [0, 0.69444, 0, 0, 0.51945],
              64: [0, 0.69444, 0, 0, 0.73334],
              65: [0, 0.69444, 0, 0, 0.73334],
              66: [0, 0.69444, 0, 0, 0.73334],
              67: [0, 0.69444, 0, 0, 0.70278],
              68: [0, 0.69444, 0, 0, 0.79445],
              69: [0, 0.69444, 0, 0, 0.64167],
              70: [0, 0.69444, 0, 0, 0.61111],
              71: [0, 0.69444, 0, 0, 0.73334],
              72: [0, 0.69444, 0, 0, 0.79445],
              73: [0, 0.69444, 0, 0, 0.33056],
              74: [0, 0.69444, 0, 0, 0.51945],
              75: [0, 0.69444, 0, 0, 0.76389],
              76: [0, 0.69444, 0, 0, 0.58056],
              77: [0, 0.69444, 0, 0, 0.97778],
              78: [0, 0.69444, 0, 0, 0.79445],
              79: [0, 0.69444, 0, 0, 0.79445],
              80: [0, 0.69444, 0, 0, 0.70278],
              81: [0.10556, 0.69444, 0, 0, 0.79445],
              82: [0, 0.69444, 0, 0, 0.70278],
              83: [0, 0.69444, 0, 0, 0.61111],
              84: [0, 0.69444, 0, 0, 0.73334],
              85: [0, 0.69444, 0, 0, 0.76389],
              86: [0, 0.69444, 0.01528, 0, 0.73334],
              87: [0, 0.69444, 0.01528, 0, 1.03889],
              88: [0, 0.69444, 0, 0, 0.73334],
              89: [0, 0.69444, 0.0275, 0, 0.73334],
              90: [0, 0.69444, 0, 0, 0.67223],
              91: [0.25, 0.75, 0, 0, 0.34306],
              93: [0.25, 0.75, 0, 0, 0.34306],
              94: [0, 0.69444, 0, 0, 0.55],
              95: [0.35, 0.10833, 0.03056, 0, 0.55],
              97: [0, 0.45833, 0, 0, 0.525],
              98: [0, 0.69444, 0, 0, 0.56111],
              99: [0, 0.45833, 0, 0, 0.48889],
              100: [0, 0.69444, 0, 0, 0.56111],
              101: [0, 0.45833, 0, 0, 0.51111],
              102: [0, 0.69444, 0.07639, 0, 0.33611],
              103: [0.19444, 0.45833, 0.01528, 0, 0.55],
              104: [0, 0.69444, 0, 0, 0.56111],
              105: [0, 0.69444, 0, 0, 0.25556],
              106: [0.19444, 0.69444, 0, 0, 0.28611],
              107: [0, 0.69444, 0, 0, 0.53056],
              108: [0, 0.69444, 0, 0, 0.25556],
              109: [0, 0.45833, 0, 0, 0.86667],
              110: [0, 0.45833, 0, 0, 0.56111],
              111: [0, 0.45833, 0, 0, 0.55],
              112: [0.19444, 0.45833, 0, 0, 0.56111],
              113: [0.19444, 0.45833, 0, 0, 0.56111],
              114: [0, 0.45833, 0.01528, 0, 0.37222],
              115: [0, 0.45833, 0, 0, 0.42167],
              116: [0, 0.58929, 0, 0, 0.40417],
              117: [0, 0.45833, 0, 0, 0.56111],
              118: [0, 0.45833, 0.01528, 0, 0.5],
              119: [0, 0.45833, 0.01528, 0, 0.74445],
              120: [0, 0.45833, 0, 0, 0.5],
              121: [0.19444, 0.45833, 0.01528, 0, 0.5],
              122: [0, 0.45833, 0, 0, 0.47639],
              126: [0.35, 0.34444, 0, 0, 0.55],
              160: [0, 0, 0, 0, 0.25],
              168: [0, 0.69444, 0, 0, 0.55],
              176: [0, 0.69444, 0, 0, 0.73334],
              180: [0, 0.69444, 0, 0, 0.55],
              184: [0.17014, 0, 0, 0, 0.48889],
              305: [0, 0.45833, 0, 0, 0.25556],
              567: [0.19444, 0.45833, 0, 0, 0.28611],
              710: [0, 0.69444, 0, 0, 0.55],
              711: [0, 0.63542, 0, 0, 0.55],
              713: [0, 0.63778, 0, 0, 0.55],
              728: [0, 0.69444, 0, 0, 0.55],
              729: [0, 0.69444, 0, 0, 0.30556],
              730: [0, 0.69444, 0, 0, 0.73334],
              732: [0, 0.69444, 0, 0, 0.55],
              733: [0, 0.69444, 0, 0, 0.55],
              915: [0, 0.69444, 0, 0, 0.58056],
              916: [0, 0.69444, 0, 0, 0.91667],
              920: [0, 0.69444, 0, 0, 0.85556],
              923: [0, 0.69444, 0, 0, 0.67223],
              926: [0, 0.69444, 0, 0, 0.73334],
              928: [0, 0.69444, 0, 0, 0.79445],
              931: [0, 0.69444, 0, 0, 0.79445],
              933: [0, 0.69444, 0, 0, 0.85556],
              934: [0, 0.69444, 0, 0, 0.79445],
              936: [0, 0.69444, 0, 0, 0.85556],
              937: [0, 0.69444, 0, 0, 0.79445],
              8211: [0, 0.45833, 0.03056, 0, 0.55],
              8212: [0, 0.45833, 0.03056, 0, 1.10001],
              8216: [0, 0.69444, 0, 0, 0.30556],
              8217: [0, 0.69444, 0, 0, 0.30556],
              8220: [0, 0.69444, 0, 0, 0.55834],
              8221: [0, 0.69444, 0, 0, 0.55834]
            },
            "SansSerif-Italic": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69444, 0.05733, 0, 0.31945],
              34: [0, 0.69444, 316e-5, 0, 0.5],
              35: [0.19444, 0.69444, 0.05087, 0, 0.83334],
              36: [0.05556, 0.75, 0.11156, 0, 0.5],
              37: [0.05556, 0.75, 0.03126, 0, 0.83334],
              38: [0, 0.69444, 0.03058, 0, 0.75834],
              39: [0, 0.69444, 0.07816, 0, 0.27778],
              40: [0.25, 0.75, 0.13164, 0, 0.38889],
              41: [0.25, 0.75, 0.02536, 0, 0.38889],
              42: [0, 0.75, 0.11775, 0, 0.5],
              43: [0.08333, 0.58333, 0.02536, 0, 0.77778],
              44: [0.125, 0.08333, 0, 0, 0.27778],
              45: [0, 0.44444, 0.01946, 0, 0.33333],
              46: [0, 0.08333, 0, 0, 0.27778],
              47: [0.25, 0.75, 0.13164, 0, 0.5],
              48: [0, 0.65556, 0.11156, 0, 0.5],
              49: [0, 0.65556, 0.11156, 0, 0.5],
              50: [0, 0.65556, 0.11156, 0, 0.5],
              51: [0, 0.65556, 0.11156, 0, 0.5],
              52: [0, 0.65556, 0.11156, 0, 0.5],
              53: [0, 0.65556, 0.11156, 0, 0.5],
              54: [0, 0.65556, 0.11156, 0, 0.5],
              55: [0, 0.65556, 0.11156, 0, 0.5],
              56: [0, 0.65556, 0.11156, 0, 0.5],
              57: [0, 0.65556, 0.11156, 0, 0.5],
              58: [0, 0.44444, 0.02502, 0, 0.27778],
              59: [0.125, 0.44444, 0.02502, 0, 0.27778],
              61: [-0.13, 0.37, 0.05087, 0, 0.77778],
              63: [0, 0.69444, 0.11809, 0, 0.47222],
              64: [0, 0.69444, 0.07555, 0, 0.66667],
              65: [0, 0.69444, 0, 0, 0.66667],
              66: [0, 0.69444, 0.08293, 0, 0.66667],
              67: [0, 0.69444, 0.11983, 0, 0.63889],
              68: [0, 0.69444, 0.07555, 0, 0.72223],
              69: [0, 0.69444, 0.11983, 0, 0.59722],
              70: [0, 0.69444, 0.13372, 0, 0.56945],
              71: [0, 0.69444, 0.11983, 0, 0.66667],
              72: [0, 0.69444, 0.08094, 0, 0.70834],
              73: [0, 0.69444, 0.13372, 0, 0.27778],
              74: [0, 0.69444, 0.08094, 0, 0.47222],
              75: [0, 0.69444, 0.11983, 0, 0.69445],
              76: [0, 0.69444, 0, 0, 0.54167],
              77: [0, 0.69444, 0.08094, 0, 0.875],
              78: [0, 0.69444, 0.08094, 0, 0.70834],
              79: [0, 0.69444, 0.07555, 0, 0.73611],
              80: [0, 0.69444, 0.08293, 0, 0.63889],
              81: [0.125, 0.69444, 0.07555, 0, 0.73611],
              82: [0, 0.69444, 0.08293, 0, 0.64584],
              83: [0, 0.69444, 0.09205, 0, 0.55556],
              84: [0, 0.69444, 0.13372, 0, 0.68056],
              85: [0, 0.69444, 0.08094, 0, 0.6875],
              86: [0, 0.69444, 0.1615, 0, 0.66667],
              87: [0, 0.69444, 0.1615, 0, 0.94445],
              88: [0, 0.69444, 0.13372, 0, 0.66667],
              89: [0, 0.69444, 0.17261, 0, 0.66667],
              90: [0, 0.69444, 0.11983, 0, 0.61111],
              91: [0.25, 0.75, 0.15942, 0, 0.28889],
              93: [0.25, 0.75, 0.08719, 0, 0.28889],
              94: [0, 0.69444, 0.0799, 0, 0.5],
              95: [0.35, 0.09444, 0.08616, 0, 0.5],
              97: [0, 0.44444, 981e-5, 0, 0.48056],
              98: [0, 0.69444, 0.03057, 0, 0.51667],
              99: [0, 0.44444, 0.08336, 0, 0.44445],
              100: [0, 0.69444, 0.09483, 0, 0.51667],
              101: [0, 0.44444, 0.06778, 0, 0.44445],
              102: [0, 0.69444, 0.21705, 0, 0.30556],
              103: [0.19444, 0.44444, 0.10836, 0, 0.5],
              104: [0, 0.69444, 0.01778, 0, 0.51667],
              105: [0, 0.67937, 0.09718, 0, 0.23889],
              106: [0.19444, 0.67937, 0.09162, 0, 0.26667],
              107: [0, 0.69444, 0.08336, 0, 0.48889],
              108: [0, 0.69444, 0.09483, 0, 0.23889],
              109: [0, 0.44444, 0.01778, 0, 0.79445],
              110: [0, 0.44444, 0.01778, 0, 0.51667],
              111: [0, 0.44444, 0.06613, 0, 0.5],
              112: [0.19444, 0.44444, 0.0389, 0, 0.51667],
              113: [0.19444, 0.44444, 0.04169, 0, 0.51667],
              114: [0, 0.44444, 0.10836, 0, 0.34167],
              115: [0, 0.44444, 0.0778, 0, 0.38333],
              116: [0, 0.57143, 0.07225, 0, 0.36111],
              117: [0, 0.44444, 0.04169, 0, 0.51667],
              118: [0, 0.44444, 0.10836, 0, 0.46111],
              119: [0, 0.44444, 0.10836, 0, 0.68334],
              120: [0, 0.44444, 0.09169, 0, 0.46111],
              121: [0.19444, 0.44444, 0.10836, 0, 0.46111],
              122: [0, 0.44444, 0.08752, 0, 0.43472],
              126: [0.35, 0.32659, 0.08826, 0, 0.5],
              160: [0, 0, 0, 0, 0.25],
              168: [0, 0.67937, 0.06385, 0, 0.5],
              176: [0, 0.69444, 0, 0, 0.73752],
              184: [0.17014, 0, 0, 0, 0.44445],
              305: [0, 0.44444, 0.04169, 0, 0.23889],
              567: [0.19444, 0.44444, 0.04169, 0, 0.26667],
              710: [0, 0.69444, 0.0799, 0, 0.5],
              711: [0, 0.63194, 0.08432, 0, 0.5],
              713: [0, 0.60889, 0.08776, 0, 0.5],
              714: [0, 0.69444, 0.09205, 0, 0.5],
              715: [0, 0.69444, 0, 0, 0.5],
              728: [0, 0.69444, 0.09483, 0, 0.5],
              729: [0, 0.67937, 0.07774, 0, 0.27778],
              730: [0, 0.69444, 0, 0, 0.73752],
              732: [0, 0.67659, 0.08826, 0, 0.5],
              733: [0, 0.69444, 0.09205, 0, 0.5],
              915: [0, 0.69444, 0.13372, 0, 0.54167],
              916: [0, 0.69444, 0, 0, 0.83334],
              920: [0, 0.69444, 0.07555, 0, 0.77778],
              923: [0, 0.69444, 0, 0, 0.61111],
              926: [0, 0.69444, 0.12816, 0, 0.66667],
              928: [0, 0.69444, 0.08094, 0, 0.70834],
              931: [0, 0.69444, 0.11983, 0, 0.72222],
              933: [0, 0.69444, 0.09031, 0, 0.77778],
              934: [0, 0.69444, 0.04603, 0, 0.72222],
              936: [0, 0.69444, 0.09031, 0, 0.77778],
              937: [0, 0.69444, 0.08293, 0, 0.72222],
              8211: [0, 0.44444, 0.08616, 0, 0.5],
              8212: [0, 0.44444, 0.08616, 0, 1],
              8216: [0, 0.69444, 0.07816, 0, 0.27778],
              8217: [0, 0.69444, 0.07816, 0, 0.27778],
              8220: [0, 0.69444, 0.14205, 0, 0.5],
              8221: [0, 0.69444, 316e-5, 0, 0.5]
            },
            "SansSerif-Regular": {
              32: [0, 0, 0, 0, 0.25],
              33: [0, 0.69444, 0, 0, 0.31945],
              34: [0, 0.69444, 0, 0, 0.5],
              35: [0.19444, 0.69444, 0, 0, 0.83334],
              36: [0.05556, 0.75, 0, 0, 0.5],
              37: [0.05556, 0.75, 0, 0, 0.83334],
              38: [0, 0.69444, 0, 0, 0.75834],
              39: [0, 0.69444, 0, 0, 0.27778],
              40: [0.25, 0.75, 0, 0, 0.38889],
              41: [0.25, 0.75, 0, 0, 0.38889],
              42: [0, 0.75, 0, 0, 0.5],
              43: [0.08333, 0.58333, 0, 0, 0.77778],
              44: [0.125, 0.08333, 0, 0, 0.27778],
              45: [0, 0.44444, 0, 0, 0.33333],
              46: [0, 0.08333, 0, 0, 0.27778],
              47: [0.25, 0.75, 0, 0, 0.5],
              48: [0, 0.65556, 0, 0, 0.5],
              49: [0, 0.65556, 0, 0, 0.5],
              50: [0, 0.65556, 0, 0, 0.5],
              51: [0, 0.65556, 0, 0, 0.5],
              52: [0, 0.65556, 0, 0, 0.5],
              53: [0, 0.65556, 0, 0, 0.5],
              54: [0, 0.65556, 0, 0, 0.5],
              55: [0, 0.65556, 0, 0, 0.5],
              56: [0, 0.65556, 0, 0, 0.5],
              57: [0, 0.65556, 0, 0, 0.5],
              58: [0, 0.44444, 0, 0, 0.27778],
              59: [0.125, 0.44444, 0, 0, 0.27778],
              61: [-0.13, 0.37, 0, 0, 0.77778],
              63: [0, 0.69444, 0, 0, 0.47222],
              64: [0, 0.69444, 0, 0, 0.66667],
              65: [0, 0.69444, 0, 0, 0.66667],
              66: [0, 0.69444, 0, 0, 0.66667],
              67: [0, 0.69444, 0, 0, 0.63889],
              68: [0, 0.69444, 0, 0, 0.72223],
              69: [0, 0.69444, 0, 0, 0.59722],
              70: [0, 0.69444, 0, 0, 0.56945],
              71: [0, 0.69444, 0, 0, 0.66667],
              72: [0, 0.69444, 0, 0, 0.70834],
              73: [0, 0.69444, 0, 0, 0.27778],
              74: [0, 0.69444, 0, 0, 0.47222],
              75: [0, 0.69444, 0, 0, 0.69445],
              76: [0, 0.69444, 0, 0, 0.54167],
              77: [0, 0.69444, 0, 0, 0.875],
              78: [0, 0.69444, 0, 0, 0.70834],
              79: [0, 0.69444, 0, 0, 0.73611],
              80: [0, 0.69444, 0, 0, 0.63889],
              81: [0.125, 0.69444, 0, 0, 0.73611],
              82: [0, 0.69444, 0, 0, 0.64584],
              83: [0, 0.69444, 0, 0, 0.55556],
              84: [0, 0.69444, 0, 0, 0.68056],
              85: [0, 0.69444, 0, 0, 0.6875],
              86: [0, 0.69444, 0.01389, 0, 0.66667],
              87: [0, 0.69444, 0.01389, 0, 0.94445],
              88: [0, 0.69444, 0, 0, 0.66667],
              89: [0, 0.69444, 0.025, 0, 0.66667],
              90: [0, 0.69444, 0, 0, 0.61111],
              91: [0.25, 0.75, 0, 0, 0.28889],
              93: [0.25, 0.75, 0, 0, 0.28889],
              94: [0, 0.69444, 0, 0, 0.5],
              95: [0.35, 0.09444, 0.02778, 0, 0.5],
              97: [0, 0.44444, 0, 0, 0.48056],
              98: [0, 0.69444, 0, 0, 0.51667],
              99: [0, 0.44444, 0, 0, 0.44445],
              100: [0, 0.69444, 0, 0, 0.51667],
              101: [0, 0.44444, 0, 0, 0.44445],
              102: [0, 0.69444, 0.06944, 0, 0.30556],
              103: [0.19444, 0.44444, 0.01389, 0, 0.5],
              104: [0, 0.69444, 0, 0, 0.51667],
              105: [0, 0.67937, 0, 0, 0.23889],
              106: [0.19444, 0.67937, 0, 0, 0.26667],
              107: [0, 0.69444, 0, 0, 0.48889],
              108: [0, 0.69444, 0, 0, 0.23889],
              109: [0, 0.44444, 0, 0, 0.79445],
              110: [0, 0.44444, 0, 0, 0.51667],
              111: [0, 0.44444, 0, 0, 0.5],
              112: [0.19444, 0.44444, 0, 0, 0.51667],
              113: [0.19444, 0.44444, 0, 0, 0.51667],
              114: [0, 0.44444, 0.01389, 0, 0.34167],
              115: [0, 0.44444, 0, 0, 0.38333],
              116: [0, 0.57143, 0, 0, 0.36111],
              117: [0, 0.44444, 0, 0, 0.51667],
              118: [0, 0.44444, 0.01389, 0, 0.46111],
              119: [0, 0.44444, 0.01389, 0, 0.68334],
              120: [0, 0.44444, 0, 0, 0.46111],
              121: [0.19444, 0.44444, 0.01389, 0, 0.46111],
              122: [0, 0.44444, 0, 0, 0.43472],
              126: [0.35, 0.32659, 0, 0, 0.5],
              160: [0, 0, 0, 0, 0.25],
              168: [0, 0.67937, 0, 0, 0.5],
              176: [0, 0.69444, 0, 0, 0.66667],
              184: [0.17014, 0, 0, 0, 0.44445],
              305: [0, 0.44444, 0, 0, 0.23889],
              567: [0.19444, 0.44444, 0, 0, 0.26667],
              710: [0, 0.69444, 0, 0, 0.5],
              711: [0, 0.63194, 0, 0, 0.5],
              713: [0, 0.60889, 0, 0, 0.5],
              714: [0, 0.69444, 0, 0, 0.5],
              715: [0, 0.69444, 0, 0, 0.5],
              728: [0, 0.69444, 0, 0, 0.5],
              729: [0, 0.67937, 0, 0, 0.27778],
              730: [0, 0.69444, 0, 0, 0.66667],
              732: [0, 0.67659, 0, 0, 0.5],
              733: [0, 0.69444, 0, 0, 0.5],
              915: [0, 0.69444, 0, 0, 0.54167],
              916: [0, 0.69444, 0, 0, 0.83334],
              920: [0, 0.69444, 0, 0, 0.77778],
              923: [0, 0.69444, 0, 0, 0.61111],
              926: [0, 0.69444, 0, 0, 0.66667],
              928: [0, 0.69444, 0, 0, 0.70834],
              931: [0, 0.69444, 0, 0, 0.72222],
              933: [0, 0.69444, 0, 0, 0.77778],
              934: [0, 0.69444, 0, 0, 0.72222],
              936: [0, 0.69444, 0, 0, 0.77778],
              937: [0, 0.69444, 0, 0, 0.72222],
              8211: [0, 0.44444, 0.02778, 0, 0.5],
              8212: [0, 0.44444, 0.02778, 0, 1],
              8216: [0, 0.69444, 0, 0, 0.27778],
              8217: [0, 0.69444, 0, 0, 0.27778],
              8220: [0, 0.69444, 0, 0, 0.5],
              8221: [0, 0.69444, 0, 0, 0.5]
            },
            "Script-Regular": {
              32: [0, 0, 0, 0, 0.25],
              65: [0, 0.7, 0.22925, 0, 0.80253],
              66: [0, 0.7, 0.04087, 0, 0.90757],
              67: [0, 0.7, 0.1689, 0, 0.66619],
              68: [0, 0.7, 0.09371, 0, 0.77443],
              69: [0, 0.7, 0.18583, 0, 0.56162],
              70: [0, 0.7, 0.13634, 0, 0.89544],
              71: [0, 0.7, 0.17322, 0, 0.60961],
              72: [0, 0.7, 0.29694, 0, 0.96919],
              73: [0, 0.7, 0.19189, 0, 0.80907],
              74: [0.27778, 0.7, 0.19189, 0, 1.05159],
              75: [0, 0.7, 0.31259, 0, 0.91364],
              76: [0, 0.7, 0.19189, 0, 0.87373],
              77: [0, 0.7, 0.15981, 0, 1.08031],
              78: [0, 0.7, 0.3525, 0, 0.9015],
              79: [0, 0.7, 0.08078, 0, 0.73787],
              80: [0, 0.7, 0.08078, 0, 1.01262],
              81: [0, 0.7, 0.03305, 0, 0.88282],
              82: [0, 0.7, 0.06259, 0, 0.85],
              83: [0, 0.7, 0.19189, 0, 0.86767],
              84: [0, 0.7, 0.29087, 0, 0.74697],
              85: [0, 0.7, 0.25815, 0, 0.79996],
              86: [0, 0.7, 0.27523, 0, 0.62204],
              87: [0, 0.7, 0.27523, 0, 0.80532],
              88: [0, 0.7, 0.26006, 0, 0.94445],
              89: [0, 0.7, 0.2939, 0, 0.70961],
              90: [0, 0.7, 0.24037, 0, 0.8212],
              160: [0, 0, 0, 0, 0.25]
            },
            "Size1-Regular": {
              32: [0, 0, 0, 0, 0.25],
              40: [0.35001, 0.85, 0, 0, 0.45834],
              41: [0.35001, 0.85, 0, 0, 0.45834],
              47: [0.35001, 0.85, 0, 0, 0.57778],
              91: [0.35001, 0.85, 0, 0, 0.41667],
              92: [0.35001, 0.85, 0, 0, 0.57778],
              93: [0.35001, 0.85, 0, 0, 0.41667],
              123: [0.35001, 0.85, 0, 0, 0.58334],
              125: [0.35001, 0.85, 0, 0, 0.58334],
              160: [0, 0, 0, 0, 0.25],
              710: [0, 0.72222, 0, 0, 0.55556],
              732: [0, 0.72222, 0, 0, 0.55556],
              770: [0, 0.72222, 0, 0, 0.55556],
              771: [0, 0.72222, 0, 0, 0.55556],
              8214: [-99e-5, 0.601, 0, 0, 0.77778],
              8593: [1e-5, 0.6, 0, 0, 0.66667],
              8595: [1e-5, 0.6, 0, 0, 0.66667],
              8657: [1e-5, 0.6, 0, 0, 0.77778],
              8659: [1e-5, 0.6, 0, 0, 0.77778],
              8719: [0.25001, 0.75, 0, 0, 0.94445],
              8720: [0.25001, 0.75, 0, 0, 0.94445],
              8721: [0.25001, 0.75, 0, 0, 1.05556],
              8730: [0.35001, 0.85, 0, 0, 1],
              8739: [-599e-5, 0.606, 0, 0, 0.33333],
              8741: [-599e-5, 0.606, 0, 0, 0.55556],
              8747: [0.30612, 0.805, 0.19445, 0, 0.47222],
              8748: [0.306, 0.805, 0.19445, 0, 0.47222],
              8749: [0.306, 0.805, 0.19445, 0, 0.47222],
              8750: [0.30612, 0.805, 0.19445, 0, 0.47222],
              8896: [0.25001, 0.75, 0, 0, 0.83334],
              8897: [0.25001, 0.75, 0, 0, 0.83334],
              8898: [0.25001, 0.75, 0, 0, 0.83334],
              8899: [0.25001, 0.75, 0, 0, 0.83334],
              8968: [0.35001, 0.85, 0, 0, 0.47222],
              8969: [0.35001, 0.85, 0, 0, 0.47222],
              8970: [0.35001, 0.85, 0, 0, 0.47222],
              8971: [0.35001, 0.85, 0, 0, 0.47222],
              9168: [-99e-5, 0.601, 0, 0, 0.66667],
              10216: [0.35001, 0.85, 0, 0, 0.47222],
              10217: [0.35001, 0.85, 0, 0, 0.47222],
              10752: [0.25001, 0.75, 0, 0, 1.11111],
              10753: [0.25001, 0.75, 0, 0, 1.11111],
              10754: [0.25001, 0.75, 0, 0, 1.11111],
              10756: [0.25001, 0.75, 0, 0, 0.83334],
              10758: [0.25001, 0.75, 0, 0, 0.83334]
            },
            "Size2-Regular": {
              32: [0, 0, 0, 0, 0.25],
              40: [0.65002, 1.15, 0, 0, 0.59722],
              41: [0.65002, 1.15, 0, 0, 0.59722],
              47: [0.65002, 1.15, 0, 0, 0.81111],
              91: [0.65002, 1.15, 0, 0, 0.47222],
              92: [0.65002, 1.15, 0, 0, 0.81111],
              93: [0.65002, 1.15, 0, 0, 0.47222],
              123: [0.65002, 1.15, 0, 0, 0.66667],
              125: [0.65002, 1.15, 0, 0, 0.66667],
              160: [0, 0, 0, 0, 0.25],
              710: [0, 0.75, 0, 0, 1],
              732: [0, 0.75, 0, 0, 1],
              770: [0, 0.75, 0, 0, 1],
              771: [0, 0.75, 0, 0, 1],
              8719: [0.55001, 1.05, 0, 0, 1.27778],
              8720: [0.55001, 1.05, 0, 0, 1.27778],
              8721: [0.55001, 1.05, 0, 0, 1.44445],
              8730: [0.65002, 1.15, 0, 0, 1],
              8747: [0.86225, 1.36, 0.44445, 0, 0.55556],
              8748: [0.862, 1.36, 0.44445, 0, 0.55556],
              8749: [0.862, 1.36, 0.44445, 0, 0.55556],
              8750: [0.86225, 1.36, 0.44445, 0, 0.55556],
              8896: [0.55001, 1.05, 0, 0, 1.11111],
              8897: [0.55001, 1.05, 0, 0, 1.11111],
              8898: [0.55001, 1.05, 0, 0, 1.11111],
              8899: [0.55001, 1.05, 0, 0, 1.11111],
              8968: [0.65002, 1.15, 0, 0, 0.52778],
              8969: [0.65002, 1.15, 0, 0, 0.52778],
              8970: [0.65002, 1.15, 0, 0, 0.52778],
              8971: [0.65002, 1.15, 0, 0, 0.52778],
              10216: [0.65002, 1.15, 0, 0, 0.61111],
              10217: [0.65002, 1.15, 0, 0, 0.61111],
              10752: [0.55001, 1.05, 0, 0, 1.51112],
              10753: [0.55001, 1.05, 0, 0, 1.51112],
              10754: [0.55001, 1.05, 0, 0, 1.51112],
              10756: [0.55001, 1.05, 0, 0, 1.11111],
              10758: [0.55001, 1.05, 0, 0, 1.11111]
            },
            "Size3-Regular": {
              32: [0, 0, 0, 0, 0.25],
              40: [0.95003, 1.45, 0, 0, 0.73611],
              41: [0.95003, 1.45, 0, 0, 0.73611],
              47: [0.95003, 1.45, 0, 0, 1.04445],
              91: [0.95003, 1.45, 0, 0, 0.52778],
              92: [0.95003, 1.45, 0, 0, 1.04445],
              93: [0.95003, 1.45, 0, 0, 0.52778],
              123: [0.95003, 1.45, 0, 0, 0.75],
              125: [0.95003, 1.45, 0, 0, 0.75],
              160: [0, 0, 0, 0, 0.25],
              710: [0, 0.75, 0, 0, 1.44445],
              732: [0, 0.75, 0, 0, 1.44445],
              770: [0, 0.75, 0, 0, 1.44445],
              771: [0, 0.75, 0, 0, 1.44445],
              8730: [0.95003, 1.45, 0, 0, 1],
              8968: [0.95003, 1.45, 0, 0, 0.58334],
              8969: [0.95003, 1.45, 0, 0, 0.58334],
              8970: [0.95003, 1.45, 0, 0, 0.58334],
              8971: [0.95003, 1.45, 0, 0, 0.58334],
              10216: [0.95003, 1.45, 0, 0, 0.75],
              10217: [0.95003, 1.45, 0, 0, 0.75]
            },
            "Size4-Regular": {
              32: [0, 0, 0, 0, 0.25],
              40: [1.25003, 1.75, 0, 0, 0.79167],
              41: [1.25003, 1.75, 0, 0, 0.79167],
              47: [1.25003, 1.75, 0, 0, 1.27778],
              91: [1.25003, 1.75, 0, 0, 0.58334],
              92: [1.25003, 1.75, 0, 0, 1.27778],
              93: [1.25003, 1.75, 0, 0, 0.58334],
              123: [1.25003, 1.75, 0, 0, 0.80556],
              125: [1.25003, 1.75, 0, 0, 0.80556],
              160: [0, 0, 0, 0, 0.25],
              710: [0, 0.825, 0, 0, 1.8889],
              732: [0, 0.825, 0, 0, 1.8889],
              770: [0, 0.825, 0, 0, 1.8889],
              771: [0, 0.825, 0, 0, 1.8889],
              8730: [1.25003, 1.75, 0, 0, 1],
              8968: [1.25003, 1.75, 0, 0, 0.63889],
              8969: [1.25003, 1.75, 0, 0, 0.63889],
              8970: [1.25003, 1.75, 0, 0, 0.63889],
              8971: [1.25003, 1.75, 0, 0, 0.63889],
              9115: [0.64502, 1.155, 0, 0, 0.875],
              9116: [1e-5, 0.6, 0, 0, 0.875],
              9117: [0.64502, 1.155, 0, 0, 0.875],
              9118: [0.64502, 1.155, 0, 0, 0.875],
              9119: [1e-5, 0.6, 0, 0, 0.875],
              9120: [0.64502, 1.155, 0, 0, 0.875],
              9121: [0.64502, 1.155, 0, 0, 0.66667],
              9122: [-99e-5, 0.601, 0, 0, 0.66667],
              9123: [0.64502, 1.155, 0, 0, 0.66667],
              9124: [0.64502, 1.155, 0, 0, 0.66667],
              9125: [-99e-5, 0.601, 0, 0, 0.66667],
              9126: [0.64502, 1.155, 0, 0, 0.66667],
              9127: [1e-5, 0.9, 0, 0, 0.88889],
              9128: [0.65002, 1.15, 0, 0, 0.88889],
              9129: [0.90001, 0, 0, 0, 0.88889],
              9130: [0, 0.3, 0, 0, 0.88889],
              9131: [1e-5, 0.9, 0, 0, 0.88889],
              9132: [0.65002, 1.15, 0, 0, 0.88889],
              9133: [0.90001, 0, 0, 0, 0.88889],
              9143: [0.88502, 0.915, 0, 0, 1.05556],
              10216: [1.25003, 1.75, 0, 0, 0.80556],
              10217: [1.25003, 1.75, 0, 0, 0.80556],
              57344: [-499e-5, 0.605, 0, 0, 1.05556],
              57345: [-499e-5, 0.605, 0, 0, 1.05556],
              57680: [0, 0.12, 0, 0, 0.45],
              57681: [0, 0.12, 0, 0, 0.45],
              57682: [0, 0.12, 0, 0, 0.45],
              57683: [0, 0.12, 0, 0, 0.45]
            },
            "Typewriter-Regular": {
              32: [0, 0, 0, 0, 0.525],
              33: [0, 0.61111, 0, 0, 0.525],
              34: [0, 0.61111, 0, 0, 0.525],
              35: [0, 0.61111, 0, 0, 0.525],
              36: [0.08333, 0.69444, 0, 0, 0.525],
              37: [0.08333, 0.69444, 0, 0, 0.525],
              38: [0, 0.61111, 0, 0, 0.525],
              39: [0, 0.61111, 0, 0, 0.525],
              40: [0.08333, 0.69444, 0, 0, 0.525],
              41: [0.08333, 0.69444, 0, 0, 0.525],
              42: [0, 0.52083, 0, 0, 0.525],
              43: [-0.08056, 0.53055, 0, 0, 0.525],
              44: [0.13889, 0.125, 0, 0, 0.525],
              45: [-0.08056, 0.53055, 0, 0, 0.525],
              46: [0, 0.125, 0, 0, 0.525],
              47: [0.08333, 0.69444, 0, 0, 0.525],
              48: [0, 0.61111, 0, 0, 0.525],
              49: [0, 0.61111, 0, 0, 0.525],
              50: [0, 0.61111, 0, 0, 0.525],
              51: [0, 0.61111, 0, 0, 0.525],
              52: [0, 0.61111, 0, 0, 0.525],
              53: [0, 0.61111, 0, 0, 0.525],
              54: [0, 0.61111, 0, 0, 0.525],
              55: [0, 0.61111, 0, 0, 0.525],
              56: [0, 0.61111, 0, 0, 0.525],
              57: [0, 0.61111, 0, 0, 0.525],
              58: [0, 0.43056, 0, 0, 0.525],
              59: [0.13889, 0.43056, 0, 0, 0.525],
              60: [-0.05556, 0.55556, 0, 0, 0.525],
              61: [-0.19549, 0.41562, 0, 0, 0.525],
              62: [-0.05556, 0.55556, 0, 0, 0.525],
              63: [0, 0.61111, 0, 0, 0.525],
              64: [0, 0.61111, 0, 0, 0.525],
              65: [0, 0.61111, 0, 0, 0.525],
              66: [0, 0.61111, 0, 0, 0.525],
              67: [0, 0.61111, 0, 0, 0.525],
              68: [0, 0.61111, 0, 0, 0.525],
              69: [0, 0.61111, 0, 0, 0.525],
              70: [0, 0.61111, 0, 0, 0.525],
              71: [0, 0.61111, 0, 0, 0.525],
              72: [0, 0.61111, 0, 0, 0.525],
              73: [0, 0.61111, 0, 0, 0.525],
              74: [0, 0.61111, 0, 0, 0.525],
              75: [0, 0.61111, 0, 0, 0.525],
              76: [0, 0.61111, 0, 0, 0.525],
              77: [0, 0.61111, 0, 0, 0.525],
              78: [0, 0.61111, 0, 0, 0.525],
              79: [0, 0.61111, 0, 0, 0.525],
              80: [0, 0.61111, 0, 0, 0.525],
              81: [0.13889, 0.61111, 0, 0, 0.525],
              82: [0, 0.61111, 0, 0, 0.525],
              83: [0, 0.61111, 0, 0, 0.525],
              84: [0, 0.61111, 0, 0, 0.525],
              85: [0, 0.61111, 0, 0, 0.525],
              86: [0, 0.61111, 0, 0, 0.525],
              87: [0, 0.61111, 0, 0, 0.525],
              88: [0, 0.61111, 0, 0, 0.525],
              89: [0, 0.61111, 0, 0, 0.525],
              90: [0, 0.61111, 0, 0, 0.525],
              91: [0.08333, 0.69444, 0, 0, 0.525],
              92: [0.08333, 0.69444, 0, 0, 0.525],
              93: [0.08333, 0.69444, 0, 0, 0.525],
              94: [0, 0.61111, 0, 0, 0.525],
              95: [0.09514, 0, 0, 0, 0.525],
              96: [0, 0.61111, 0, 0, 0.525],
              97: [0, 0.43056, 0, 0, 0.525],
              98: [0, 0.61111, 0, 0, 0.525],
              99: [0, 0.43056, 0, 0, 0.525],
              100: [0, 0.61111, 0, 0, 0.525],
              101: [0, 0.43056, 0, 0, 0.525],
              102: [0, 0.61111, 0, 0, 0.525],
              103: [0.22222, 0.43056, 0, 0, 0.525],
              104: [0, 0.61111, 0, 0, 0.525],
              105: [0, 0.61111, 0, 0, 0.525],
              106: [0.22222, 0.61111, 0, 0, 0.525],
              107: [0, 0.61111, 0, 0, 0.525],
              108: [0, 0.61111, 0, 0, 0.525],
              109: [0, 0.43056, 0, 0, 0.525],
              110: [0, 0.43056, 0, 0, 0.525],
              111: [0, 0.43056, 0, 0, 0.525],
              112: [0.22222, 0.43056, 0, 0, 0.525],
              113: [0.22222, 0.43056, 0, 0, 0.525],
              114: [0, 0.43056, 0, 0, 0.525],
              115: [0, 0.43056, 0, 0, 0.525],
              116: [0, 0.55358, 0, 0, 0.525],
              117: [0, 0.43056, 0, 0, 0.525],
              118: [0, 0.43056, 0, 0, 0.525],
              119: [0, 0.43056, 0, 0, 0.525],
              120: [0, 0.43056, 0, 0, 0.525],
              121: [0.22222, 0.43056, 0, 0, 0.525],
              122: [0, 0.43056, 0, 0, 0.525],
              123: [0.08333, 0.69444, 0, 0, 0.525],
              124: [0.08333, 0.69444, 0, 0, 0.525],
              125: [0.08333, 0.69444, 0, 0, 0.525],
              126: [0, 0.61111, 0, 0, 0.525],
              127: [0, 0.61111, 0, 0, 0.525],
              160: [0, 0, 0, 0, 0.525],
              176: [0, 0.61111, 0, 0, 0.525],
              184: [0.19445, 0, 0, 0, 0.525],
              305: [0, 0.43056, 0, 0, 0.525],
              567: [0.22222, 0.43056, 0, 0, 0.525],
              711: [0, 0.56597, 0, 0, 0.525],
              713: [0, 0.56555, 0, 0, 0.525],
              714: [0, 0.61111, 0, 0, 0.525],
              715: [0, 0.61111, 0, 0, 0.525],
              728: [0, 0.61111, 0, 0, 0.525],
              730: [0, 0.61111, 0, 0, 0.525],
              770: [0, 0.61111, 0, 0, 0.525],
              771: [0, 0.61111, 0, 0, 0.525],
              776: [0, 0.61111, 0, 0, 0.525],
              915: [0, 0.61111, 0, 0, 0.525],
              916: [0, 0.61111, 0, 0, 0.525],
              920: [0, 0.61111, 0, 0, 0.525],
              923: [0, 0.61111, 0, 0, 0.525],
              926: [0, 0.61111, 0, 0, 0.525],
              928: [0, 0.61111, 0, 0, 0.525],
              931: [0, 0.61111, 0, 0, 0.525],
              933: [0, 0.61111, 0, 0, 0.525],
              934: [0, 0.61111, 0, 0, 0.525],
              936: [0, 0.61111, 0, 0, 0.525],
              937: [0, 0.61111, 0, 0, 0.525],
              8216: [0, 0.61111, 0, 0, 0.525],
              8217: [0, 0.61111, 0, 0, 0.525],
              8242: [0, 0.61111, 0, 0, 0.525],
              9251: [0.11111, 0.21944, 0, 0, 0.525]
            }
          };
          const hs = {
            slant: [0.25, 0.25, 0.25],
            // sigma1
            space: [0, 0, 0],
            // sigma2
            stretch: [0, 0, 0],
            // sigma3
            shrink: [0, 0, 0],
            // sigma4
            xHeight: [0.431, 0.431, 0.431],
            // sigma5
            quad: [1, 1.171, 1.472],
            // sigma6
            extraSpace: [0, 0, 0],
            // sigma7
            num1: [0.677, 0.732, 0.925],
            // sigma8
            num2: [0.394, 0.384, 0.387],
            // sigma9
            num3: [0.444, 0.471, 0.504],
            // sigma10
            denom1: [0.686, 0.752, 1.025],
            // sigma11
            denom2: [0.345, 0.344, 0.532],
            // sigma12
            sup1: [0.413, 0.503, 0.504],
            // sigma13
            sup2: [0.363, 0.431, 0.404],
            // sigma14
            sup3: [0.289, 0.286, 0.294],
            // sigma15
            sub1: [0.15, 0.143, 0.2],
            // sigma16
            sub2: [0.247, 0.286, 0.4],
            // sigma17
            supDrop: [0.386, 0.353, 0.494],
            // sigma18
            subDrop: [0.05, 0.071, 0.1],
            // sigma19
            delim1: [2.39, 1.7, 1.98],
            // sigma20
            delim2: [1.01, 1.157, 1.42],
            // sigma21
            axisHeight: [0.25, 0.25, 0.25],
            // sigma22
            // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
            // they correspond to the font parameters of the extension fonts (family 3).
            // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
            // match cmex7, we'd use cmex7.tfm values for script and scriptscript
            // values.
            defaultRuleThickness: [0.04, 0.049, 0.049],
            // xi8; cmex7: 0.049
            bigOpSpacing1: [0.111, 0.111, 0.111],
            // xi9
            bigOpSpacing2: [0.166, 0.166, 0.166],
            // xi10
            bigOpSpacing3: [0.2, 0.2, 0.2],
            // xi11
            bigOpSpacing4: [0.6, 0.611, 0.611],
            // xi12; cmex7: 0.611
            bigOpSpacing5: [0.1, 0.143, 0.143],
            // xi13; cmex7: 0.143
            // The \sqrt rule width is taken from the height of the surd character.
            // Since we use the same font at all sizes, this thickness doesn't scale.
            sqrtRuleThickness: [0.04, 0.04, 0.04],
            // This value determines how large a pt is, for metrics which are defined
            // in terms of pts.
            // This value is also used in katex.scss; if you change it make sure the
            // values match.
            ptPerEm: [10, 10, 10],
            // The space between adjacent `|` columns in an array definition. From
            // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
            doubleRuleSep: [0.2, 0.2, 0.2],
            // The width of separator lines in {array} environments. From
            // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
            arrayRuleWidth: [0.04, 0.04, 0.04],
            // Two values from LaTeX source2e:
            fboxsep: [0.3, 0.3, 0.3],
            //        3 pt / ptPerEm
            fboxrule: [0.04, 0.04, 0.04]
            // 0.4 pt / ptPerEm
          }, Sl = {
            // Latin-1
            Ã…: "A",
            Ã: "D",
            Ã: "o",
            Ã¥: "a",
            Ã°: "d",
            Ã¾: "o",
            // Cyrillic
            Ğ: "A",
            Ğ‘: "B",
            Ğ’: "B",
            Ğ“: "F",
            Ğ”: "A",
            Ğ•: "E",
            Ğ–: "K",
            Ğ—: "3",
            Ğ˜: "N",
            Ğ™: "N",
            Ğš: "K",
            Ğ›: "N",
            Ğœ: "M",
            Ğ: "H",
            Ğ: "O",
            ĞŸ: "N",
            Ğ : "P",
            Ğ¡: "C",
            Ğ¢: "T",
            Ğ£: "y",
            Ğ¤: "O",
            Ğ¥: "X",
            Ğ¦: "U",
            Ğ§: "h",
            Ğ¨: "W",
            Ğ©: "W",
            Ğª: "B",
            Ğ«: "X",
            Ğ¬: "B",
            Ğ­: "3",
            Ğ®: "X",
            Ğ¯: "R",
            Ğ°: "a",
            Ğ±: "b",
            Ğ²: "a",
            Ğ³: "r",
            Ğ´: "y",
            Ğµ: "e",
            Ğ¶: "m",
            Ğ·: "e",
            Ğ¸: "n",
            Ğ¹: "n",
            Ğº: "n",
            Ğ»: "n",
            Ğ¼: "m",
            Ğ½: "n",
            Ğ¾: "o",
            Ğ¿: "n",
            Ñ€: "p",
            Ñ: "c",
            Ñ‚: "o",
            Ñƒ: "y",
            Ñ„: "b",
            Ñ…: "x",
            Ñ†: "n",
            Ñ‡: "n",
            Ñˆ: "w",
            Ñ‰: "w",
            ÑŠ: "a",
            Ñ‹: "m",
            ÑŒ: "a",
            Ñ: "e",
            Ñ: "m",
            Ñ: "r"
          };
          function l2(a, u) {
            sn[a] = u;
          }
          function uu(a, u, c) {
            if (!sn[u])
              throw new Error("Font metrics not found for font: " + u + ".");
            let d = a.charCodeAt(0), m = sn[u][d];
            if (!m && a[0] in Sl && (d = Sl[a[0]].charCodeAt(0), m = sn[u][d]), !m && c === "text" && De(d) && (m = sn[u][77]), m)
              return {
                depth: m[0],
                height: m[1],
                italic: m[2],
                skew: m[3],
                width: m[4]
              };
          }
          const ou = {};
          function c2(a) {
            let u;
            if (a >= 5 ? u = 0 : a >= 3 ? u = 1 : u = 2, !ou[u]) {
              const c = ou[u] = {
                cssEmPerMu: hs.quad[u] / 18
              };
              for (const d in hs)
                hs.hasOwnProperty(d) && (c[d] = hs[d][u]);
            }
            return ou[u];
          }
          const f2 = [
            // Each element contains [textsize, scriptsize, scriptscriptsize].
            // The size mappings are taken from TeX with \normalsize=10pt.
            [1, 1, 1],
            // size1: [5, 5, 5]              \tiny
            [2, 1, 1],
            // size2: [6, 5, 5]
            [3, 1, 1],
            // size3: [7, 5, 5]              \scriptsize
            [4, 2, 1],
            // size4: [8, 6, 5]              \footnotesize
            [5, 2, 1],
            // size5: [9, 6, 5]              \small
            [6, 3, 1],
            // size6: [10, 7, 5]             \normalsize
            [7, 4, 2],
            // size7: [12, 8, 6]             \large
            [8, 6, 3],
            // size8: [14.4, 10, 7]          \Large
            [9, 7, 6],
            // size9: [17.28, 12, 10]        \LARGE
            [10, 8, 7],
            // size10: [20.74, 14.4, 12]     \huge
            [11, 10, 9]
            // size11: [24.88, 20.74, 17.28] \HUGE
          ], Al = [
            // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
            // you change size indexes, change that function.
            0.5,
            0.6,
            0.7,
            0.8,
            0.9,
            1,
            1.2,
            1.44,
            1.728,
            2.074,
            2.488
          ], El = function(a, u) {
            return u.size < 2 ? a : f2[a - 1][u.size - 1];
          };
          class vn {
            // A font family applies to a group of fonts (i.e. SansSerif), while a font
            // represents a specific font (i.e. SansSerif Bold).
            // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
            /**
             * The base size index.
             */
            constructor(u) {
              this.style = void 0, this.color = void 0, this.size = void 0, this.textSize = void 0, this.phantom = void 0, this.font = void 0, this.fontFamily = void 0, this.fontWeight = void 0, this.fontShape = void 0, this.sizeMultiplier = void 0, this.maxSize = void 0, this.minRuleThickness = void 0, this._fontMetrics = void 0, this.style = u.style, this.color = u.color, this.size = u.size || vn.BASESIZE, this.textSize = u.textSize || this.size, this.phantom = !!u.phantom, this.font = u.font || "", this.fontFamily = u.fontFamily || "", this.fontWeight = u.fontWeight || "", this.fontShape = u.fontShape || "", this.sizeMultiplier = Al[this.size - 1], this.maxSize = u.maxSize, this.minRuleThickness = u.minRuleThickness, this._fontMetrics = void 0;
            }
            /**
             * Returns a new options object with the same properties as "this".  Properties
             * from "extension" will be copied to the new options object.
             */
            extend(u) {
              const c = {
                style: this.style,
                size: this.size,
                textSize: this.textSize,
                color: this.color,
                phantom: this.phantom,
                font: this.font,
                fontFamily: this.fontFamily,
                fontWeight: this.fontWeight,
                fontShape: this.fontShape,
                maxSize: this.maxSize,
                minRuleThickness: this.minRuleThickness
              };
              for (const d in u)
                u.hasOwnProperty(d) && (c[d] = u[d]);
              return new vn(c);
            }
            /**
             * Return an options object with the given style. If `this.style === style`,
             * returns `this`.
             */
            havingStyle(u) {
              return this.style === u ? this : this.extend({
                style: u,
                size: El(this.textSize, u)
              });
            }
            /**
             * Return an options object with a cramped version of the current style. If
             * the current style is cramped, returns `this`.
             */
            havingCrampedStyle() {
              return this.havingStyle(this.style.cramp());
            }
            /**
             * Return an options object with the given size and in at least `\textstyle`.
             * Returns `this` if appropriate.
             */
            havingSize(u) {
              return this.size === u && this.textSize === u ? this : this.extend({
                style: this.style.text(),
                size: u,
                textSize: u,
                sizeMultiplier: Al[u - 1]
              });
            }
            /**
             * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
             * changes to at least `\textstyle`.
             */
            havingBaseStyle(u) {
              u = u || this.style.text();
              const c = El(vn.BASESIZE, u);
              return this.size === c && this.textSize === vn.BASESIZE && this.style === u ? this : this.extend({
                style: u,
                size: c
              });
            }
            /**
             * Remove the effect of sizing changes such as \Huge.
             * Keep the effect of the current style, such as \scriptstyle.
             */
            havingBaseSizing() {
              let u;
              switch (this.style.id) {
                case 4:
                case 5:
                  u = 3;
                  break;
                case 6:
                case 7:
                  u = 1;
                  break;
                default:
                  u = 6;
              }
              return this.extend({
                style: this.style.text(),
                size: u
              });
            }
            /**
             * Create a new options object with the given color.
             */
            withColor(u) {
              return this.extend({
                color: u
              });
            }
            /**
             * Create a new options object with "phantom" set to true.
             */
            withPhantom() {
              return this.extend({
                phantom: true
              });
            }
            /**
             * Creates a new options object with the given math font or old text font.
             * @type {[type]}
             */
            withFont(u) {
              return this.extend({
                font: u
              });
            }
            /**
             * Create a new options objects with the given fontFamily.
             */
            withTextFontFamily(u) {
              return this.extend({
                fontFamily: u,
                font: ""
              });
            }
            /**
             * Creates a new options object with the given font weight
             */
            withTextFontWeight(u) {
              return this.extend({
                fontWeight: u,
                font: ""
              });
            }
            /**
             * Creates a new options object with the given font weight
             */
            withTextFontShape(u) {
              return this.extend({
                fontShape: u,
                font: ""
              });
            }
            /**
             * Return the CSS sizing classes required to switch from enclosing options
             * `oldOptions` to `this`. Returns an array of classes.
             */
            sizingClasses(u) {
              return u.size !== this.size ? ["sizing", "reset-size" + u.size, "size" + this.size] : [];
            }
            /**
             * Return the CSS sizing classes required to switch to the base size. Like
             * `this.havingSize(BASESIZE).sizingClasses(this)`.
             */
            baseSizingClasses() {
              return this.size !== vn.BASESIZE ? ["sizing", "reset-size" + this.size, "size" + vn.BASESIZE] : [];
            }
            /**
             * Return the font metrics for this size.
             */
            fontMetrics() {
              return this._fontMetrics || (this._fontMetrics = c2(this.size)), this._fontMetrics;
            }
            /**
             * Gets the CSS color of the current options object
             */
            getColor() {
              return this.phantom ? "transparent" : this.color;
            }
          }
          vn.BASESIZE = 6;
          var h22 = vn;
          const au = {
            // https://en.wikibooks.org/wiki/LaTeX/Lengths and
            // https://tex.stackexchange.com/a/8263
            pt: 1,
            // TeX point
            mm: 7227 / 2540,
            // millimeter
            cm: 7227 / 254,
            // centimeter
            in: 72.27,
            // inch
            bp: 803 / 800,
            // big (PostScript) points
            pc: 12,
            // pica
            dd: 1238 / 1157,
            // didot
            cc: 14856 / 1157,
            // cicero (12 didot)
            nd: 685 / 642,
            // new didot
            nc: 1370 / 107,
            // new cicero (12 new didot)
            sp: 1 / 65536,
            // scaled point (TeX's internal smallest unit)
            // https://tex.stackexchange.com/a/41371
            px: 803 / 800
            // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
          }, d2 = {
            ex: true,
            em: true,
            mu: true
          }, Cl = function(a) {
            return typeof a != "string" && (a = a.unit), a in au || a in d2 || a === "ex";
          }, Qe = function(a, u) {
            let c;
            if (a.unit in au)
              c = au[a.unit] / u.fontMetrics().ptPerEm / u.sizeMultiplier;
            else if (a.unit === "mu")
              c = u.fontMetrics().cssEmPerMu;
            else {
              let d;
              if (u.style.isTight() ? d = u.havingStyle(u.style.text()) : d = u, a.unit === "ex")
                c = d.fontMetrics().xHeight;
              else if (a.unit === "em")
                c = d.fontMetrics().quad;
              else
                throw new s("Invalid unit: '" + a.unit + "'");
              d !== u && (c *= d.sizeMultiplier / u.sizeMultiplier);
            }
            return Math.min(a.number * c, u.maxSize);
          }, ce = function(a) {
            return +a.toFixed(4) + "em";
          }, Ln = function(a) {
            return a.filter((u) => u).join(" ");
          }, Tl = function(a, u, c) {
            if (this.classes = a || [], this.attributes = {}, this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = c || {}, u) {
              u.style.isTight() && this.classes.push("mtight");
              const d = u.getColor();
              d && (this.style.color = d);
            }
          }, Dl = function(a) {
            const u = document.createElement(a);
            u.className = Ln(this.classes);
            for (const c in this.style)
              this.style.hasOwnProperty(c) && (u.style[c] = this.style[c]);
            for (const c in this.attributes)
              this.attributes.hasOwnProperty(c) && u.setAttribute(c, this.attributes[c]);
            for (let c = 0; c < this.children.length; c++)
              u.appendChild(this.children[c].toNode());
            return u;
          }, p2 = /[\s"'>/=\x00-\x1f]/, Ml = function(a) {
            let u = "<" + a;
            this.classes.length && (u += ' class="' + D.escape(Ln(this.classes)) + '"');
            let c = "";
            for (const d in this.style)
              this.style.hasOwnProperty(d) && (c += D.hyphenate(d) + ":" + this.style[d] + ";");
            c && (u += ' style="' + D.escape(c) + '"');
            for (const d in this.attributes)
              if (this.attributes.hasOwnProperty(d)) {
                if (p2.test(d))
                  throw new s("Invalid attribute name '" + d + "'");
                u += " " + d + '="' + D.escape(this.attributes[d]) + '"';
              }
            u += ">";
            for (let d = 0; d < this.children.length; d++)
              u += this.children[d].toMarkup();
            return u += "</" + a + ">", u;
          };
          class hi {
            constructor(u, c, d, m) {
              this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.width = void 0, this.maxFontSize = void 0, this.style = void 0, Tl.call(this, u, d, m), this.children = c || [];
            }
            /**
             * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
             * all browsers support attributes the same, and having too many custom
             * attributes is probably bad.
             */
            setAttribute(u, c) {
              this.attributes[u] = c;
            }
            hasClass(u) {
              return D.contains(this.classes, u);
            }
            toNode() {
              return Dl.call(this, "span");
            }
            toMarkup() {
              return Ml.call(this, "span");
            }
          }
          class lu {
            constructor(u, c, d, m) {
              this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, Tl.call(this, c, m), this.children = d || [], this.setAttribute("href", u);
            }
            setAttribute(u, c) {
              this.attributes[u] = c;
            }
            hasClass(u) {
              return D.contains(this.classes, u);
            }
            toNode() {
              return Dl.call(this, "a");
            }
            toMarkup() {
              return Ml.call(this, "a");
            }
          }
          class m2 {
            constructor(u, c, d) {
              this.src = void 0, this.alt = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.alt = c, this.src = u, this.classes = ["mord"], this.style = d;
            }
            hasClass(u) {
              return D.contains(this.classes, u);
            }
            toNode() {
              const u = document.createElement("img");
              u.src = this.src, u.alt = this.alt, u.className = "mord";
              for (const c in this.style)
                this.style.hasOwnProperty(c) && (u.style[c] = this.style[c]);
              return u;
            }
            toMarkup() {
              let u = '<img src="' + D.escape(this.src) + '"' + (' alt="' + D.escape(this.alt) + '"'), c = "";
              for (const d in this.style)
                this.style.hasOwnProperty(d) && (c += D.hyphenate(d) + ":" + this.style[d] + ";");
              return c && (u += ' style="' + D.escape(c) + '"'), u += "'/>", u;
            }
          }
          const g2 = {
            Ã®: "Ä±Ì‚",
            Ã¯: "Ä±Ìˆ",
            Ã­: "Ä±Ì",
            // 'Ä«': '\u0131\u0304', // enable when we add Extended Latin
            Ã¬: "Ä±Ì€"
          };
          class Rt {
            constructor(u, c, d, m, y, _, E, M) {
              this.text = void 0, this.height = void 0, this.depth = void 0, this.italic = void 0, this.skew = void 0, this.width = void 0, this.maxFontSize = void 0, this.classes = void 0, this.style = void 0, this.text = u, this.height = c || 0, this.depth = d || 0, this.italic = m || 0, this.skew = y || 0, this.width = _ || 0, this.classes = E || [], this.style = M || {}, this.maxFontSize = 0;
              const B = he(this.text.charCodeAt(0));
              B && this.classes.push(B + "_fallback"), /[Ã®Ã¯Ã­Ã¬]/.test(this.text) && (this.text = g2[this.text]);
            }
            hasClass(u) {
              return D.contains(this.classes, u);
            }
            /**
             * Creates a text node or span from a symbol node. Note that a span is only
             * created if it is needed.
             */
            toNode() {
              const u = document.createTextNode(this.text);
              let c = null;
              this.italic > 0 && (c = document.createElement("span"), c.style.marginRight = ce(this.italic)), this.classes.length > 0 && (c = c || document.createElement("span"), c.className = Ln(this.classes));
              for (const d in this.style)
                this.style.hasOwnProperty(d) && (c = c || document.createElement("span"), c.style[d] = this.style[d]);
              return c ? (c.appendChild(u), c) : u;
            }
            /**
             * Creates markup for a symbol node.
             */
            toMarkup() {
              let u = false, c = "<span";
              this.classes.length && (u = true, c += ' class="', c += D.escape(Ln(this.classes)), c += '"');
              let d = "";
              this.italic > 0 && (d += "margin-right:" + this.italic + "em;");
              for (const y in this.style)
                this.style.hasOwnProperty(y) && (d += D.hyphenate(y) + ":" + this.style[y] + ";");
              d && (u = true, c += ' style="' + D.escape(d) + '"');
              const m = D.escape(this.text);
              return u ? (c += ">", c += m, c += "</span>", c) : m;
            }
          }
          class kn {
            constructor(u, c) {
              this.children = void 0, this.attributes = void 0, this.children = u || [], this.attributes = c || {};
            }
            toNode() {
              const c = document.createElementNS("http://www.w3.org/2000/svg", "svg");
              for (const d in this.attributes)
                Object.prototype.hasOwnProperty.call(this.attributes, d) && c.setAttribute(d, this.attributes[d]);
              for (let d = 0; d < this.children.length; d++)
                c.appendChild(this.children[d].toNode());
              return c;
            }
            toMarkup() {
              let u = '<svg xmlns="http://www.w3.org/2000/svg"';
              for (const c in this.attributes)
                Object.prototype.hasOwnProperty.call(this.attributes, c) && (u += " " + c + '="' + D.escape(this.attributes[c]) + '"');
              u += ">";
              for (let c = 0; c < this.children.length; c++)
                u += this.children[c].toMarkup();
              return u += "</svg>", u;
            }
          }
          class qn {
            constructor(u, c) {
              this.pathName = void 0, this.alternate = void 0, this.pathName = u, this.alternate = c;
            }
            toNode() {
              const c = document.createElementNS("http://www.w3.org/2000/svg", "path");
              return this.alternate ? c.setAttribute("d", this.alternate) : c.setAttribute("d", _l[this.pathName]), c;
            }
            toMarkup() {
              return this.alternate ? '<path d="' + D.escape(this.alternate) + '"/>' : '<path d="' + D.escape(_l[this.pathName]) + '"/>';
            }
          }
          class cu {
            constructor(u) {
              this.attributes = void 0, this.attributes = u || {};
            }
            toNode() {
              const c = document.createElementNS("http://www.w3.org/2000/svg", "line");
              for (const d in this.attributes)
                Object.prototype.hasOwnProperty.call(this.attributes, d) && c.setAttribute(d, this.attributes[d]);
              return c;
            }
            toMarkup() {
              let u = "<line";
              for (const c in this.attributes)
                Object.prototype.hasOwnProperty.call(this.attributes, c) && (u += " " + c + '="' + D.escape(this.attributes[c]) + '"');
              return u += "/>", u;
            }
          }
          function Nl(a) {
            if (a instanceof Rt)
              return a;
            throw new Error("Expected symbolNode but got " + String(a) + ".");
          }
          function b2(a) {
            if (a instanceof hi)
              return a;
            throw new Error("Expected span<HtmlDomNode> but got " + String(a) + ".");
          }
          const y2 = {
            bin: 1,
            close: 1,
            inner: 1,
            open: 1,
            punct: 1,
            rel: 1
          }, x2 = {
            "accent-token": 1,
            mathord: 1,
            "op-token": 1,
            spacing: 1,
            textord: 1
          }, ds = {
            math: {},
            text: {}
          };
          var et = ds;
          function g(a, u, c, d, m, y) {
            ds[a][m] = {
              font: u,
              group: c,
              replace: d
            }, y && d && (ds[a][d] = ds[a][m]);
          }
          const x = "math", ie = "text", S = "main", I = "ams", Ye = "accent-token", pe = "bin", kt = "close", Er = "inner", ye = "mathord", lt = "op-token", Ft = "open", ps = "punct", F = "rel", _n = "spacing", L = "textord";
          g(x, S, F, "â‰¡", "\\equiv", true), g(x, S, F, "â‰º", "\\prec", true), g(x, S, F, "â‰»", "\\succ", true), g(x, S, F, "âˆ¼", "\\sim", true), g(x, S, F, "âŠ¥", "\\perp"), g(x, S, F, "âª¯", "\\preceq", true), g(x, S, F, "âª°", "\\succeq", true), g(x, S, F, "â‰ƒ", "\\simeq", true), g(x, S, F, "âˆ£", "\\mid", true), g(x, S, F, "â‰ª", "\\ll", true), g(x, S, F, "â‰«", "\\gg", true), g(x, S, F, "â‰", "\\asymp", true), g(x, S, F, "âˆ¥", "\\parallel"), g(x, S, F, "â‹ˆ", "\\bowtie", true), g(x, S, F, "âŒ£", "\\smile", true), g(x, S, F, "âŠ‘", "\\sqsubseteq", true), g(x, S, F, "âŠ’", "\\sqsupseteq", true), g(x, S, F, "â‰", "\\doteq", true), g(x, S, F, "âŒ¢", "\\frown", true), g(x, S, F, "âˆ‹", "\\ni", true), g(x, S, F, "âˆ", "\\propto", true), g(x, S, F, "âŠ¢", "\\vdash", true), g(x, S, F, "âŠ£", "\\dashv", true), g(x, S, F, "âˆ‹", "\\owns"), g(x, S, ps, ".", "\\ldotp"), g(x, S, ps, "â‹…", "\\cdotp"), g(x, S, L, "#", "\\#"), g(ie, S, L, "#", "\\#"), g(x, S, L, "&", "\\&"), g(ie, S, L, "&", "\\&"), g(x, S, L, "â„µ", "\\aleph", true), g(x, S, L, "âˆ€", "\\forall", true), g(x, S, L, "â„", "\\hbar", true), g(x, S, L, "âˆƒ", "\\exists", true), g(x, S, L, "âˆ‡", "\\nabla", true), g(x, S, L, "â™­", "\\flat", true), g(x, S, L, "â„“", "\\ell", true), g(x, S, L, "â™®", "\\natural", true), g(x, S, L, "â™£", "\\clubsuit", true), g(x, S, L, "â„˜", "\\wp", true), g(x, S, L, "â™¯", "\\sharp", true), g(x, S, L, "â™¢", "\\diamondsuit", true), g(x, S, L, "â„œ", "\\Re", true), g(x, S, L, "â™¡", "\\heartsuit", true), g(x, S, L, "â„‘", "\\Im", true), g(x, S, L, "â™ ", "\\spadesuit", true), g(x, S, L, "Â§", "\\S", true), g(ie, S, L, "Â§", "\\S"), g(x, S, L, "Â¶", "\\P", true), g(ie, S, L, "Â¶", "\\P"), g(x, S, L, "â€ ", "\\dag"), g(ie, S, L, "â€ ", "\\dag"), g(ie, S, L, "â€ ", "\\textdagger"), g(x, S, L, "â€¡", "\\ddag"), g(ie, S, L, "â€¡", "\\ddag"), g(ie, S, L, "â€¡", "\\textdaggerdbl"), g(x, S, kt, "â±", "\\rmoustache", true), g(x, S, Ft, "â°", "\\lmoustache", true), g(x, S, kt, "âŸ¯", "\\rgroup", true), g(x, S, Ft, "âŸ®", "\\lgroup", true), g(x, S, pe, "âˆ“", "\\mp", true), g(x, S, pe, "âŠ–", "\\ominus", true), g(x, S, pe, "âŠ", "\\uplus", true), g(x, S, pe, "âŠ“", "\\sqcap", true), g(x, S, pe, "âˆ—", "\\ast"), g(x, S, pe, "âŠ”", "\\sqcup", true), g(x, S, pe, "â—¯", "\\bigcirc", true), g(x, S, pe, "âˆ™", "\\bullet", true), g(x, S, pe, "â€¡", "\\ddagger"), g(x, S, pe, "â‰€", "\\wr", true), g(x, S, pe, "â¨¿", "\\amalg"), g(x, S, pe, "&", "\\And"), g(x, S, F, "âŸµ", "\\longleftarrow", true), g(x, S, F, "â‡", "\\Leftarrow", true), g(x, S, F, "âŸ¸", "\\Longleftarrow", true), g(x, S, F, "âŸ¶", "\\longrightarrow", true), g(x, S, F, "â‡’", "\\Rightarrow", true), g(x, S, F, "âŸ¹", "\\Longrightarrow", true), g(x, S, F, "â†”", "\\leftrightarrow", true), g(x, S, F, "âŸ·", "\\longleftrightarrow", true), g(x, S, F, "â‡”", "\\Leftrightarrow", true), g(x, S, F, "âŸº", "\\Longleftrightarrow", true), g(x, S, F, "â†¦", "\\mapsto", true), g(x, S, F, "âŸ¼", "\\longmapsto", true), g(x, S, F, "â†—", "\\nearrow", true), g(x, S, F, "â†©", "\\hookleftarrow", true), g(x, S, F, "â†ª", "\\hookrightarrow", true), g(x, S, F, "â†˜", "\\searrow", true), g(x, S, F, "â†¼", "\\leftharpoonup", true), g(x, S, F, "â‡€", "\\rightharpoonup", true), g(x, S, F, "â†™", "\\swarrow", true), g(x, S, F, "â†½", "\\leftharpoondown", true), g(x, S, F, "â‡", "\\rightharpoondown", true), g(x, S, F, "â†–", "\\nwarrow", true), g(x, S, F, "â‡Œ", "\\rightleftharpoons", true), g(x, I, F, "â‰®", "\\nless", true), g(x, I, F, "î€", "\\@nleqslant"), g(x, I, F, "î€‘", "\\@nleqq"), g(x, I, F, "âª‡", "\\lneq", true), g(x, I, F, "â‰¨", "\\lneqq", true), g(x, I, F, "î€Œ", "\\@lvertneqq"), g(x, I, F, "â‹¦", "\\lnsim", true), g(x, I, F, "âª‰", "\\lnapprox", true), g(x, I, F, "âŠ€", "\\nprec", true), g(x, I, F, "â‹ ", "\\npreceq", true), g(x, I, F, "â‹¨", "\\precnsim", true), g(x, I, F, "âª¹", "\\precnapprox", true), g(x, I, F, "â‰", "\\nsim", true), g(x, I, F, "î€†", "\\@nshortmid"), g(x, I, F, "âˆ¤", "\\nmid", true), g(x, I, F, "âŠ¬", "\\nvdash", true), g(x, I, F, "âŠ­", "\\nvDash", true), g(x, I, F, "â‹ª", "\\ntriangleleft"), g(x, I, F, "â‹¬", "\\ntrianglelefteq", true), g(x, I, F, "âŠŠ", "\\subsetneq", true), g(x, I, F, "î€š", "\\@varsubsetneq"), g(x, I, F, "â«‹", "\\subsetneqq", true), g(x, I, F, "î€—", "\\@varsubsetneqq"), g(x, I, F, "â‰¯", "\\ngtr", true), g(x, I, F, "î€", "\\@ngeqslant"), g(x, I, F, "î€", "\\@ngeqq"), g(x, I, F, "âªˆ", "\\gneq", true), g(x, I, F, "â‰©", "\\gneqq", true), g(x, I, F, "î€", "\\@gvertneqq"), g(x, I, F, "â‹§", "\\gnsim", true), g(x, I, F, "âªŠ", "\\gnapprox", true), g(x, I, F, "âŠ", "\\nsucc", true), g(x, I, F, "â‹¡", "\\nsucceq", true), g(x, I, F, "â‹©", "\\succnsim", true), g(x, I, F, "âªº", "\\succnapprox", true), g(x, I, F, "â‰†", "\\ncong", true), g(x, I, F, "î€‡", "\\@nshortparallel"), g(x, I, F, "âˆ¦", "\\nparallel", true), g(x, I, F, "âŠ¯", "\\nVDash", true), g(x, I, F, "â‹«", "\\ntriangleright"), g(x, I, F, "â‹­", "\\ntrianglerighteq", true), g(x, I, F, "î€˜", "\\@nsupseteqq"), g(x, I, F, "âŠ‹", "\\supsetneq", true), g(x, I, F, "î€›", "\\@varsupsetneq"), g(x, I, F, "â«Œ", "\\supsetneqq", true), g(x, I, F, "î€™", "\\@varsupsetneqq"), g(x, I, F, "âŠ®", "\\nVdash", true), g(x, I, F, "âªµ", "\\precneqq", true), g(x, I, F, "âª¶", "\\succneqq", true), g(x, I, F, "î€–", "\\@nsubseteqq"), g(x, I, pe, "âŠ´", "\\unlhd"), g(x, I, pe, "âŠµ", "\\unrhd"), g(x, I, F, "â†š", "\\nleftarrow", true), g(x, I, F, "â†›", "\\nrightarrow", true), g(x, I, F, "â‡", "\\nLeftarrow", true), g(x, I, F, "â‡", "\\nRightarrow", true), g(x, I, F, "â†®", "\\nleftrightarrow", true), g(x, I, F, "â‡", "\\nLeftrightarrow", true), g(x, I, F, "â–³", "\\vartriangle"), g(x, I, L, "â„", "\\hslash"), g(x, I, L, "â–½", "\\triangledown"), g(x, I, L, "â—Š", "\\lozenge"), g(x, I, L, "â“ˆ", "\\circledS"), g(x, I, L, "Â®", "\\circledR"), g(ie, I, L, "Â®", "\\circledR"), g(x, I, L, "âˆ¡", "\\measuredangle", true), g(x, I, L, "âˆ„", "\\nexists"), g(x, I, L, "â„§", "\\mho"), g(x, I, L, "â„²", "\\Finv", true), g(x, I, L, "â…", "\\Game", true), g(x, I, L, "â€µ", "\\backprime"), g(x, I, L, "â–²", "\\blacktriangle"), g(x, I, L, "â–¼", "\\blacktriangledown"), g(x, I, L, "â– ", "\\blacksquare"), g(x, I, L, "â§«", "\\blacklozenge"), g(x, I, L, "â˜…", "\\bigstar"), g(x, I, L, "âˆ¢", "\\sphericalangle", true), g(x, I, L, "âˆ", "\\complement", true), g(x, I, L, "Ã°", "\\eth", true), g(ie, S, L, "Ã°", "Ã°"), g(x, I, L, "â•±", "\\diagup"), g(x, I, L, "â•²", "\\diagdown"), g(x, I, L, "â–¡", "\\square"), g(x, I, L, "â–¡", "\\Box"), g(x, I, L, "â—Š", "\\Diamond"), g(x, I, L, "Â¥", "\\yen", true), g(ie, I, L, "Â¥", "\\yen", true), g(x, I, L, "âœ“", "\\checkmark", true), g(ie, I, L, "âœ“", "\\checkmark"), g(x, I, L, "â„¶", "\\beth", true), g(x, I, L, "â„¸", "\\daleth", true), g(x, I, L, "â„·", "\\gimel", true), g(x, I, L, "Ï", "\\digamma", true), g(x, I, L, "Ï°", "\\varkappa"), g(x, I, Ft, "â”Œ", "\\@ulcorner", true), g(x, I, kt, "â”", "\\@urcorner", true), g(x, I, Ft, "â””", "\\@llcorner", true), g(x, I, kt, "â”˜", "\\@lrcorner", true), g(x, I, F, "â‰¦", "\\leqq", true), g(x, I, F, "â©½", "\\leqslant", true), g(x, I, F, "âª•", "\\eqslantless", true), g(x, I, F, "â‰²", "\\lesssim", true), g(x, I, F, "âª…", "\\lessapprox", true), g(x, I, F, "â‰Š", "\\approxeq", true), g(x, I, pe, "â‹–", "\\lessdot"), g(x, I, F, "â‹˜", "\\lll", true), g(x, I, F, "â‰¶", "\\lessgtr", true), g(x, I, F, "â‹š", "\\lesseqgtr", true), g(x, I, F, "âª‹", "\\lesseqqgtr", true), g(x, I, F, "â‰‘", "\\doteqdot"), g(x, I, F, "â‰“", "\\risingdotseq", true), g(x, I, F, "â‰’", "\\fallingdotseq", true), g(x, I, F, "âˆ½", "\\backsim", true), g(x, I, F, "â‹", "\\backsimeq", true), g(x, I, F, "â«…", "\\subseteqq", true), g(x, I, F, "â‹", "\\Subset", true), g(x, I, F, "âŠ", "\\sqsubset", true), g(x, I, F, "â‰¼", "\\preccurlyeq", true), g(x, I, F, "â‹", "\\curlyeqprec", true), g(x, I, F, "â‰¾", "\\precsim", true), g(x, I, F, "âª·", "\\precapprox", true), g(x, I, F, "âŠ²", "\\vartriangleleft"), g(x, I, F, "âŠ´", "\\trianglelefteq"), g(x, I, F, "âŠ¨", "\\vDash", true), g(x, I, F, "âŠª", "\\Vvdash", true), g(x, I, F, "âŒ£", "\\smallsmile"), g(x, I, F, "âŒ¢", "\\smallfrown"), g(x, I, F, "â‰", "\\bumpeq", true), g(x, I, F, "â‰", "\\Bumpeq", true), g(x, I, F, "â‰§", "\\geqq", true), g(x, I, F, "â©¾", "\\geqslant", true), g(x, I, F, "âª–", "\\eqslantgtr", true), g(x, I, F, "â‰³", "\\gtrsim", true), g(x, I, F, "âª†", "\\gtrapprox", true), g(x, I, pe, "â‹—", "\\gtrdot"), g(x, I, F, "â‹™", "\\ggg", true), g(x, I, F, "â‰·", "\\gtrless", true), g(x, I, F, "â‹›", "\\gtreqless", true), g(x, I, F, "âªŒ", "\\gtreqqless", true), g(x, I, F, "â‰–", "\\eqcirc", true), g(x, I, F, "â‰—", "\\circeq", true), g(x, I, F, "â‰œ", "\\triangleq", true), g(x, I, F, "âˆ¼", "\\thicksim"), g(x, I, F, "â‰ˆ", "\\thickapprox"), g(x, I, F, "â«†", "\\supseteqq", true), g(x, I, F, "â‹‘", "\\Supset", true), g(x, I, F, "âŠ", "\\sqsupset", true), g(x, I, F, "â‰½", "\\succcurlyeq", true), g(x, I, F, "â‹Ÿ", "\\curlyeqsucc", true), g(x, I, F, "â‰¿", "\\succsim", true), g(x, I, F, "âª¸", "\\succapprox", true), g(x, I, F, "âŠ³", "\\vartriangleright"), g(x, I, F, "âŠµ", "\\trianglerighteq"), g(x, I, F, "âŠ©", "\\Vdash", true), g(x, I, F, "âˆ£", "\\shortmid"), g(x, I, F, "âˆ¥", "\\shortparallel"), g(x, I, F, "â‰¬", "\\between", true), g(x, I, F, "â‹”", "\\pitchfork", true), g(x, I, F, "âˆ", "\\varpropto"), g(x, I, F, "â—€", "\\blacktriangleleft"), g(x, I, F, "âˆ´", "\\therefore", true), g(x, I, F, "âˆ", "\\backepsilon"), g(x, I, F, "â–¶", "\\blacktriangleright"), g(x, I, F, "âˆµ", "\\because", true), g(x, I, F, "â‹˜", "\\llless"), g(x, I, F, "â‹™", "\\gggtr"), g(x, I, pe, "âŠ²", "\\lhd"), g(x, I, pe, "âŠ³", "\\rhd"), g(x, I, F, "â‰‚", "\\eqsim", true), g(x, S, F, "â‹ˆ", "\\Join"), g(x, I, F, "â‰‘", "\\Doteq", true), g(x, I, pe, "âˆ”", "\\dotplus", true), g(x, I, pe, "âˆ–", "\\smallsetminus"), g(x, I, pe, "â‹’", "\\Cap", true), g(x, I, pe, "â‹“", "\\Cup", true), g(x, I, pe, "â©", "\\doublebarwedge", true), g(x, I, pe, "âŠŸ", "\\boxminus", true), g(x, I, pe, "âŠ", "\\boxplus", true), g(x, I, pe, "â‹‡", "\\divideontimes", true), g(x, I, pe, "â‹‰", "\\ltimes", true), g(x, I, pe, "â‹Š", "\\rtimes", true), g(x, I, pe, "â‹‹", "\\leftthreetimes", true), g(x, I, pe, "â‹Œ", "\\rightthreetimes", true), g(x, I, pe, "â‹", "\\curlywedge", true), g(x, I, pe, "â‹", "\\curlyvee", true), g(x, I, pe, "âŠ", "\\circleddash", true), g(x, I, pe, "âŠ›", "\\circledast", true), g(x, I, pe, "â‹…", "\\centerdot"), g(x, I, pe, "âŠº", "\\intercal", true), g(x, I, pe, "â‹’", "\\doublecap"), g(x, I, pe, "â‹“", "\\doublecup"), g(x, I, pe, "âŠ ", "\\boxtimes", true), g(x, I, F, "â‡¢", "\\dashrightarrow", true), g(x, I, F, "â‡ ", "\\dashleftarrow", true), g(x, I, F, "â‡‡", "\\leftleftarrows", true), g(x, I, F, "â‡†", "\\leftrightarrows", true), g(x, I, F, "â‡š", "\\Lleftarrow", true), g(x, I, F, "â†", "\\twoheadleftarrow", true), g(x, I, F, "â†¢", "\\leftarrowtail", true), g(x, I, F, "â†«", "\\looparrowleft", true), g(x, I, F, "â‡‹", "\\leftrightharpoons", true), g(x, I, F, "â†¶", "\\curvearrowleft", true), g(x, I, F, "â†º", "\\circlearrowleft", true), g(x, I, F, "â†°", "\\Lsh", true), g(x, I, F, "â‡ˆ", "\\upuparrows", true), g(x, I, F, "â†¿", "\\upharpoonleft", true), g(x, I, F, "â‡ƒ", "\\downharpoonleft", true), g(x, S, F, "âŠ¶", "\\origof", true), g(x, S, F, "âŠ·", "\\imageof", true), g(x, I, F, "âŠ¸", "\\multimap", true), g(x, I, F, "â†­", "\\leftrightsquigarrow", true), g(x, I, F, "â‡‰", "\\rightrightarrows", true), g(x, I, F, "â‡„", "\\rightleftarrows", true), g(x, I, F, "â† ", "\\twoheadrightarrow", true), g(x, I, F, "â†£", "\\rightarrowtail", true), g(x, I, F, "â†¬", "\\looparrowright", true), g(x, I, F, "â†·", "\\curvearrowright", true), g(x, I, F, "â†»", "\\circlearrowright", true), g(x, I, F, "â†±", "\\Rsh", true), g(x, I, F, "â‡Š", "\\downdownarrows", true), g(x, I, F, "â†¾", "\\upharpoonright", true), g(x, I, F, "â‡‚", "\\downharpoonright", true), g(x, I, F, "â‡", "\\rightsquigarrow", true), g(x, I, F, "â‡", "\\leadsto"), g(x, I, F, "â‡›", "\\Rrightarrow", true), g(x, I, F, "â†¾", "\\restriction"), g(x, S, L, "â€˜", "`"), g(x, S, L, "$", "\\$"), g(ie, S, L, "$", "\\$"), g(ie, S, L, "$", "\\textdollar"), g(x, S, L, "%", "\\%"), g(ie, S, L, "%", "\\%"), g(x, S, L, "_", "\\_"), g(ie, S, L, "_", "\\_"), g(ie, S, L, "_", "\\textunderscore"), g(x, S, L, "âˆ ", "\\angle", true), g(x, S, L, "âˆ", "\\infty", true), g(x, S, L, "â€²", "\\prime"), g(x, S, L, "â–³", "\\triangle"), g(x, S, L, "Î“", "\\Gamma", true), g(x, S, L, "Î”", "\\Delta", true), g(x, S, L, "Î˜", "\\Theta", true), g(x, S, L, "Î›", "\\Lambda", true), g(x, S, L, "Î", "\\Xi", true), g(x, S, L, "Î ", "\\Pi", true), g(x, S, L, "Î£", "\\Sigma", true), g(x, S, L, "Î¥", "\\Upsilon", true), g(x, S, L, "Î¦", "\\Phi", true), g(x, S, L, "Î¨", "\\Psi", true), g(x, S, L, "Î©", "\\Omega", true), g(x, S, L, "A", "Î‘"), g(x, S, L, "B", "Î’"), g(x, S, L, "E", "Î•"), g(x, S, L, "Z", "Î–"), g(x, S, L, "H", "Î—"), g(x, S, L, "I", "Î™"), g(x, S, L, "K", "Îš"), g(x, S, L, "M", "Îœ"), g(x, S, L, "N", "Î"), g(x, S, L, "O", "ÎŸ"), g(x, S, L, "P", "Î¡"), g(x, S, L, "T", "Î¤"), g(x, S, L, "X", "Î§"), g(x, S, L, "Â¬", "\\neg", true), g(x, S, L, "Â¬", "\\lnot"), g(x, S, L, "âŠ¤", "\\top"), g(x, S, L, "âŠ¥", "\\bot"), g(x, S, L, "âˆ…", "\\emptyset"), g(x, I, L, "âˆ…", "\\varnothing"), g(x, S, ye, "Î±", "\\alpha", true), g(x, S, ye, "Î²", "\\beta", true), g(x, S, ye, "Î³", "\\gamma", true), g(x, S, ye, "Î´", "\\delta", true), g(x, S, ye, "Ïµ", "\\epsilon", true), g(x, S, ye, "Î¶", "\\zeta", true), g(x, S, ye, "Î·", "\\eta", true), g(x, S, ye, "Î¸", "\\theta", true), g(x, S, ye, "Î¹", "\\iota", true), g(x, S, ye, "Îº", "\\kappa", true), g(x, S, ye, "Î»", "\\lambda", true), g(x, S, ye, "Î¼", "\\mu", true), g(x, S, ye, "Î½", "\\nu", true), g(x, S, ye, "Î¾", "\\xi", true), g(x, S, ye, "Î¿", "\\omicron", true), g(x, S, ye, "Ï€", "\\pi", true), g(x, S, ye, "Ï", "\\rho", true), g(x, S, ye, "Ïƒ", "\\sigma", true), g(x, S, ye, "Ï„", "\\tau", true), g(x, S, ye, "Ï…", "\\upsilon", true), g(x, S, ye, "Ï•", "\\phi", true), g(x, S, ye, "Ï‡", "\\chi", true), g(x, S, ye, "Ïˆ", "\\psi", true), g(x, S, ye, "Ï‰", "\\omega", true), g(x, S, ye, "Îµ", "\\varepsilon", true), g(x, S, ye, "Ï‘", "\\vartheta", true), g(x, S, ye, "Ï–", "\\varpi", true), g(x, S, ye, "Ï±", "\\varrho", true), g(x, S, ye, "Ï‚", "\\varsigma", true), g(x, S, ye, "Ï†", "\\varphi", true), g(x, S, pe, "âˆ—", "*", true), g(x, S, pe, "+", "+"), g(x, S, pe, "âˆ’", "-", true), g(x, S, pe, "â‹…", "\\cdot", true), g(x, S, pe, "âˆ˜", "\\circ", true), g(x, S, pe, "Ã·", "\\div", true), g(x, S, pe, "Â±", "\\pm", true), g(x, S, pe, "Ã—", "\\times", true), g(x, S, pe, "âˆ©", "\\cap", true), g(x, S, pe, "âˆª", "\\cup", true), g(x, S, pe, "âˆ–", "\\setminus", true), g(x, S, pe, "âˆ§", "\\land"), g(x, S, pe, "âˆ¨", "\\lor"), g(x, S, pe, "âˆ§", "\\wedge", true), g(x, S, pe, "âˆ¨", "\\vee", true), g(x, S, L, "âˆš", "\\surd"), g(x, S, Ft, "âŸ¨", "\\langle", true), g(x, S, Ft, "âˆ£", "\\lvert"), g(x, S, Ft, "âˆ¥", "\\lVert"), g(x, S, kt, "?", "?"), g(x, S, kt, "!", "!"), g(x, S, kt, "âŸ©", "\\rangle", true), g(x, S, kt, "âˆ£", "\\rvert"), g(x, S, kt, "âˆ¥", "\\rVert"), g(x, S, F, "=", "="), g(x, S, F, ":", ":"), g(x, S, F, "â‰ˆ", "\\approx", true), g(x, S, F, "â‰…", "\\cong", true), g(x, S, F, "â‰¥", "\\ge"), g(x, S, F, "â‰¥", "\\geq", true), g(x, S, F, "â†", "\\gets"), g(x, S, F, ">", "\\gt", true), g(x, S, F, "âˆˆ", "\\in", true), g(x, S, F, "î€ ", "\\@not"), g(x, S, F, "âŠ‚", "\\subset", true), g(x, S, F, "âŠƒ", "\\supset", true), g(x, S, F, "âŠ†", "\\subseteq", true), g(x, S, F, "âŠ‡", "\\supseteq", true), g(x, I, F, "âŠˆ", "\\nsubseteq", true), g(x, I, F, "âŠ‰", "\\nsupseteq", true), g(x, S, F, "âŠ¨", "\\models"), g(x, S, F, "â†", "\\leftarrow", true), g(x, S, F, "â‰¤", "\\le"), g(x, S, F, "â‰¤", "\\leq", true), g(x, S, F, "<", "\\lt", true), g(x, S, F, "â†’", "\\rightarrow", true), g(x, S, F, "â†’", "\\to"), g(x, I, F, "â‰±", "\\ngeq", true), g(x, I, F, "â‰°", "\\nleq", true), g(x, S, _n, "Â ", "\\ "), g(x, S, _n, "Â ", "\\space"), g(x, S, _n, "Â ", "\\nobreakspace"), g(ie, S, _n, "Â ", "\\ "), g(ie, S, _n, "Â ", " "), g(ie, S, _n, "Â ", "\\space"), g(ie, S, _n, "Â ", "\\nobreakspace"), g(x, S, _n, null, "\\nobreak"), g(x, S, _n, null, "\\allowbreak"), g(x, S, ps, ",", ","), g(x, S, ps, ";", ";"), g(x, I, pe, "âŠ¼", "\\barwedge", true), g(x, I, pe, "âŠ»", "\\veebar", true), g(x, S, pe, "âŠ™", "\\odot", true), g(x, S, pe, "âŠ•", "\\oplus", true), g(x, S, pe, "âŠ—", "\\otimes", true), g(x, S, L, "âˆ‚", "\\partial", true), g(x, S, pe, "âŠ˜", "\\oslash", true), g(x, I, pe, "âŠš", "\\circledcirc", true), g(x, I, pe, "âŠ¡", "\\boxdot", true), g(x, S, pe, "â–³", "\\bigtriangleup"), g(x, S, pe, "â–½", "\\bigtriangledown"), g(x, S, pe, "â€ ", "\\dagger"), g(x, S, pe, "â‹„", "\\diamond"), g(x, S, pe, "â‹†", "\\star"), g(x, S, pe, "â—ƒ", "\\triangleleft"), g(x, S, pe, "â–¹", "\\triangleright"), g(x, S, Ft, "{", "\\{"), g(ie, S, L, "{", "\\{"), g(ie, S, L, "{", "\\textbraceleft"), g(x, S, kt, "}", "\\}"), g(ie, S, L, "}", "\\}"), g(ie, S, L, "}", "\\textbraceright"), g(x, S, Ft, "{", "\\lbrace"), g(x, S, kt, "}", "\\rbrace"), g(x, S, Ft, "[", "\\lbrack", true), g(ie, S, L, "[", "\\lbrack", true), g(x, S, kt, "]", "\\rbrack", true), g(ie, S, L, "]", "\\rbrack", true), g(x, S, Ft, "(", "\\lparen", true), g(x, S, kt, ")", "\\rparen", true), g(ie, S, L, "<", "\\textless", true), g(ie, S, L, ">", "\\textgreater", true), g(x, S, Ft, "âŒŠ", "\\lfloor", true), g(x, S, kt, "âŒ‹", "\\rfloor", true), g(x, S, Ft, "âŒˆ", "\\lceil", true), g(x, S, kt, "âŒ‰", "\\rceil", true), g(x, S, L, "\\", "\\backslash"), g(x, S, L, "âˆ£", "|"), g(x, S, L, "âˆ£", "\\vert"), g(ie, S, L, "|", "\\textbar", true), g(x, S, L, "âˆ¥", "\\|"), g(x, S, L, "âˆ¥", "\\Vert"), g(ie, S, L, "âˆ¥", "\\textbardbl"), g(ie, S, L, "~", "\\textasciitilde"), g(ie, S, L, "\\", "\\textbackslash"), g(ie, S, L, "^", "\\textasciicircum"), g(x, S, F, "â†‘", "\\uparrow", true), g(x, S, F, "â‡‘", "\\Uparrow", true), g(x, S, F, "â†“", "\\downarrow", true), g(x, S, F, "â‡“", "\\Downarrow", true), g(x, S, F, "â†•", "\\updownarrow", true), g(x, S, F, "â‡•", "\\Updownarrow", true), g(x, S, lt, "âˆ", "\\coprod"), g(x, S, lt, "â‹", "\\bigvee"), g(x, S, lt, "â‹€", "\\bigwedge"), g(x, S, lt, "â¨„", "\\biguplus"), g(x, S, lt, "â‹‚", "\\bigcap"), g(x, S, lt, "â‹ƒ", "\\bigcup"), g(x, S, lt, "âˆ«", "\\int"), g(x, S, lt, "âˆ«", "\\intop"), g(x, S, lt, "âˆ¬", "\\iint"), g(x, S, lt, "âˆ­", "\\iiint"), g(x, S, lt, "âˆ", "\\prod"), g(x, S, lt, "âˆ‘", "\\sum"), g(x, S, lt, "â¨‚", "\\bigotimes"), g(x, S, lt, "â¨", "\\bigoplus"), g(x, S, lt, "â¨€", "\\bigodot"), g(x, S, lt, "âˆ®", "\\oint"), g(x, S, lt, "âˆ¯", "\\oiint"), g(x, S, lt, "âˆ°", "\\oiiint"), g(x, S, lt, "â¨†", "\\bigsqcup"), g(x, S, lt, "âˆ«", "\\smallint"), g(ie, S, Er, "â€¦", "\\textellipsis"), g(x, S, Er, "â€¦", "\\mathellipsis"), g(ie, S, Er, "â€¦", "\\ldots", true), g(x, S, Er, "â€¦", "\\ldots", true), g(x, S, Er, "â‹¯", "\\@cdots", true), g(x, S, Er, "â‹±", "\\ddots", true), g(x, S, L, "â‹®", "\\varvdots"), g(ie, S, L, "â‹®", "\\varvdots"), g(x, S, Ye, "ËŠ", "\\acute"), g(x, S, Ye, "Ë‹", "\\grave"), g(x, S, Ye, "Â¨", "\\ddot"), g(x, S, Ye, "~", "\\tilde"), g(x, S, Ye, "Ë‰", "\\bar"), g(x, S, Ye, "Ë˜", "\\breve"), g(x, S, Ye, "Ë‡", "\\check"), g(x, S, Ye, "^", "\\hat"), g(x, S, Ye, "âƒ—", "\\vec"), g(x, S, Ye, "Ë™", "\\dot"), g(x, S, Ye, "Ëš", "\\mathring"), g(x, S, ye, "î„±", "\\@imath"), g(x, S, ye, "îˆ·", "\\@jmath"), g(x, S, L, "Ä±", "Ä±"), g(x, S, L, "È·", "È·"), g(ie, S, L, "Ä±", "\\i", true), g(ie, S, L, "È·", "\\j", true), g(ie, S, L, "ÃŸ", "\\ss", true), g(ie, S, L, "Ã¦", "\\ae", true), g(ie, S, L, "Å“", "\\oe", true), g(ie, S, L, "Ã¸", "\\o", true), g(ie, S, L, "Ã†", "\\AE", true), g(ie, S, L, "Å’", "\\OE", true), g(ie, S, L, "Ã˜", "\\O", true), g(ie, S, Ye, "ËŠ", "\\'"), g(ie, S, Ye, "Ë‹", "\\`"), g(ie, S, Ye, "Ë†", "\\^"), g(ie, S, Ye, "Ëœ", "\\~"), g(ie, S, Ye, "Ë‰", "\\="), g(ie, S, Ye, "Ë˜", "\\u"), g(ie, S, Ye, "Ë™", "\\."), g(ie, S, Ye, "Â¸", "\\c"), g(ie, S, Ye, "Ëš", "\\r"), g(ie, S, Ye, "Ë‡", "\\v"), g(ie, S, Ye, "Â¨", '\\"'), g(ie, S, Ye, "Ë", "\\H"), g(ie, S, Ye, "â—¯", "\\textcircled");
          const Il = {
            "--": true,
            "---": true,
            "``": true,
            "''": true
          };
          g(ie, S, L, "â€“", "--", true), g(ie, S, L, "â€“", "\\textendash"), g(ie, S, L, "â€”", "---", true), g(ie, S, L, "â€”", "\\textemdash"), g(ie, S, L, "â€˜", "`", true), g(ie, S, L, "â€˜", "\\textquoteleft"), g(ie, S, L, "â€™", "'", true), g(ie, S, L, "â€™", "\\textquoteright"), g(ie, S, L, "â€œ", "``", true), g(ie, S, L, "â€œ", "\\textquotedblleft"), g(ie, S, L, "â€", "''", true), g(ie, S, L, "â€", "\\textquotedblright"), g(x, S, L, "Â°", "\\degree", true), g(ie, S, L, "Â°", "\\degree"), g(ie, S, L, "Â°", "\\textdegree", true), g(x, S, L, "Â£", "\\pounds"), g(x, S, L, "Â£", "\\mathsterling", true), g(ie, S, L, "Â£", "\\pounds"), g(ie, S, L, "Â£", "\\textsterling", true), g(x, I, L, "âœ ", "\\maltese"), g(ie, I, L, "âœ ", "\\maltese");
          const Fl = '0123456789/@."';
          for (let a = 0; a < Fl.length; a++) {
            const u = Fl.charAt(a);
            g(x, S, L, u, u);
          }
          const Bl = '0123456789!@*()-=+";:?/.,';
          for (let a = 0; a < Bl.length; a++) {
            const u = Bl.charAt(a);
            g(ie, S, L, u, u);
          }
          const ms = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
          for (let a = 0; a < ms.length; a++) {
            const u = ms.charAt(a);
            g(x, S, ye, u, u), g(ie, S, L, u, u);
          }
          g(x, I, L, "C", "â„‚"), g(ie, I, L, "C", "â„‚"), g(x, I, L, "H", "â„"), g(ie, I, L, "H", "â„"), g(x, I, L, "N", "â„•"), g(ie, I, L, "N", "â„•"), g(x, I, L, "P", "â„™"), g(ie, I, L, "P", "â„™"), g(x, I, L, "Q", "â„š"), g(ie, I, L, "Q", "â„š"), g(x, I, L, "R", "â„"), g(ie, I, L, "R", "â„"), g(x, I, L, "Z", "â„¤"), g(ie, I, L, "Z", "â„¤"), g(x, S, ye, "h", "â„"), g(ie, S, ye, "h", "â„");
          let ve = "";
          for (let a = 0; a < ms.length; a++) {
            const u = ms.charAt(a);
            ve = String.fromCharCode(55349, 56320 + a), g(x, S, ye, u, ve), g(ie, S, L, u, ve), ve = String.fromCharCode(55349, 56372 + a), g(x, S, ye, u, ve), g(ie, S, L, u, ve), ve = String.fromCharCode(55349, 56424 + a), g(x, S, ye, u, ve), g(ie, S, L, u, ve), ve = String.fromCharCode(55349, 56580 + a), g(x, S, ye, u, ve), g(ie, S, L, u, ve), ve = String.fromCharCode(55349, 56684 + a), g(x, S, ye, u, ve), g(ie, S, L, u, ve), ve = String.fromCharCode(55349, 56736 + a), g(x, S, ye, u, ve), g(ie, S, L, u, ve), ve = String.fromCharCode(55349, 56788 + a), g(x, S, ye, u, ve), g(ie, S, L, u, ve), ve = String.fromCharCode(55349, 56840 + a), g(x, S, ye, u, ve), g(ie, S, L, u, ve), ve = String.fromCharCode(55349, 56944 + a), g(x, S, ye, u, ve), g(ie, S, L, u, ve), a < 26 && (ve = String.fromCharCode(55349, 56632 + a), g(x, S, ye, u, ve), g(ie, S, L, u, ve), ve = String.fromCharCode(55349, 56476 + a), g(x, S, ye, u, ve), g(ie, S, L, u, ve));
          }
          ve = "ğ•œ", g(x, S, ye, "k", ve), g(ie, S, L, "k", ve);
          for (let a = 0; a < 10; a++) {
            const u = a.toString();
            ve = String.fromCharCode(55349, 57294 + a), g(x, S, ye, u, ve), g(ie, S, L, u, ve), ve = String.fromCharCode(55349, 57314 + a), g(x, S, ye, u, ve), g(ie, S, L, u, ve), ve = String.fromCharCode(55349, 57324 + a), g(x, S, ye, u, ve), g(ie, S, L, u, ve), ve = String.fromCharCode(55349, 57334 + a), g(x, S, ye, u, ve), g(ie, S, L, u, ve);
          }
          const fu = "ÃÃÃ¾";
          for (let a = 0; a < fu.length; a++) {
            const u = fu.charAt(a);
            g(x, S, ye, u, u), g(ie, S, L, u, u);
          }
          const gs = [
            ["mathbf", "textbf", "Main-Bold"],
            // A-Z bold upright
            ["mathbf", "textbf", "Main-Bold"],
            // a-z bold upright
            ["mathnormal", "textit", "Math-Italic"],
            // A-Z italic
            ["mathnormal", "textit", "Math-Italic"],
            // a-z italic
            ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
            // A-Z bold italic
            ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
            // a-z bold italic
            // Map fancy A-Z letters to script, not calligraphic.
            // This aligns with unicode-math and math fonts (except Cambria Math).
            ["mathscr", "textscr", "Script-Regular"],
            // A-Z script
            ["", "", ""],
            // a-z script.  No font
            ["", "", ""],
            // A-Z bold script. No font
            ["", "", ""],
            // a-z bold script. No font
            ["mathfrak", "textfrak", "Fraktur-Regular"],
            // A-Z Fraktur
            ["mathfrak", "textfrak", "Fraktur-Regular"],
            // a-z Fraktur
            ["mathbb", "textbb", "AMS-Regular"],
            // A-Z double-struck
            ["mathbb", "textbb", "AMS-Regular"],
            // k double-struck
            // Note that we are using a bold font, but font metrics for regular Fraktur.
            ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
            // A-Z bold Fraktur
            ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
            // a-z bold Fraktur
            ["mathsf", "textsf", "SansSerif-Regular"],
            // A-Z sans-serif
            ["mathsf", "textsf", "SansSerif-Regular"],
            // a-z sans-serif
            ["mathboldsf", "textboldsf", "SansSerif-Bold"],
            // A-Z bold sans-serif
            ["mathboldsf", "textboldsf", "SansSerif-Bold"],
            // a-z bold sans-serif
            ["mathitsf", "textitsf", "SansSerif-Italic"],
            // A-Z italic sans-serif
            ["mathitsf", "textitsf", "SansSerif-Italic"],
            // a-z italic sans-serif
            ["", "", ""],
            // A-Z bold italic sans. No font
            ["", "", ""],
            // a-z bold italic sans. No font
            ["mathtt", "texttt", "Typewriter-Regular"],
            // A-Z monospace
            ["mathtt", "texttt", "Typewriter-Regular"]
            // a-z monospace
          ], Ol = [
            ["mathbf", "textbf", "Main-Bold"],
            // 0-9 bold
            ["", "", ""],
            // 0-9 double-struck. No KaTeX font.
            ["mathsf", "textsf", "SansSerif-Regular"],
            // 0-9 sans-serif
            ["mathboldsf", "textboldsf", "SansSerif-Bold"],
            // 0-9 bold sans-serif
            ["mathtt", "texttt", "Typewriter-Regular"]
            // 0-9 monospace
          ], w2 = function(a, u) {
            const c = a.charCodeAt(0), d = a.charCodeAt(1), m = (c - 55296) * 1024 + (d - 56320) + 65536, y = u === "math" ? 0 : 1;
            if (119808 <= m && m < 120484) {
              const _ = Math.floor((m - 119808) / 26);
              return [gs[_][2], gs[_][y]];
            } else if (120782 <= m && m <= 120831) {
              const _ = Math.floor((m - 120782) / 10);
              return [Ol[_][2], Ol[_][y]];
            } else {
              if (m === 120485 || m === 120486)
                return [gs[0][2], gs[0][y]];
              if (120486 < m && m < 120782)
                return ["", ""];
              throw new s("Unsupported character: " + a);
            }
          }, bs = function(a, u, c) {
            return et[c][a] && et[c][a].replace && (a = et[c][a].replace), {
              value: a,
              metrics: uu(a, u, c)
            };
          }, Zt = function(a, u, c, d, m) {
            const y = bs(a, u, c), _ = y.metrics;
            a = y.value;
            let E;
            if (_) {
              let M = _.italic;
              (c === "text" || d && d.font === "mathit") && (M = 0), E = new Rt(a, _.height, _.depth, M, _.skew, _.width, m);
            } else
              typeof console < "u" && console.warn("No character metrics " + ("for '" + a + "' in style '" + u + "' and mode '" + c + "'")), E = new Rt(a, 0, 0, 0, 0, 0, m);
            if (d) {
              E.maxFontSize = d.sizeMultiplier, d.style.isTight() && E.classes.push("mtight");
              const M = d.getColor();
              M && (E.style.color = M);
            }
            return E;
          }, v2 = function(a, u, c, d) {
            return d === void 0 && (d = []), c.font === "boldsymbol" && bs(a, "Main-Bold", u).metrics ? Zt(a, "Main-Bold", u, c, d.concat(["mathbf"])) : a === "\\" || et[u][a].font === "main" ? Zt(a, "Main-Regular", u, c, d) : Zt(a, "AMS-Regular", u, c, d.concat(["amsrm"]));
          }, k2 = function(a, u, c, d, m) {
            return m !== "textord" && bs(a, "Math-BoldItalic", u).metrics ? {
              fontName: "Math-BoldItalic",
              fontClass: "boldsymbol"
            } : {
              fontName: "Main-Bold",
              fontClass: "mathbf"
            };
          }, _2 = function(a, u, c) {
            const d = a.mode, m = a.text, y = ["mord"], _ = d === "math" || d === "text" && u.font, E = _ ? u.font : u.fontFamily;
            let M = "", B = "";
            if (m.charCodeAt(0) === 55349 && ([M, B] = w2(m, d)), M.length > 0)
              return Zt(m, M, d, u, y.concat(B));
            if (E) {
              let H, U;
              if (E === "boldsymbol") {
                const W = k2(m, d, u, y, c);
                H = W.fontName, U = [W.fontClass];
              } else _ ? (H = Ll[E].fontName, U = [E]) : (H = ys(E, u.fontWeight, u.fontShape), U = [E, u.fontWeight, u.fontShape]);
              if (bs(m, H, d).metrics)
                return Zt(m, H, d, u, y.concat(U));
              if (Il.hasOwnProperty(m) && H.slice(0, 10) === "Typewriter") {
                const W = [];
                for (let re = 0; re < m.length; re++)
                  W.push(Zt(m[re], H, d, u, y.concat(U)));
                return $l(W);
              }
            }
            if (c === "mathord")
              return Zt(m, "Math-Italic", d, u, y.concat(["mathnormal"]));
            if (c === "textord") {
              const H = et[d][m] && et[d][m].font;
              if (H === "ams") {
                const U = ys("amsrm", u.fontWeight, u.fontShape);
                return Zt(m, U, d, u, y.concat("amsrm", u.fontWeight, u.fontShape));
              } else if (H === "main" || !H) {
                const U = ys("textrm", u.fontWeight, u.fontShape);
                return Zt(m, U, d, u, y.concat(u.fontWeight, u.fontShape));
              } else {
                const U = ys(H, u.fontWeight, u.fontShape);
                return Zt(m, U, d, u, y.concat(U, u.fontWeight, u.fontShape));
              }
            } else
              throw new Error("unexpected type: " + c + " in makeOrd");
          }, S2 = (a, u) => {
            if (Ln(a.classes) !== Ln(u.classes) || a.skew !== u.skew || a.maxFontSize !== u.maxFontSize)
              return false;
            if (a.classes.length === 1) {
              const c = a.classes[0];
              if (c === "mbin" || c === "mord")
                return false;
            }
            for (const c in a.style)
              if (a.style.hasOwnProperty(c) && a.style[c] !== u.style[c])
                return false;
            for (const c in u.style)
              if (u.style.hasOwnProperty(c) && a.style[c] !== u.style[c])
                return false;
            return true;
          }, A2 = (a) => {
            for (let u = 0; u < a.length - 1; u++) {
              const c = a[u], d = a[u + 1];
              c instanceof Rt && d instanceof Rt && S2(c, d) && (c.text += d.text, c.height = Math.max(c.height, d.height), c.depth = Math.max(c.depth, d.depth), c.italic = d.italic, a.splice(u + 1, 1), u--);
            }
            return a;
          }, hu = function(a) {
            let u = 0, c = 0, d = 0;
            for (let m = 0; m < a.children.length; m++) {
              const y = a.children[m];
              y.height > u && (u = y.height), y.depth > c && (c = y.depth), y.maxFontSize > d && (d = y.maxFontSize);
            }
            a.height = u, a.depth = c, a.maxFontSize = d;
          }, Et = function(a, u, c, d) {
            const m = new hi(a, u, c, d);
            return hu(m), m;
          }, zl = (a, u, c, d) => new hi(a, u, c, d), E2 = function(a, u, c) {
            const d = Et([a], [], u);
            return d.height = Math.max(c || u.fontMetrics().defaultRuleThickness, u.minRuleThickness), d.style.borderBottomWidth = ce(d.height), d.maxFontSize = 1, d;
          }, C2 = function(a, u, c, d) {
            const m = new lu(a, u, c, d);
            return hu(m), m;
          }, $l = function(a) {
            const u = new fi(a);
            return hu(u), u;
          }, T2 = function(a, u) {
            return a instanceof fi ? Et([], [a], u) : a;
          }, D2 = function(a) {
            if (a.positionType === "individualShift") {
              const c = a.children, d = [c[0]], m = -c[0].shift - c[0].elem.depth;
              let y = m;
              for (let _ = 1; _ < c.length; _++) {
                const E = -c[_].shift - y - c[_].elem.depth, M = E - (c[_ - 1].elem.height + c[_ - 1].elem.depth);
                y = y + E, d.push({
                  type: "kern",
                  size: M
                }), d.push(c[_]);
              }
              return {
                children: d,
                depth: m
              };
            }
            let u;
            if (a.positionType === "top") {
              let c = a.positionData;
              for (let d = 0; d < a.children.length; d++) {
                const m = a.children[d];
                c -= m.type === "kern" ? m.size : m.elem.height + m.elem.depth;
              }
              u = c;
            } else if (a.positionType === "bottom")
              u = -a.positionData;
            else {
              const c = a.children[0];
              if (c.type !== "elem")
                throw new Error('First child must have type "elem".');
              if (a.positionType === "shift")
                u = -c.elem.depth - a.positionData;
              else if (a.positionType === "firstBaseline")
                u = -c.elem.depth;
              else
                throw new Error("Invalid positionType " + a.positionType + ".");
            }
            return {
              children: a.children,
              depth: u
            };
          }, M2 = function(a, u) {
            const {
              children: c,
              depth: d
            } = D2(a);
            let m = 0;
            for (let re = 0; re < c.length; re++) {
              const me = c[re];
              if (me.type === "elem") {
                const be = me.elem;
                m = Math.max(m, be.maxFontSize, be.height);
              }
            }
            m += 2;
            const y = Et(["pstrut"], []);
            y.style.height = ce(m);
            const _ = [];
            let E = d, M = d, B = d;
            for (let re = 0; re < c.length; re++) {
              const me = c[re];
              if (me.type === "kern")
                B += me.size;
              else {
                const be = me.elem, Ne = me.wrapperClasses || [], Ee = me.wrapperStyle || {}, Ie = Et(Ne, [y, be], void 0, Ee);
                Ie.style.top = ce(-m - B - be.depth), me.marginLeft && (Ie.style.marginLeft = me.marginLeft), me.marginRight && (Ie.style.marginRight = me.marginRight), _.push(Ie), B += be.height + be.depth;
              }
              E = Math.min(E, B), M = Math.max(M, B);
            }
            const H = Et(["vlist"], _);
            H.style.height = ce(M);
            let U;
            if (E < 0) {
              const re = Et([], []), me = Et(["vlist"], [re]);
              me.style.height = ce(-E);
              const be = Et(["vlist-s"], [new Rt("â€‹")]);
              U = [Et(["vlist-r"], [H, be]), Et(["vlist-r"], [me])];
            } else
              U = [Et(["vlist-r"], [H])];
            const W = Et(["vlist-t"], U);
            return U.length === 2 && W.classes.push("vlist-t2"), W.height = M, W.depth = -E, W;
          }, N2 = (a, u) => {
            const c = Et(["mspace"], [], u), d = Qe(a, u);
            return c.style.marginRight = ce(d), c;
          }, ys = function(a, u, c) {
            let d = "";
            switch (a) {
              case "amsrm":
                d = "AMS";
                break;
              case "textrm":
                d = "Main";
                break;
              case "textsf":
                d = "SansSerif";
                break;
              case "texttt":
                d = "Typewriter";
                break;
              default:
                d = a;
            }
            let m;
            return u === "textbf" && c === "textit" ? m = "BoldItalic" : u === "textbf" ? m = "Bold" : u === "textit" ? m = "Italic" : m = "Regular", d + "-" + m;
          }, Ll = {
            // styles
            mathbf: {
              variant: "bold",
              fontName: "Main-Bold"
            },
            mathrm: {
              variant: "normal",
              fontName: "Main-Regular"
            },
            textit: {
              variant: "italic",
              fontName: "Main-Italic"
            },
            mathit: {
              variant: "italic",
              fontName: "Main-Italic"
            },
            mathnormal: {
              variant: "italic",
              fontName: "Math-Italic"
            },
            mathsfit: {
              variant: "sans-serif-italic",
              fontName: "SansSerif-Italic"
            },
            // "boldsymbol" is missing because they require the use of multiple fonts:
            // Math-BoldItalic and Main-Bold.  This is handled by a special case in
            // makeOrd which ends up calling boldsymbol.
            // families
            mathbb: {
              variant: "double-struck",
              fontName: "AMS-Regular"
            },
            mathcal: {
              variant: "script",
              fontName: "Caligraphic-Regular"
            },
            mathfrak: {
              variant: "fraktur",
              fontName: "Fraktur-Regular"
            },
            mathscr: {
              variant: "script",
              fontName: "Script-Regular"
            },
            mathsf: {
              variant: "sans-serif",
              fontName: "SansSerif-Regular"
            },
            mathtt: {
              variant: "monospace",
              fontName: "Typewriter-Regular"
            }
          }, ql = {
            //   path, width, height
            vec: ["vec", 0.471, 0.714],
            // values from the font glyph
            oiintSize1: ["oiintSize1", 0.957, 0.499],
            // oval to overlay the integrand
            oiintSize2: ["oiintSize2", 1.472, 0.659],
            oiiintSize1: ["oiiintSize1", 1.304, 0.499],
            oiiintSize2: ["oiiintSize2", 1.98, 0.659]
          };
          var G = {
            fontMap: Ll,
            makeSymbol: Zt,
            mathsym: v2,
            makeSpan: Et,
            makeSvgSpan: zl,
            makeLineSpan: E2,
            makeAnchor: C2,
            makeFragment: $l,
            wrapFragment: T2,
            makeVList: M2,
            makeOrd: _2,
            makeGlue: N2,
            staticSvg: function(a, u) {
              const [c, d, m] = ql[a], y = new qn(c), _ = new kn([y], {
                width: ce(d),
                height: ce(m),
                // Override CSS rule `.katex svg { width: 100% }`
                style: "width:" + ce(d),
                viewBox: "0 0 " + 1e3 * d + " " + 1e3 * m,
                preserveAspectRatio: "xMinYMin"
              }), E = zl(["overlay"], [_], u);
              return E.height = m, E.style.height = ce(m), E.style.width = ce(d), E;
            },
            svgData: ql,
            tryCombineChars: A2
          };
          const tt = {
            number: 3,
            unit: "mu"
          }, rr = {
            number: 4,
            unit: "mu"
          }, Sn = {
            number: 5,
            unit: "mu"
          }, I2 = {
            mord: {
              mop: tt,
              mbin: rr,
              mrel: Sn,
              minner: tt
            },
            mop: {
              mord: tt,
              mop: tt,
              mrel: Sn,
              minner: tt
            },
            mbin: {
              mord: rr,
              mop: rr,
              mopen: rr,
              minner: rr
            },
            mrel: {
              mord: Sn,
              mop: Sn,
              mopen: Sn,
              minner: Sn
            },
            mopen: {},
            mclose: {
              mop: tt,
              mbin: rr,
              mrel: Sn,
              minner: tt
            },
            mpunct: {
              mord: tt,
              mop: tt,
              mrel: Sn,
              mopen: tt,
              mclose: tt,
              mpunct: tt,
              minner: tt
            },
            minner: {
              mord: tt,
              mop: tt,
              mbin: rr,
              mrel: Sn,
              mopen: tt,
              mpunct: tt,
              minner: tt
            }
          }, F2 = {
            mord: {
              mop: tt
            },
            mop: {
              mord: tt,
              mop: tt
            },
            mbin: {},
            mrel: {},
            mopen: {},
            mclose: {
              mop: tt
            },
            mpunct: {},
            minner: {
              mop: tt
            }
          }, Rl = {}, xs = {}, ws = {};
          function de(a) {
            let {
              type: u,
              names: c,
              props: d,
              handler: m,
              htmlBuilder: y,
              mathmlBuilder: _
            } = a;
            const E = {
              type: u,
              numArgs: d.numArgs,
              argTypes: d.argTypes,
              allowedInArgument: !!d.allowedInArgument,
              allowedInText: !!d.allowedInText,
              allowedInMath: d.allowedInMath === void 0 ? true : d.allowedInMath,
              numOptionalArgs: d.numOptionalArgs || 0,
              infix: !!d.infix,
              primitive: !!d.primitive,
              handler: m
            };
            for (let M = 0; M < c.length; ++M)
              Rl[c[M]] = E;
            u && (y && (xs[u] = y), _ && (ws[u] = _));
          }
          function ir(a) {
            let {
              type: u,
              htmlBuilder: c,
              mathmlBuilder: d
            } = a;
            de({
              type: u,
              names: [],
              props: {
                numArgs: 0
              },
              handler() {
                throw new Error("Should never be called.");
              },
              htmlBuilder: c,
              mathmlBuilder: d
            });
          }
          const vs = function(a) {
            return a.type === "ordgroup" && a.body.length === 1 ? a.body[0] : a;
          }, st = function(a) {
            return a.type === "ordgroup" ? a.body : [a];
          }, An = G.makeSpan, B2 = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"], O2 = ["rightmost", "mrel", "mclose", "mpunct"], z2 = {
            display: ne.DISPLAY,
            text: ne.TEXT,
            script: ne.SCRIPT,
            scriptscript: ne.SCRIPTSCRIPT
          }, $2 = {
            mord: "mord",
            mop: "mop",
            mbin: "mbin",
            mrel: "mrel",
            mopen: "mopen",
            mclose: "mclose",
            mpunct: "mpunct",
            minner: "minner"
          }, ct = function(a, u, c, d) {
            d === void 0 && (d = [null, null]);
            const m = [];
            for (let B = 0; B < a.length; B++) {
              const H = Fe(a[B], u);
              if (H instanceof fi) {
                const U = H.children;
                m.push(...U);
              } else
                m.push(H);
            }
            if (G.tryCombineChars(m), !c)
              return m;
            let y = u;
            if (a.length === 1) {
              const B = a[0];
              B.type === "sizing" ? y = u.havingSize(B.size) : B.type === "styling" && (y = u.havingStyle(z2[B.style]));
            }
            const _ = An([d[0] || "leftmost"], [], u), E = An([d[1] || "rightmost"], [], u), M = c === "root";
            return du(m, (B, H) => {
              const U = H.classes[0], W = B.classes[0];
              U === "mbin" && D.contains(O2, W) ? H.classes[0] = "mord" : W === "mbin" && D.contains(B2, U) && (B.classes[0] = "mord");
            }, {
              node: _
            }, E, M), du(m, (B, H) => {
              const U = mu(H), W = mu(B), re = U && W ? B.hasClass("mtight") ? F2[U][W] : I2[U][W] : null;
              if (re)
                return G.makeGlue(re, y);
            }, {
              node: _
            }, E, M), m;
          }, du = function(a, u, c, d, m) {
            d && a.push(d);
            let y = 0;
            for (; y < a.length; y++) {
              const _ = a[y], E = Pl(_);
              if (E) {
                du(E.children, u, c, null, m);
                continue;
              }
              const M = !_.hasClass("mspace");
              if (M) {
                const B = u(_, c.node);
                B && (c.insertAfter ? c.insertAfter(B) : (a.unshift(B), y++));
              }
              M ? c.node = _ : m && _.hasClass("newline") && (c.node = An(["leftmost"])), c.insertAfter = /* @__PURE__ */ ((B) => (H) => {
                a.splice(B + 1, 0, H), y++;
              })(y);
            }
            d && a.pop();
          }, Pl = function(a) {
            return a instanceof fi || a instanceof lu || a instanceof hi && a.hasClass("enclosing") ? a : null;
          }, pu = function(a, u) {
            const c = Pl(a);
            if (c) {
              const d = c.children;
              if (d.length) {
                if (u === "right")
                  return pu(d[d.length - 1], "right");
                if (u === "left")
                  return pu(d[0], "left");
              }
            }
            return a;
          }, mu = function(a, u) {
            return a ? (u && (a = pu(a, u)), $2[a.classes[0]] || null) : null;
          }, di = function(a, u) {
            const c = ["nulldelimiter"].concat(a.baseSizingClasses());
            return An(u.concat(c));
          }, Fe = function(a, u, c) {
            if (!a)
              return An();
            if (xs[a.type]) {
              let d = xs[a.type](a, u);
              if (c && u.size !== c.size) {
                d = An(u.sizingClasses(c), [d], u);
                const m = u.sizeMultiplier / c.sizeMultiplier;
                d.height *= m, d.depth *= m;
              }
              return d;
            } else
              throw new s("Got group of unknown type: '" + a.type + "'");
          };
          function ks(a, u) {
            const c = An(["base"], a, u), d = An(["strut"]);
            return d.style.height = ce(c.height + c.depth), c.depth && (d.style.verticalAlign = ce(-c.depth)), c.children.unshift(d), c;
          }
          function gu(a, u) {
            let c = null;
            a.length === 1 && a[0].type === "tag" && (c = a[0].tag, a = a[0].body);
            const d = ct(a, u, "root");
            let m;
            d.length === 2 && d[1].hasClass("tag") && (m = d.pop());
            const y = [];
            let _ = [];
            for (let B = 0; B < d.length; B++)
              if (_.push(d[B]), d[B].hasClass("mbin") || d[B].hasClass("mrel") || d[B].hasClass("allowbreak")) {
                let H = false;
                for (; B < d.length - 1 && d[B + 1].hasClass("mspace") && !d[B + 1].hasClass("newline"); )
                  B++, _.push(d[B]), d[B].hasClass("nobreak") && (H = true);
                H || (y.push(ks(_, u)), _ = []);
              } else d[B].hasClass("newline") && (_.pop(), _.length > 0 && (y.push(ks(_, u)), _ = []), y.push(d[B]));
            _.length > 0 && y.push(ks(_, u));
            let E;
            c ? (E = ks(ct(c, u, true)), E.classes = ["tag"], y.push(E)) : m && y.push(m);
            const M = An(["katex-html"], y);
            if (M.setAttribute("aria-hidden", "true"), E) {
              const B = E.children[0];
              B.style.height = ce(M.height + M.depth), M.depth && (B.style.verticalAlign = ce(-M.depth));
            }
            return M;
          }
          function Hl(a) {
            return new fi(a);
          }
          class Bt {
            constructor(u, c, d) {
              this.type = void 0, this.attributes = void 0, this.children = void 0, this.classes = void 0, this.type = u, this.attributes = {}, this.children = c || [], this.classes = d || [];
            }
            /**
             * Sets an attribute on a MathML node. MathML depends on attributes to convey a
             * semantic content, so this is used heavily.
             */
            setAttribute(u, c) {
              this.attributes[u] = c;
            }
            /**
             * Gets an attribute on a MathML node.
             */
            getAttribute(u) {
              return this.attributes[u];
            }
            /**
             * Converts the math node into a MathML-namespaced DOM element.
             */
            toNode() {
              const u = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
              for (const c in this.attributes)
                Object.prototype.hasOwnProperty.call(this.attributes, c) && u.setAttribute(c, this.attributes[c]);
              this.classes.length > 0 && (u.className = Ln(this.classes));
              for (let c = 0; c < this.children.length; c++)
                if (this.children[c] instanceof un && this.children[c + 1] instanceof un) {
                  let d = this.children[c].toText() + this.children[++c].toText();
                  for (; this.children[c + 1] instanceof un; )
                    d += this.children[++c].toText();
                  u.appendChild(new un(d).toNode());
                } else
                  u.appendChild(this.children[c].toNode());
              return u;
            }
            /**
             * Converts the math node into an HTML markup string.
             */
            toMarkup() {
              let u = "<" + this.type;
              for (const c in this.attributes)
                Object.prototype.hasOwnProperty.call(this.attributes, c) && (u += " " + c + '="', u += D.escape(this.attributes[c]), u += '"');
              this.classes.length > 0 && (u += ' class ="' + D.escape(Ln(this.classes)) + '"'), u += ">";
              for (let c = 0; c < this.children.length; c++)
                u += this.children[c].toMarkup();
              return u += "</" + this.type + ">", u;
            }
            /**
             * Converts the math node into a string, similar to innerText, but escaped.
             */
            toText() {
              return this.children.map((u) => u.toText()).join("");
            }
          }
          class un {
            constructor(u) {
              this.text = void 0, this.text = u;
            }
            /**
             * Converts the text node into a DOM text node.
             */
            toNode() {
              return document.createTextNode(this.text);
            }
            /**
             * Converts the text node into escaped HTML markup
             * (representing the text itself).
             */
            toMarkup() {
              return D.escape(this.toText());
            }
            /**
             * Converts the text node into a string
             * (representing the text itself).
             */
            toText() {
              return this.text;
            }
          }
          class L2 {
            /**
             * Create a Space node with width given in CSS ems.
             */
            constructor(u) {
              this.width = void 0, this.character = void 0, this.width = u, u >= 0.05555 && u <= 0.05556 ? this.character = "â€Š" : u >= 0.1666 && u <= 0.1667 ? this.character = "â€‰" : u >= 0.2222 && u <= 0.2223 ? this.character = "â€…" : u >= 0.2777 && u <= 0.2778 ? this.character = "â€…â€Š" : u >= -0.05556 && u <= -0.05555 ? this.character = "â€Šâ£" : u >= -0.1667 && u <= -0.1666 ? this.character = "â€‰â£" : u >= -0.2223 && u <= -0.2222 ? this.character = "âŸâ£" : u >= -0.2778 && u <= -0.2777 ? this.character = "â€…â£" : this.character = null;
            }
            /**
             * Converts the math node into a MathML-namespaced DOM element.
             */
            toNode() {
              if (this.character)
                return document.createTextNode(this.character);
              {
                const u = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
                return u.setAttribute("width", ce(this.width)), u;
              }
            }
            /**
             * Converts the math node into an HTML markup string.
             */
            toMarkup() {
              return this.character ? "<mtext>" + this.character + "</mtext>" : '<mspace width="' + ce(this.width) + '"/>';
            }
            /**
             * Converts the math node into a string, similar to innerText.
             */
            toText() {
              return this.character ? this.character : " ";
            }
          }
          var oe = {
            MathNode: Bt,
            TextNode: un,
            SpaceNode: L2,
            newDocumentFragment: Hl
          };
          const Pt = function(a, u, c) {
            return et[u][a] && et[u][a].replace && a.charCodeAt(0) !== 55349 && !(Il.hasOwnProperty(a) && c && (c.fontFamily && c.fontFamily.slice(4, 6) === "tt" || c.font && c.font.slice(4, 6) === "tt")) && (a = et[u][a].replace), new oe.TextNode(a);
          }, bu = function(a) {
            return a.length === 1 ? a[0] : new oe.MathNode("mrow", a);
          }, yu = function(a, u) {
            if (u.fontFamily === "texttt")
              return "monospace";
            if (u.fontFamily === "textsf")
              return u.fontShape === "textit" && u.fontWeight === "textbf" ? "sans-serif-bold-italic" : u.fontShape === "textit" ? "sans-serif-italic" : u.fontWeight === "textbf" ? "bold-sans-serif" : "sans-serif";
            if (u.fontShape === "textit" && u.fontWeight === "textbf")
              return "bold-italic";
            if (u.fontShape === "textit")
              return "italic";
            if (u.fontWeight === "textbf")
              return "bold";
            const c = u.font;
            if (!c || c === "mathnormal")
              return null;
            const d = a.mode;
            if (c === "mathit")
              return "italic";
            if (c === "boldsymbol")
              return a.type === "textord" ? "bold" : "bold-italic";
            if (c === "mathbf")
              return "bold";
            if (c === "mathbb")
              return "double-struck";
            if (c === "mathsfit")
              return "sans-serif-italic";
            if (c === "mathfrak")
              return "fraktur";
            if (c === "mathscr" || c === "mathcal")
              return "script";
            if (c === "mathsf")
              return "sans-serif";
            if (c === "mathtt")
              return "monospace";
            let m = a.text;
            if (D.contains(["\\imath", "\\jmath"], m))
              return null;
            et[d][m] && et[d][m].replace && (m = et[d][m].replace);
            const y = G.fontMap[c].fontName;
            return uu(m, y, d) ? G.fontMap[c].variant : null;
          };
          function xu(a) {
            if (!a)
              return false;
            if (a.type === "mi" && a.children.length === 1) {
              const u = a.children[0];
              return u instanceof un && u.text === ".";
            } else if (a.type === "mo" && a.children.length === 1 && a.getAttribute("separator") === "true" && a.getAttribute("lspace") === "0em" && a.getAttribute("rspace") === "0em") {
              const u = a.children[0];
              return u instanceof un && u.text === ",";
            } else
              return false;
          }
          const Ct = function(a, u, c) {
            if (a.length === 1) {
              const y = je(a[0], u);
              return c && y instanceof Bt && y.type === "mo" && (y.setAttribute("lspace", "0em"), y.setAttribute("rspace", "0em")), [y];
            }
            const d = [];
            let m;
            for (let y = 0; y < a.length; y++) {
              const _ = je(a[y], u);
              if (_ instanceof Bt && m instanceof Bt) {
                if (_.type === "mtext" && m.type === "mtext" && _.getAttribute("mathvariant") === m.getAttribute("mathvariant")) {
                  m.children.push(..._.children);
                  continue;
                } else if (_.type === "mn" && m.type === "mn") {
                  m.children.push(..._.children);
                  continue;
                } else if (xu(_) && m.type === "mn") {
                  m.children.push(..._.children);
                  continue;
                } else if (_.type === "mn" && xu(m))
                  _.children = [...m.children, ..._.children], d.pop();
                else if ((_.type === "msup" || _.type === "msub") && _.children.length >= 1 && (m.type === "mn" || xu(m))) {
                  const E = _.children[0];
                  E instanceof Bt && E.type === "mn" && (E.children = [...m.children, ...E.children], d.pop());
                } else if (m.type === "mi" && m.children.length === 1) {
                  const E = m.children[0];
                  if (E instanceof un && E.text === "Ì¸" && (_.type === "mo" || _.type === "mi" || _.type === "mn")) {
                    const M = _.children[0];
                    M instanceof un && M.text.length > 0 && (M.text = M.text.slice(0, 1) + "Ì¸" + M.text.slice(1), d.pop());
                  }
                }
              }
              d.push(_), m = _;
            }
            return d;
          }, Rn = function(a, u, c) {
            return bu(Ct(a, u, c));
          }, je = function(a, u) {
            if (!a)
              return new oe.MathNode("mrow");
            if (ws[a.type])
              return ws[a.type](a, u);
            throw new s("Got group of unknown type: '" + a.type + "'");
          };
          function jl(a, u, c, d, m) {
            const y = Ct(a, c);
            let _;
            y.length === 1 && y[0] instanceof Bt && D.contains(["mrow", "mtable"], y[0].type) ? _ = y[0] : _ = new oe.MathNode("mrow", y);
            const E = new oe.MathNode("annotation", [new oe.TextNode(u)]);
            E.setAttribute("encoding", "application/x-tex");
            const M = new oe.MathNode("semantics", [_, E]), B = new oe.MathNode("math", [M]);
            B.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"), d && B.setAttribute("display", "block");
            const H = m ? "katex" : "katex-mathml";
            return G.makeSpan([H], [B]);
          }
          const Ul = function(a) {
            return new h22({
              style: a.displayMode ? ne.DISPLAY : ne.TEXT,
              maxSize: a.maxSize,
              minRuleThickness: a.minRuleThickness
            });
          }, Vl = function(a, u) {
            if (u.displayMode) {
              const c = ["katex-display"];
              u.leqno && c.push("leqno"), u.fleqn && c.push("fleqn"), a = G.makeSpan(c, [a]);
            }
            return a;
          }, q2 = function(a, u, c) {
            const d = Ul(c);
            let m;
            if (c.output === "mathml")
              return jl(a, u, d, c.displayMode, true);
            if (c.output === "html") {
              const y = gu(a, d);
              m = G.makeSpan(["katex"], [y]);
            } else {
              const y = jl(a, u, d, c.displayMode, false), _ = gu(a, d);
              m = G.makeSpan(["katex"], [y, _]);
            }
            return Vl(m, c);
          }, R2 = function(a, u, c) {
            const d = Ul(c), m = gu(a, d), y = G.makeSpan(["katex"], [m]);
            return Vl(y, c);
          }, P2 = {
            widehat: "^",
            widecheck: "Ë‡",
            widetilde: "~",
            utilde: "~",
            overleftarrow: "â†",
            underleftarrow: "â†",
            xleftarrow: "â†",
            overrightarrow: "â†’",
            underrightarrow: "â†’",
            xrightarrow: "â†’",
            underbrace: "âŸ",
            overbrace: "â",
            overgroup: "â ",
            undergroup: "â¡",
            overleftrightarrow: "â†”",
            underleftrightarrow: "â†”",
            xleftrightarrow: "â†”",
            Overrightarrow: "â‡’",
            xRightarrow: "â‡’",
            overleftharpoon: "â†¼",
            xleftharpoonup: "â†¼",
            overrightharpoon: "â‡€",
            xrightharpoonup: "â‡€",
            xLeftarrow: "â‡",
            xLeftrightarrow: "â‡”",
            xhookleftarrow: "â†©",
            xhookrightarrow: "â†ª",
            xmapsto: "â†¦",
            xrightharpoondown: "â‡",
            xleftharpoondown: "â†½",
            xrightleftharpoons: "â‡Œ",
            xleftrightharpoons: "â‡‹",
            xtwoheadleftarrow: "â†",
            xtwoheadrightarrow: "â† ",
            xlongequal: "=",
            xtofrom: "â‡„",
            xrightleftarrows: "â‡„",
            xrightequilibrium: "â‡Œ",
            // Not a perfect match.
            xleftequilibrium: "â‡‹",
            // None better available.
            "\\cdrightarrow": "â†’",
            "\\cdleftarrow": "â†",
            "\\cdlongequal": "="
          }, H2 = function(a) {
            const u = new oe.MathNode("mo", [new oe.TextNode(P2[a.replace(/^\\/, "")])]);
            return u.setAttribute("stretchy", "true"), u;
          }, j2 = {
            //   path(s), minWidth, height, align
            overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
            overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
            underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
            underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
            xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
            "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
            // CD minwwidth2.5pc
            xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
            "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
            Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
            xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
            xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
            overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
            xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
            xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
            overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
            xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
            xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
            xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
            "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
            xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
            xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
            overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
            overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
            underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
            underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
            xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
            xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
            xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
            xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
            xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
            xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
            overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
            underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
            overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
            undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
            xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
            xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
            // The next three arrows are from the mhchem package.
            // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
            // document as \xrightarrow or \xrightleftharpoons. Those have
            // min-length = 1.75em, so we set min-length on these next three to match.
            xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
            xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
            xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
          }, U2 = function(a) {
            return a.type === "ordgroup" ? a.body.length : 1;
          };
          var En = {
            encloseSpan: function(a, u, c, d, m) {
              let y;
              const _ = a.height + a.depth + c + d;
              if (/fbox|color|angl/.test(u)) {
                if (y = G.makeSpan(["stretchy", u], [], m), u === "fbox") {
                  const E = m.color && m.getColor();
                  E && (y.style.borderColor = E);
                }
              } else {
                const E = [];
                /^[bx]cancel$/.test(u) && E.push(new cu({
                  x1: "0",
                  y1: "0",
                  x2: "100%",
                  y2: "100%",
                  "stroke-width": "0.046em"
                })), /^x?cancel$/.test(u) && E.push(new cu({
                  x1: "0",
                  y1: "100%",
                  x2: "100%",
                  y2: "0",
                  "stroke-width": "0.046em"
                }));
                const M = new kn(E, {
                  width: "100%",
                  height: ce(_)
                });
                y = G.makeSvgSpan([], [M], m);
              }
              return y.height = _, y.style.height = ce(_), y;
            },
            mathMLnode: H2,
            svgSpan: function(a, u) {
              function c() {
                let _ = 4e5;
                const E = a.label.slice(1);
                if (D.contains(["widehat", "widecheck", "widetilde", "utilde"], E)) {
                  const B = U2(a.base);
                  let H, U, W;
                  if (B > 5)
                    E === "widehat" || E === "widecheck" ? (H = 420, _ = 2364, W = 0.42, U = E + "4") : (H = 312, _ = 2340, W = 0.34, U = "tilde4");
                  else {
                    const be = [1, 1, 2, 2, 3, 3][B];
                    E === "widehat" || E === "widecheck" ? (_ = [0, 1062, 2364, 2364, 2364][be], H = [0, 239, 300, 360, 420][be], W = [0, 0.24, 0.3, 0.3, 0.36, 0.42][be], U = E + be) : (_ = [0, 600, 1033, 2339, 2340][be], H = [0, 260, 286, 306, 312][be], W = [0, 0.26, 0.286, 0.3, 0.306, 0.34][be], U = "tilde" + be);
                  }
                  const re = new qn(U), me = new kn([re], {
                    width: "100%",
                    height: ce(W),
                    viewBox: "0 0 " + _ + " " + H,
                    preserveAspectRatio: "none"
                  });
                  return {
                    span: G.makeSvgSpan([], [me], u),
                    minWidth: 0,
                    height: W
                  };
                } else {
                  const M = [], B = j2[E], [H, U, W] = B, re = W / 1e3, me = H.length;
                  let be, Ne;
                  if (me === 1) {
                    const Ee = B[3];
                    be = ["hide-tail"], Ne = [Ee];
                  } else if (me === 2)
                    be = ["halfarrow-left", "halfarrow-right"], Ne = ["xMinYMin", "xMaxYMin"];
                  else if (me === 3)
                    be = ["brace-left", "brace-center", "brace-right"], Ne = ["xMinYMin", "xMidYMin", "xMaxYMin"];
                  else
                    throw new Error(`Correct katexImagesData or update code here to support
                    ` + me + " children.");
                  for (let Ee = 0; Ee < me; Ee++) {
                    const Ie = new qn(H[Ee]), ze = new kn([Ie], {
                      width: "400em",
                      height: ce(re),
                      viewBox: "0 0 " + _ + " " + W,
                      preserveAspectRatio: Ne[Ee] + " slice"
                    }), Ve = G.makeSvgSpan([be[Ee]], [ze], u);
                    if (me === 1)
                      return {
                        span: Ve,
                        minWidth: U,
                        height: re
                      };
                    Ve.style.height = ce(re), M.push(Ve);
                  }
                  return {
                    span: G.makeSpan(["stretchy"], M, u),
                    minWidth: U,
                    height: re
                  };
                }
              }
              const {
                span: d,
                minWidth: m,
                height: y
              } = c();
              return d.height = y, d.style.height = ce(y), m > 0 && (d.style.minWidth = ce(m)), d;
            }
          };
          function Ae(a, u) {
            if (!a || a.type !== u)
              throw new Error("Expected node of type " + u + ", but got " + (a ? "node of type " + a.type : String(a)));
            return a;
          }
          function wu(a) {
            const u = _s(a);
            if (!u)
              throw new Error("Expected node of symbol group type, but got " + (a ? "node of type " + a.type : String(a)));
            return u;
          }
          function _s(a) {
            return a && (a.type === "atom" || x2.hasOwnProperty(a.type)) ? a : null;
          }
          const vu = (a, u) => {
            let c, d, m;
            a && a.type === "supsub" ? (d = Ae(a.base, "accent"), c = d.base, a.base = c, m = b2(Fe(a, u)), a.base = d) : (d = Ae(a, "accent"), c = d.base);
            const y = Fe(c, u.havingCrampedStyle()), _ = d.isShifty && D.isCharacterBox(c);
            let E = 0;
            if (_) {
              const W = D.getBaseElem(c), re = Fe(W, u.havingCrampedStyle());
              E = Nl(re).skew;
            }
            const M = d.label === "\\c";
            let B = M ? y.height + y.depth : Math.min(y.height, u.fontMetrics().xHeight), H;
            if (d.isStretchy)
              H = En.svgSpan(d, u), H = G.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: y
                }, {
                  type: "elem",
                  elem: H,
                  wrapperClasses: ["svg-align"],
                  wrapperStyle: E > 0 ? {
                    width: "calc(100% - " + ce(2 * E) + ")",
                    marginLeft: ce(2 * E)
                  } : void 0
                }]
              }, u);
            else {
              let W, re;
              d.label === "\\vec" ? (W = G.staticSvg("vec", u), re = G.svgData.vec[1]) : (W = G.makeOrd({
                mode: d.mode,
                text: d.label
              }, u, "textord"), W = Nl(W), W.italic = 0, re = W.width, M && (B += W.depth)), H = G.makeSpan(["accent-body"], [W]);
              const me = d.label === "\\textcircled";
              me && (H.classes.push("accent-full"), B = y.height);
              let be = E;
              me || (be -= re / 2), H.style.left = ce(be), d.label === "\\textcircled" && (H.style.top = ".2em"), H = G.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: y
                }, {
                  type: "kern",
                  size: -B
                }, {
                  type: "elem",
                  elem: H
                }]
              }, u);
            }
            const U = G.makeSpan(["mord", "accent"], [H], u);
            return m ? (m.children[0] = U, m.height = Math.max(U.height, m.height), m.classes[0] = "mord", m) : U;
          }, Gl = (a, u) => {
            const c = a.isStretchy ? En.mathMLnode(a.label) : new oe.MathNode("mo", [Pt(a.label, a.mode)]), d = new oe.MathNode("mover", [je(a.base, u), c]);
            return d.setAttribute("accent", "true"), d;
          }, V2 = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((a) => "\\" + a).join("|"));
          de({
            type: "accent",
            names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
            props: {
              numArgs: 1
            },
            handler: (a, u) => {
              const c = vs(u[0]), d = !V2.test(a.funcName), m = !d || a.funcName === "\\widehat" || a.funcName === "\\widetilde" || a.funcName === "\\widecheck";
              return {
                type: "accent",
                mode: a.parser.mode,
                label: a.funcName,
                isStretchy: d,
                isShifty: m,
                base: c
              };
            },
            htmlBuilder: vu,
            mathmlBuilder: Gl
          }), de({
            type: "accent",
            names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
            props: {
              numArgs: 1,
              allowedInText: true,
              allowedInMath: true,
              // unless in strict mode
              argTypes: ["primitive"]
            },
            handler: (a, u) => {
              const c = u[0];
              let d = a.parser.mode;
              return d === "math" && (a.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + a.funcName + " works only in text mode"), d = "text"), {
                type: "accent",
                mode: d,
                label: a.funcName,
                isStretchy: false,
                isShifty: true,
                base: c
              };
            },
            htmlBuilder: vu,
            mathmlBuilder: Gl
          }), de({
            type: "accentUnder",
            names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
            props: {
              numArgs: 1
            },
            handler: (a, u) => {
              let {
                parser: c,
                funcName: d
              } = a;
              const m = u[0];
              return {
                type: "accentUnder",
                mode: c.mode,
                label: d,
                base: m
              };
            },
            htmlBuilder: (a, u) => {
              const c = Fe(a.base, u), d = En.svgSpan(a, u), m = a.label === "\\utilde" ? 0.12 : 0, y = G.makeVList({
                positionType: "top",
                positionData: c.height,
                children: [{
                  type: "elem",
                  elem: d,
                  wrapperClasses: ["svg-align"]
                }, {
                  type: "kern",
                  size: m
                }, {
                  type: "elem",
                  elem: c
                }]
              }, u);
              return G.makeSpan(["mord", "accentunder"], [y], u);
            },
            mathmlBuilder: (a, u) => {
              const c = En.mathMLnode(a.label), d = new oe.MathNode("munder", [je(a.base, u), c]);
              return d.setAttribute("accentunder", "true"), d;
            }
          });
          const Ss = (a) => {
            const u = new oe.MathNode("mpadded", a ? [a] : []);
            return u.setAttribute("width", "+0.6em"), u.setAttribute("lspace", "0.3em"), u;
          };
          de({
            type: "xArrow",
            names: [
              "\\xleftarrow",
              "\\xrightarrow",
              "\\xLeftarrow",
              "\\xRightarrow",
              "\\xleftrightarrow",
              "\\xLeftrightarrow",
              "\\xhookleftarrow",
              "\\xhookrightarrow",
              "\\xmapsto",
              "\\xrightharpoondown",
              "\\xrightharpoonup",
              "\\xleftharpoondown",
              "\\xleftharpoonup",
              "\\xrightleftharpoons",
              "\\xleftrightharpoons",
              "\\xlongequal",
              "\\xtwoheadrightarrow",
              "\\xtwoheadleftarrow",
              "\\xtofrom",
              // The next 3 functions are here to support the mhchem extension.
              // Direct use of these functions is discouraged and may break someday.
              "\\xrightleftarrows",
              "\\xrightequilibrium",
              "\\xleftequilibrium",
              // The next 3 functions are here only to support the {CD} environment.
              "\\\\cdrightarrow",
              "\\\\cdleftarrow",
              "\\\\cdlongequal"
            ],
            props: {
              numArgs: 1,
              numOptionalArgs: 1
            },
            handler(a, u, c) {
              let {
                parser: d,
                funcName: m
              } = a;
              return {
                type: "xArrow",
                mode: d.mode,
                label: m,
                body: u[0],
                below: c[0]
              };
            },
            // Flow is unable to correctly infer the type of `group`, even though it's
            // unambiguously determined from the passed-in `type` above.
            htmlBuilder(a, u) {
              const c = u.style;
              let d = u.havingStyle(c.sup());
              const m = G.wrapFragment(Fe(a.body, d, u), u), y = a.label.slice(0, 2) === "\\x" ? "x" : "cd";
              m.classes.push(y + "-arrow-pad");
              let _;
              a.below && (d = u.havingStyle(c.sub()), _ = G.wrapFragment(Fe(a.below, d, u), u), _.classes.push(y + "-arrow-pad"));
              const E = En.svgSpan(a, u), M = -u.fontMetrics().axisHeight + 0.5 * E.height;
              let B = -u.fontMetrics().axisHeight - 0.5 * E.height - 0.111;
              (m.depth > 0.25 || a.label === "\\xleftequilibrium") && (B -= m.depth);
              let H;
              if (_) {
                const U = -u.fontMetrics().axisHeight + _.height + 0.5 * E.height + 0.111;
                H = G.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: m,
                    shift: B
                  }, {
                    type: "elem",
                    elem: E,
                    shift: M
                  }, {
                    type: "elem",
                    elem: _,
                    shift: U
                  }]
                }, u);
              } else
                H = G.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: m,
                    shift: B
                  }, {
                    type: "elem",
                    elem: E,
                    shift: M
                  }]
                }, u);
              return H.children[0].children[0].children[1].classes.push("svg-align"), G.makeSpan(["mrel", "x-arrow"], [H], u);
            },
            mathmlBuilder(a, u) {
              const c = En.mathMLnode(a.label);
              c.setAttribute("minsize", a.label.charAt(0) === "x" ? "1.75em" : "3.0em");
              let d;
              if (a.body) {
                const m = Ss(je(a.body, u));
                if (a.below) {
                  const y = Ss(je(a.below, u));
                  d = new oe.MathNode("munderover", [c, y, m]);
                } else
                  d = new oe.MathNode("mover", [c, m]);
              } else if (a.below) {
                const m = Ss(je(a.below, u));
                d = new oe.MathNode("munder", [c, m]);
              } else
                d = Ss(), d = new oe.MathNode("mover", [c, d]);
              return d;
            }
          });
          const G2 = G.makeSpan;
          function Wl(a, u) {
            const c = ct(a.body, u, true);
            return G2([a.mclass], c, u);
          }
          function Kl(a, u) {
            let c;
            const d = Ct(a.body, u);
            return a.mclass === "minner" ? c = new oe.MathNode("mpadded", d) : a.mclass === "mord" ? a.isCharacterBox ? (c = d[0], c.type = "mi") : c = new oe.MathNode("mi", d) : (a.isCharacterBox ? (c = d[0], c.type = "mo") : c = new oe.MathNode("mo", d), a.mclass === "mbin" ? (c.attributes.lspace = "0.22em", c.attributes.rspace = "0.22em") : a.mclass === "mpunct" ? (c.attributes.lspace = "0em", c.attributes.rspace = "0.17em") : a.mclass === "mopen" || a.mclass === "mclose" ? (c.attributes.lspace = "0em", c.attributes.rspace = "0em") : a.mclass === "minner" && (c.attributes.lspace = "0.0556em", c.attributes.width = "+0.1111em")), c;
          }
          de({
            type: "mclass",
            names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler(a, u) {
              let {
                parser: c,
                funcName: d
              } = a;
              const m = u[0];
              return {
                type: "mclass",
                mode: c.mode,
                mclass: "m" + d.slice(5),
                // TODO(kevinb): don't prefix with 'm'
                body: st(m),
                isCharacterBox: D.isCharacterBox(m)
              };
            },
            htmlBuilder: Wl,
            mathmlBuilder: Kl
          });
          const As = (a) => {
            const u = a.type === "ordgroup" && a.body.length ? a.body[0] : a;
            return u.type === "atom" && (u.family === "bin" || u.family === "rel") ? "m" + u.family : "mord";
          };
          de({
            type: "mclass",
            names: ["\\@binrel"],
            props: {
              numArgs: 2
            },
            handler(a, u) {
              let {
                parser: c
              } = a;
              return {
                type: "mclass",
                mode: c.mode,
                mclass: As(u[0]),
                body: st(u[1]),
                isCharacterBox: D.isCharacterBox(u[1])
              };
            }
          }), de({
            type: "mclass",
            names: ["\\stackrel", "\\overset", "\\underset"],
            props: {
              numArgs: 2
            },
            handler(a, u) {
              let {
                parser: c,
                funcName: d
              } = a;
              const m = u[1], y = u[0];
              let _;
              d !== "\\stackrel" ? _ = As(m) : _ = "mrel";
              const E = {
                type: "op",
                mode: m.mode,
                limits: true,
                alwaysHandleSupSub: true,
                parentIsSupSub: false,
                symbol: false,
                suppressBaseShift: d !== "\\stackrel",
                body: st(m)
              }, M = {
                type: "supsub",
                mode: y.mode,
                base: E,
                sup: d === "\\underset" ? null : y,
                sub: d === "\\underset" ? y : null
              };
              return {
                type: "mclass",
                mode: c.mode,
                mclass: _,
                body: [M],
                isCharacterBox: D.isCharacterBox(M)
              };
            },
            htmlBuilder: Wl,
            mathmlBuilder: Kl
          }), de({
            type: "pmb",
            names: ["\\pmb"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler(a, u) {
              let {
                parser: c
              } = a;
              return {
                type: "pmb",
                mode: c.mode,
                mclass: As(u[0]),
                body: st(u[0])
              };
            },
            htmlBuilder(a, u) {
              const c = ct(a.body, u, true), d = G.makeSpan([a.mclass], c, u);
              return d.style.textShadow = "0.02em 0.01em 0.04px", d;
            },
            mathmlBuilder(a, u) {
              const c = Ct(a.body, u), d = new oe.MathNode("mstyle", c);
              return d.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px"), d;
            }
          });
          const W2 = {
            ">": "\\\\cdrightarrow",
            "<": "\\\\cdleftarrow",
            "=": "\\\\cdlongequal",
            A: "\\uparrow",
            V: "\\downarrow",
            "|": "\\Vert",
            ".": "no arrow"
          }, Xl = () => ({
            type: "styling",
            body: [],
            mode: "math",
            style: "display"
          }), Yl = (a) => a.type === "textord" && a.text === "@", K2 = (a, u) => (a.type === "mathord" || a.type === "atom") && a.text === u;
          function X2(a, u, c) {
            const d = W2[a];
            switch (d) {
              case "\\\\cdrightarrow":
              case "\\\\cdleftarrow":
                return c.callFunction(d, [u[0]], [u[1]]);
              case "\\uparrow":
              case "\\downarrow": {
                const m = c.callFunction("\\\\cdleft", [u[0]], []), y = {
                  type: "atom",
                  text: d,
                  mode: "math",
                  family: "rel"
                }, _ = c.callFunction("\\Big", [y], []), E = c.callFunction("\\\\cdright", [u[1]], []), M = {
                  type: "ordgroup",
                  mode: "math",
                  body: [m, _, E]
                };
                return c.callFunction("\\\\cdparent", [M], []);
              }
              case "\\\\cdlongequal":
                return c.callFunction("\\\\cdlongequal", [], []);
              case "\\Vert": {
                const m = {
                  type: "textord",
                  text: "\\Vert",
                  mode: "math"
                };
                return c.callFunction("\\Big", [m], []);
              }
              default:
                return {
                  type: "textord",
                  text: " ",
                  mode: "math"
                };
            }
          }
          function Y2(a) {
            const u = [];
            for (a.gullet.beginGroup(), a.gullet.macros.set("\\cr", "\\\\\\relax"), a.gullet.beginGroup(); ; ) {
              u.push(a.parseExpression(false, "\\\\")), a.gullet.endGroup(), a.gullet.beginGroup();
              const y = a.fetch().text;
              if (y === "&" || y === "\\\\")
                a.consume();
              else if (y === "\\end") {
                u[u.length - 1].length === 0 && u.pop();
                break;
              } else
                throw new s("Expected \\\\ or \\cr or \\end", a.nextToken);
            }
            let c = [];
            const d = [c];
            for (let y = 0; y < u.length; y++) {
              const _ = u[y];
              let E = Xl();
              for (let M = 0; M < _.length; M++)
                if (!Yl(_[M]))
                  E.body.push(_[M]);
                else {
                  c.push(E), M += 1;
                  const B = wu(_[M]).text, H = new Array(2);
                  if (H[0] = {
                    type: "ordgroup",
                    mode: "math",
                    body: []
                  }, H[1] = {
                    type: "ordgroup",
                    mode: "math",
                    body: []
                  }, !("=|.".indexOf(B) > -1)) if ("<>AV".indexOf(B) > -1)
                    for (let re = 0; re < 2; re++) {
                      let me = true;
                      for (let be = M + 1; be < _.length; be++) {
                        if (K2(_[be], B)) {
                          me = false, M = be;
                          break;
                        }
                        if (Yl(_[be]))
                          throw new s("Missing a " + B + " character to complete a CD arrow.", _[be]);
                        H[re].body.push(_[be]);
                      }
                      if (me)
                        throw new s("Missing a " + B + " character to complete a CD arrow.", _[M]);
                    }
                  else
                    throw new s('Expected one of "<>AV=|." after @', _[M]);
                  const W = {
                    type: "styling",
                    body: [X2(B, H, a)],
                    mode: "math",
                    style: "display"
                    // CD is always displaystyle.
                  };
                  c.push(W), E = Xl();
                }
              y % 2 === 0 ? c.push(E) : c.shift(), c = [], d.push(c);
            }
            a.gullet.endGroup(), a.gullet.endGroup();
            const m = new Array(d[0].length).fill({
              type: "align",
              align: "c",
              pregap: 0.25,
              // CD package sets \enskip between columns.
              postgap: 0.25
              // So pre and post each get half an \enskip, i.e. 0.25em.
            });
            return {
              type: "array",
              mode: "math",
              body: d,
              arraystretch: 1,
              addJot: true,
              rowGaps: [null],
              cols: m,
              colSeparationType: "CD",
              hLinesBeforeRow: new Array(d.length + 1).fill([])
            };
          }
          de({
            type: "cdlabel",
            names: ["\\\\cdleft", "\\\\cdright"],
            props: {
              numArgs: 1
            },
            handler(a, u) {
              let {
                parser: c,
                funcName: d
              } = a;
              return {
                type: "cdlabel",
                mode: c.mode,
                side: d.slice(4),
                label: u[0]
              };
            },
            htmlBuilder(a, u) {
              const c = u.havingStyle(u.style.sup()), d = G.wrapFragment(Fe(a.label, c, u), u);
              return d.classes.push("cd-label-" + a.side), d.style.bottom = ce(0.8 - d.depth), d.height = 0, d.depth = 0, d;
            },
            mathmlBuilder(a, u) {
              let c = new oe.MathNode("mrow", [je(a.label, u)]);
              return c = new oe.MathNode("mpadded", [c]), c.setAttribute("width", "0"), a.side === "left" && c.setAttribute("lspace", "-1width"), c.setAttribute("voffset", "0.7em"), c = new oe.MathNode("mstyle", [c]), c.setAttribute("displaystyle", "false"), c.setAttribute("scriptlevel", "1"), c;
            }
          }), de({
            type: "cdlabelparent",
            names: ["\\\\cdparent"],
            props: {
              numArgs: 1
            },
            handler(a, u) {
              let {
                parser: c
              } = a;
              return {
                type: "cdlabelparent",
                mode: c.mode,
                fragment: u[0]
              };
            },
            htmlBuilder(a, u) {
              const c = G.wrapFragment(Fe(a.fragment, u), u);
              return c.classes.push("cd-vert-arrow"), c;
            },
            mathmlBuilder(a, u) {
              return new oe.MathNode("mrow", [je(a.fragment, u)]);
            }
          }), de({
            type: "textord",
            names: ["\\@char"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler(a, u) {
              let {
                parser: c
              } = a;
              const m = Ae(u[0], "ordgroup").body;
              let y = "";
              for (let M = 0; M < m.length; M++) {
                const B = Ae(m[M], "textord");
                y += B.text;
              }
              let _ = parseInt(y), E;
              if (isNaN(_))
                throw new s("\\@char has non-numeric argument " + y);
              if (_ < 0 || _ >= 1114111)
                throw new s("\\@char with invalid code point " + y);
              return _ <= 65535 ? E = String.fromCharCode(_) : (_ -= 65536, E = String.fromCharCode((_ >> 10) + 55296, (_ & 1023) + 56320)), {
                type: "textord",
                mode: c.mode,
                text: E
              };
            }
          });
          const Zl = (a, u) => {
            const c = ct(a.body, u.withColor(a.color), false);
            return G.makeFragment(c);
          }, Jl = (a, u) => {
            const c = Ct(a.body, u.withColor(a.color)), d = new oe.MathNode("mstyle", c);
            return d.setAttribute("mathcolor", a.color), d;
          };
          de({
            type: "color",
            names: ["\\textcolor"],
            props: {
              numArgs: 2,
              allowedInText: true,
              argTypes: ["color", "original"]
            },
            handler(a, u) {
              let {
                parser: c
              } = a;
              const d = Ae(u[0], "color-token").color, m = u[1];
              return {
                type: "color",
                mode: c.mode,
                color: d,
                body: st(m)
              };
            },
            htmlBuilder: Zl,
            mathmlBuilder: Jl
          }), de({
            type: "color",
            names: ["\\color"],
            props: {
              numArgs: 1,
              allowedInText: true,
              argTypes: ["color"]
            },
            handler(a, u) {
              let {
                parser: c,
                breakOnTokenText: d
              } = a;
              const m = Ae(u[0], "color-token").color;
              c.gullet.macros.set("\\current@color", m);
              const y = c.parseExpression(true, d);
              return {
                type: "color",
                mode: c.mode,
                color: m,
                body: y
              };
            },
            htmlBuilder: Zl,
            mathmlBuilder: Jl
          }), de({
            type: "cr",
            names: ["\\\\"],
            props: {
              numArgs: 0,
              numOptionalArgs: 0,
              allowedInText: true
            },
            handler(a, u, c) {
              let {
                parser: d
              } = a;
              const m = d.gullet.future().text === "[" ? d.parseSizeGroup(true) : null, y = !d.settings.displayMode || !d.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
              return {
                type: "cr",
                mode: d.mode,
                newLine: y,
                size: m && Ae(m, "size").value
              };
            },
            // The following builders are called only at the top level,
            // not within tabular/array environments.
            htmlBuilder(a, u) {
              const c = G.makeSpan(["mspace"], [], u);
              return a.newLine && (c.classes.push("newline"), a.size && (c.style.marginTop = ce(Qe(a.size, u)))), c;
            },
            mathmlBuilder(a, u) {
              const c = new oe.MathNode("mspace");
              return a.newLine && (c.setAttribute("linebreak", "newline"), a.size && c.setAttribute("height", ce(Qe(a.size, u)))), c;
            }
          });
          const ku = {
            "\\global": "\\global",
            "\\long": "\\\\globallong",
            "\\\\globallong": "\\\\globallong",
            "\\def": "\\gdef",
            "\\gdef": "\\gdef",
            "\\edef": "\\xdef",
            "\\xdef": "\\xdef",
            "\\let": "\\\\globallet",
            "\\futurelet": "\\\\globalfuture"
          }, Ql = (a) => {
            const u = a.text;
            if (/^(?:[\\{}$&#^_]|EOF)$/.test(u))
              throw new s("Expected a control sequence", a);
            return u;
          }, Z2 = (a) => {
            let u = a.gullet.popToken();
            return u.text === "=" && (u = a.gullet.popToken(), u.text === " " && (u = a.gullet.popToken())), u;
          }, ec = (a, u, c, d) => {
            let m = a.gullet.macros.get(c.text);
            m == null && (c.noexpand = true, m = {
              tokens: [c],
              numArgs: 0,
              // reproduce the same behavior in expansion
              unexpandable: !a.gullet.isExpandable(c.text)
            }), a.gullet.macros.set(u, m, d);
          };
          de({
            type: "internal",
            names: [
              "\\global",
              "\\long",
              "\\\\globallong"
              // canâ€™t be entered directly
            ],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler(a) {
              let {
                parser: u,
                funcName: c
              } = a;
              u.consumeSpaces();
              const d = u.fetch();
              if (ku[d.text])
                return (c === "\\global" || c === "\\\\globallong") && (d.text = ku[d.text]), Ae(u.parseFunction(), "internal");
              throw new s("Invalid token after macro prefix", d);
            }
          }), de({
            type: "internal",
            names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
            props: {
              numArgs: 0,
              allowedInText: true,
              primitive: true
            },
            handler(a) {
              let {
                parser: u,
                funcName: c
              } = a, d = u.gullet.popToken();
              const m = d.text;
              if (/^(?:[\\{}$&#^_]|EOF)$/.test(m))
                throw new s("Expected a control sequence", d);
              let y = 0, _;
              const E = [[]];
              for (; u.gullet.future().text !== "{"; )
                if (d = u.gullet.popToken(), d.text === "#") {
                  if (u.gullet.future().text === "{") {
                    _ = u.gullet.future(), E[y].push("{");
                    break;
                  }
                  if (d = u.gullet.popToken(), !/^[1-9]$/.test(d.text))
                    throw new s('Invalid argument number "' + d.text + '"');
                  if (parseInt(d.text) !== y + 1)
                    throw new s('Argument number "' + d.text + '" out of order');
                  y++, E.push([]);
                } else {
                  if (d.text === "EOF")
                    throw new s("Expected a macro definition");
                  E[y].push(d.text);
                }
              let {
                tokens: M
              } = u.gullet.consumeArg();
              return _ && M.unshift(_), (c === "\\edef" || c === "\\xdef") && (M = u.gullet.expandTokens(M), M.reverse()), u.gullet.macros.set(m, {
                tokens: M,
                numArgs: y,
                delimiters: E
              }, c === ku[c]), {
                type: "internal",
                mode: u.mode
              };
            }
          }), de({
            type: "internal",
            names: [
              "\\let",
              "\\\\globallet"
              // canâ€™t be entered directly
            ],
            props: {
              numArgs: 0,
              allowedInText: true,
              primitive: true
            },
            handler(a) {
              let {
                parser: u,
                funcName: c
              } = a;
              const d = Ql(u.gullet.popToken());
              u.gullet.consumeSpaces();
              const m = Z2(u);
              return ec(u, d, m, c === "\\\\globallet"), {
                type: "internal",
                mode: u.mode
              };
            }
          }), de({
            type: "internal",
            names: [
              "\\futurelet",
              "\\\\globalfuture"
              // canâ€™t be entered directly
            ],
            props: {
              numArgs: 0,
              allowedInText: true,
              primitive: true
            },
            handler(a) {
              let {
                parser: u,
                funcName: c
              } = a;
              const d = Ql(u.gullet.popToken()), m = u.gullet.popToken(), y = u.gullet.popToken();
              return ec(u, d, y, c === "\\\\globalfuture"), u.gullet.pushToken(y), u.gullet.pushToken(m), {
                type: "internal",
                mode: u.mode
              };
            }
          });
          const pi = function(a, u, c) {
            const d = et.math[a] && et.math[a].replace, m = uu(d || a, u, c);
            if (!m)
              throw new Error("Unsupported symbol " + a + " and font size " + u + ".");
            return m;
          }, _u = function(a, u, c, d) {
            const m = c.havingBaseStyle(u), y = G.makeSpan(d.concat(m.sizingClasses(c)), [a], c), _ = m.sizeMultiplier / c.sizeMultiplier;
            return y.height *= _, y.depth *= _, y.maxFontSize = m.sizeMultiplier, y;
          }, tc = function(a, u, c) {
            const d = u.havingBaseStyle(c), m = (1 - u.sizeMultiplier / d.sizeMultiplier) * u.fontMetrics().axisHeight;
            a.classes.push("delimcenter"), a.style.top = ce(m), a.height -= m, a.depth += m;
          }, J2 = function(a, u, c, d, m, y) {
            const _ = G.makeSymbol(a, "Main-Regular", m, d), E = _u(_, u, d, y);
            return c && tc(E, d, u), E;
          }, Q2 = function(a, u, c, d) {
            return G.makeSymbol(a, "Size" + u + "-Regular", c, d);
          }, nc = function(a, u, c, d, m, y) {
            const _ = Q2(a, u, m, d), E = _u(G.makeSpan(["delimsizing", "size" + u], [_], d), ne.TEXT, d, y);
            return c && tc(E, d, ne.TEXT), E;
          }, Su = function(a, u, c) {
            let d;
            return u === "Size1-Regular" ? d = "delim-size1" : d = "delim-size4", {
              type: "elem",
              elem: G.makeSpan(["delimsizinginner", d], [G.makeSpan([], [G.makeSymbol(a, u, c)])])
            };
          }, Au = function(a, u, c) {
            const d = sn["Size4-Regular"][a.charCodeAt(0)] ? sn["Size4-Regular"][a.charCodeAt(0)][4] : sn["Size1-Regular"][a.charCodeAt(0)][4], m = new qn("inner", kl(a, Math.round(1e3 * u))), y = new kn([m], {
              width: ce(d),
              height: ce(u),
              // Override CSS rule `.katex svg { width: 100% }`
              style: "width:" + ce(d),
              viewBox: "0 0 " + 1e3 * d + " " + Math.round(1e3 * u),
              preserveAspectRatio: "xMinYMin"
            }), _ = G.makeSvgSpan([], [y], c);
            return _.height = u, _.style.height = ce(u), _.style.width = ce(d), {
              type: "elem",
              elem: _
            };
          }, Eu = 8e-3, Es = {
            type: "kern",
            size: -1 * Eu
          }, em = ["|", "\\lvert", "\\rvert", "\\vert"], tm = ["\\|", "\\lVert", "\\rVert", "\\Vert"], rc = function(a, u, c, d, m, y) {
            let _, E, M, B, H = "", U = 0;
            _ = M = B = a, E = null;
            let W = "Size1-Regular";
            a === "\\uparrow" ? M = B = "â" : a === "\\Uparrow" ? M = B = "â€–" : a === "\\downarrow" ? _ = M = "â" : a === "\\Downarrow" ? _ = M = "â€–" : a === "\\updownarrow" ? (_ = "\\uparrow", M = "â", B = "\\downarrow") : a === "\\Updownarrow" ? (_ = "\\Uparrow", M = "â€–", B = "\\Downarrow") : D.contains(em, a) ? (M = "âˆ£", H = "vert", U = 333) : D.contains(tm, a) ? (M = "âˆ¥", H = "doublevert", U = 556) : a === "[" || a === "\\lbrack" ? (_ = "â¡", M = "â¢", B = "â£", W = "Size4-Regular", H = "lbrack", U = 667) : a === "]" || a === "\\rbrack" ? (_ = "â¤", M = "â¥", B = "â¦", W = "Size4-Regular", H = "rbrack", U = 667) : a === "\\lfloor" || a === "âŒŠ" ? (M = _ = "â¢", B = "â£", W = "Size4-Regular", H = "lfloor", U = 667) : a === "\\lceil" || a === "âŒˆ" ? (_ = "â¡", M = B = "â¢", W = "Size4-Regular", H = "lceil", U = 667) : a === "\\rfloor" || a === "âŒ‹" ? (M = _ = "â¥", B = "â¦", W = "Size4-Regular", H = "rfloor", U = 667) : a === "\\rceil" || a === "âŒ‰" ? (_ = "â¤", M = B = "â¥", W = "Size4-Regular", H = "rceil", U = 667) : a === "(" || a === "\\lparen" ? (_ = "â›", M = "âœ", B = "â", W = "Size4-Regular", H = "lparen", U = 875) : a === ")" || a === "\\rparen" ? (_ = "â", M = "âŸ", B = "â ", W = "Size4-Regular", H = "rparen", U = 875) : a === "\\{" || a === "\\lbrace" ? (_ = "â§", E = "â¨", B = "â©", M = "âª", W = "Size4-Regular") : a === "\\}" || a === "\\rbrace" ? (_ = "â«", E = "â¬", B = "â­", M = "âª", W = "Size4-Regular") : a === "\\lgroup" || a === "âŸ®" ? (_ = "â§", B = "â©", M = "âª", W = "Size4-Regular") : a === "\\rgroup" || a === "âŸ¯" ? (_ = "â«", B = "â­", M = "âª", W = "Size4-Regular") : a === "\\lmoustache" || a === "â°" ? (_ = "â§", B = "â­", M = "âª", W = "Size4-Regular") : (a === "\\rmoustache" || a === "â±") && (_ = "â«", B = "â©", M = "âª", W = "Size4-Regular");
            const re = pi(_, W, m), me = re.height + re.depth, be = pi(M, W, m), Ne = be.height + be.depth, Ee = pi(B, W, m), Ie = Ee.height + Ee.depth;
            let ze = 0, Ve = 1;
            if (E !== null) {
              const it = pi(E, W, m);
              ze = it.height + it.depth, Ve = 2;
            }
            const _t = me + Ie + ze, ft = Math.max(0, Math.ceil((u - _t) / (Ve * Ne))), jt = _t + ft * Ve * Ne;
            let Tr = d.fontMetrics().axisHeight;
            c && (Tr *= d.sizeMultiplier);
            const Be = jt / 2 - Tr, Re = [];
            if (H.length > 0) {
              const it = jt - me - Ie, nt = Math.round(jt * 1e3), Ut = a2(H, Math.round(it * 1e3)), Cm = new qn(H, Ut), Wc = (U / 1e3).toFixed(3) + "em", Kc = (nt / 1e3).toFixed(3) + "em", Tm = new kn([Cm], {
                width: Wc,
                height: Kc,
                viewBox: "0 0 " + U + " " + nt
              }), Ns = G.makeSvgSpan([], [Tm], d);
              Ns.height = nt / 1e3, Ns.style.width = Wc, Ns.style.height = Kc, Re.push({
                type: "elem",
                elem: Ns
              });
            } else {
              if (Re.push(Su(B, W, m)), Re.push(Es), E === null) {
                const it = jt - me - Ie + 2 * Eu;
                Re.push(Au(M, it, d));
              } else {
                const it = (jt - me - Ie - ze) / 2 + 2 * Eu;
                Re.push(Au(M, it, d)), Re.push(Es), Re.push(Su(E, W, m)), Re.push(Es), Re.push(Au(M, it, d));
              }
              Re.push(Es), Re.push(Su(_, W, m));
            }
            const Xe = d.havingBaseStyle(ne.TEXT), Ze = G.makeVList({
              positionType: "bottom",
              positionData: Be,
              children: Re
            }, Xe);
            return _u(G.makeSpan(["delimsizing", "mult"], [Ze], Xe), ne.TEXT, d, y);
          }, Cu = 80, Tu = 0.08, Du = function(a, u, c, d, m) {
            const y = wn(a, d, c), _ = new qn(a, y), E = new kn([_], {
              // Note: 1000:1 ratio of viewBox to document em width.
              width: "400em",
              height: ce(u),
              viewBox: "0 0 400000 " + c,
              preserveAspectRatio: "xMinYMin slice"
            });
            return G.makeSvgSpan(["hide-tail"], [E], m);
          }, nm = function(a, u) {
            const c = u.havingBaseSizing(), d = oc("\\surd", a * c.sizeMultiplier, uc, c);
            let m = c.sizeMultiplier;
            const y = Math.max(0, u.minRuleThickness - u.fontMetrics().sqrtRuleThickness);
            let _, E = 0, M = 0, B = 0, H;
            return d.type === "small" ? (B = 1e3 + 1e3 * y + Cu, a < 1 ? m = 1 : a < 1.4 && (m = 0.7), E = (1 + y + Tu) / m, M = (1 + y) / m, _ = Du("sqrtMain", E, B, y, u), _.style.minWidth = "0.853em", H = 0.833 / m) : d.type === "large" ? (B = (1e3 + Cu) * mi[d.size], M = (mi[d.size] + y) / m, E = (mi[d.size] + y + Tu) / m, _ = Du("sqrtSize" + d.size, E, B, y, u), _.style.minWidth = "1.02em", H = 1 / m) : (E = a + y + Tu, M = a + y, B = Math.floor(1e3 * a + y) + Cu, _ = Du("sqrtTall", E, B, y, u), _.style.minWidth = "0.742em", H = 1.056), _.height = M, _.style.height = ce(E), {
              span: _,
              advanceWidth: H,
              // Calculate the actual line width.
              // This actually should depend on the chosen font -- e.g. \boldmath
              // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
              // have thicker rules.
              ruleWidth: (u.fontMetrics().sqrtRuleThickness + y) * m
            };
          }, ic = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "âŒŠ", "âŒ‹", "\\lceil", "\\rceil", "âŒˆ", "âŒ‰", "\\surd"], rm = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "âŸ®", "âŸ¯", "\\lmoustache", "\\rmoustache", "â°", "â±"], sc = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"], mi = [0, 1.2, 1.8, 2.4, 3], im = function(a, u, c, d, m) {
            if (a === "<" || a === "\\lt" || a === "âŸ¨" ? a = "\\langle" : (a === ">" || a === "\\gt" || a === "âŸ©") && (a = "\\rangle"), D.contains(ic, a) || D.contains(sc, a))
              return nc(a, u, false, c, d, m);
            if (D.contains(rm, a))
              return rc(a, mi[u], false, c, d, m);
            throw new s("Illegal delimiter: '" + a + "'");
          }, sm = [{
            type: "small",
            style: ne.SCRIPTSCRIPT
          }, {
            type: "small",
            style: ne.SCRIPT
          }, {
            type: "small",
            style: ne.TEXT
          }, {
            type: "large",
            size: 1
          }, {
            type: "large",
            size: 2
          }, {
            type: "large",
            size: 3
          }, {
            type: "large",
            size: 4
          }], um = [{
            type: "small",
            style: ne.SCRIPTSCRIPT
          }, {
            type: "small",
            style: ne.SCRIPT
          }, {
            type: "small",
            style: ne.TEXT
          }, {
            type: "stack"
          }], uc = [{
            type: "small",
            style: ne.SCRIPTSCRIPT
          }, {
            type: "small",
            style: ne.SCRIPT
          }, {
            type: "small",
            style: ne.TEXT
          }, {
            type: "large",
            size: 1
          }, {
            type: "large",
            size: 2
          }, {
            type: "large",
            size: 3
          }, {
            type: "large",
            size: 4
          }, {
            type: "stack"
          }], om = function(a) {
            if (a.type === "small")
              return "Main-Regular";
            if (a.type === "large")
              return "Size" + a.size + "-Regular";
            if (a.type === "stack")
              return "Size4-Regular";
            throw new Error("Add support for delim type '" + a.type + "' here.");
          }, oc = function(a, u, c, d) {
            const m = Math.min(2, 3 - d.style.size);
            for (let y = m; y < c.length && c[y].type !== "stack"; y++) {
              const _ = pi(a, om(c[y]), "math");
              let E = _.height + _.depth;
              if (c[y].type === "small") {
                const M = d.havingBaseStyle(c[y].style);
                E *= M.sizeMultiplier;
              }
              if (E > u)
                return c[y];
            }
            return c[c.length - 1];
          }, ac = function(a, u, c, d, m, y) {
            a === "<" || a === "\\lt" || a === "âŸ¨" ? a = "\\langle" : (a === ">" || a === "\\gt" || a === "âŸ©") && (a = "\\rangle");
            let _;
            D.contains(sc, a) ? _ = sm : D.contains(ic, a) ? _ = uc : _ = um;
            const E = oc(a, u, _, d);
            return E.type === "small" ? J2(a, E.style, c, d, m, y) : E.type === "large" ? nc(a, E.size, c, d, m, y) : rc(a, u, c, d, m, y);
          };
          var Cn = {
            sqrtImage: nm,
            sizedDelim: im,
            sizeToMaxHeight: mi,
            customSizedDelim: ac,
            leftRightDelim: function(a, u, c, d, m, y) {
              const _ = d.fontMetrics().axisHeight * d.sizeMultiplier, E = 901, M = 5 / d.fontMetrics().ptPerEm, B = Math.max(u - _, c + _), H = Math.max(
                // In real TeX, calculations are done using integral values which are
                // 65536 per pt, or 655360 per em. So, the division here truncates in
                // TeX but doesn't here, producing different results. If we wanted to
                // exactly match TeX's calculation, we could do
                //   Math.floor(655360 * maxDistFromAxis / 500) *
                //    delimiterFactor / 655360
                // (To see the difference, compare
                //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
                // in TeX and KaTeX)
                B / 500 * E,
                2 * B - M
              );
              return ac(a, H, true, d, m, y);
            }
          };
          const lc = {
            "\\bigl": {
              mclass: "mopen",
              size: 1
            },
            "\\Bigl": {
              mclass: "mopen",
              size: 2
            },
            "\\biggl": {
              mclass: "mopen",
              size: 3
            },
            "\\Biggl": {
              mclass: "mopen",
              size: 4
            },
            "\\bigr": {
              mclass: "mclose",
              size: 1
            },
            "\\Bigr": {
              mclass: "mclose",
              size: 2
            },
            "\\biggr": {
              mclass: "mclose",
              size: 3
            },
            "\\Biggr": {
              mclass: "mclose",
              size: 4
            },
            "\\bigm": {
              mclass: "mrel",
              size: 1
            },
            "\\Bigm": {
              mclass: "mrel",
              size: 2
            },
            "\\biggm": {
              mclass: "mrel",
              size: 3
            },
            "\\Biggm": {
              mclass: "mrel",
              size: 4
            },
            "\\big": {
              mclass: "mord",
              size: 1
            },
            "\\Big": {
              mclass: "mord",
              size: 2
            },
            "\\bigg": {
              mclass: "mord",
              size: 3
            },
            "\\Bigg": {
              mclass: "mord",
              size: 4
            }
          }, am = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "âŒŠ", "âŒ‹", "\\lceil", "\\rceil", "âŒˆ", "âŒ‰", "<", ">", "\\langle", "âŸ¨", "\\rangle", "âŸ©", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "âŸ®", "âŸ¯", "\\lmoustache", "\\rmoustache", "â°", "â±", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
          function Cs(a, u) {
            const c = _s(a);
            if (c && D.contains(am, c.text))
              return c;
            throw c ? new s("Invalid delimiter '" + c.text + "' after '" + u.funcName + "'", a) : new s("Invalid delimiter type '" + a.type + "'", a);
          }
          de({
            type: "delimsizing",
            names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
            props: {
              numArgs: 1,
              argTypes: ["primitive"]
            },
            handler: (a, u) => {
              const c = Cs(u[0], a);
              return {
                type: "delimsizing",
                mode: a.parser.mode,
                size: lc[a.funcName].size,
                mclass: lc[a.funcName].mclass,
                delim: c.text
              };
            },
            htmlBuilder: (a, u) => a.delim === "." ? G.makeSpan([a.mclass]) : Cn.sizedDelim(a.delim, a.size, u, a.mode, [a.mclass]),
            mathmlBuilder: (a) => {
              const u = [];
              a.delim !== "." && u.push(Pt(a.delim, a.mode));
              const c = new oe.MathNode("mo", u);
              a.mclass === "mopen" || a.mclass === "mclose" ? c.setAttribute("fence", "true") : c.setAttribute("fence", "false"), c.setAttribute("stretchy", "true");
              const d = ce(Cn.sizeToMaxHeight[a.size]);
              return c.setAttribute("minsize", d), c.setAttribute("maxsize", d), c;
            }
          });
          function cc(a) {
            if (!a.body)
              throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
          }
          de({
            type: "leftright-right",
            names: ["\\right"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler: (a, u) => {
              const c = a.parser.gullet.macros.get("\\current@color");
              if (c && typeof c != "string")
                throw new s("\\current@color set to non-string in \\right");
              return {
                type: "leftright-right",
                mode: a.parser.mode,
                delim: Cs(u[0], a).text,
                color: c
                // undefined if not set via \color
              };
            }
          }), de({
            type: "leftright",
            names: ["\\left"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler: (a, u) => {
              const c = Cs(u[0], a), d = a.parser;
              ++d.leftrightDepth;
              const m = d.parseExpression(false);
              --d.leftrightDepth, d.expect("\\right", false);
              const y = Ae(d.parseFunction(), "leftright-right");
              return {
                type: "leftright",
                mode: d.mode,
                body: m,
                left: c.text,
                right: y.delim,
                rightColor: y.color
              };
            },
            htmlBuilder: (a, u) => {
              cc(a);
              const c = ct(a.body, u, true, ["mopen", "mclose"]);
              let d = 0, m = 0, y = false;
              for (let M = 0; M < c.length; M++)
                c[M].isMiddle ? y = true : (d = Math.max(c[M].height, d), m = Math.max(c[M].depth, m));
              d *= u.sizeMultiplier, m *= u.sizeMultiplier;
              let _;
              if (a.left === "." ? _ = di(u, ["mopen"]) : _ = Cn.leftRightDelim(a.left, d, m, u, a.mode, ["mopen"]), c.unshift(_), y)
                for (let M = 1; M < c.length; M++) {
                  const H = c[M].isMiddle;
                  H && (c[M] = Cn.leftRightDelim(H.delim, d, m, H.options, a.mode, []));
                }
              let E;
              if (a.right === ".")
                E = di(u, ["mclose"]);
              else {
                const M = a.rightColor ? u.withColor(a.rightColor) : u;
                E = Cn.leftRightDelim(a.right, d, m, M, a.mode, ["mclose"]);
              }
              return c.push(E), G.makeSpan(["minner"], c, u);
            },
            mathmlBuilder: (a, u) => {
              cc(a);
              const c = Ct(a.body, u);
              if (a.left !== ".") {
                const d = new oe.MathNode("mo", [Pt(a.left, a.mode)]);
                d.setAttribute("fence", "true"), c.unshift(d);
              }
              if (a.right !== ".") {
                const d = new oe.MathNode("mo", [Pt(a.right, a.mode)]);
                d.setAttribute("fence", "true"), a.rightColor && d.setAttribute("mathcolor", a.rightColor), c.push(d);
              }
              return bu(c);
            }
          }), de({
            type: "middle",
            names: ["\\middle"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler: (a, u) => {
              const c = Cs(u[0], a);
              if (!a.parser.leftrightDepth)
                throw new s("\\middle without preceding \\left", c);
              return {
                type: "middle",
                mode: a.parser.mode,
                delim: c.text
              };
            },
            htmlBuilder: (a, u) => {
              let c;
              if (a.delim === ".")
                c = di(u, []);
              else {
                c = Cn.sizedDelim(a.delim, 1, u, a.mode, []);
                const d = {
                  delim: a.delim,
                  options: u
                };
                c.isMiddle = d;
              }
              return c;
            },
            mathmlBuilder: (a, u) => {
              const c = a.delim === "\\vert" || a.delim === "|" ? Pt("|", "text") : Pt(a.delim, a.mode), d = new oe.MathNode("mo", [c]);
              return d.setAttribute("fence", "true"), d.setAttribute("lspace", "0.05em"), d.setAttribute("rspace", "0.05em"), d;
            }
          });
          const Mu = (a, u) => {
            const c = G.wrapFragment(Fe(a.body, u), u), d = a.label.slice(1);
            let m = u.sizeMultiplier, y, _ = 0;
            const E = D.isCharacterBox(a.body);
            if (d === "sout")
              y = G.makeSpan(["stretchy", "sout"]), y.height = u.fontMetrics().defaultRuleThickness / m, _ = -0.5 * u.fontMetrics().xHeight;
            else if (d === "phase") {
              const B = Qe({
                number: 0.6,
                unit: "pt"
              }, u), H = Qe({
                number: 0.35,
                unit: "ex"
              }, u), U = u.havingBaseSizing();
              m = m / U.sizeMultiplier;
              const W = c.height + c.depth + B + H;
              c.style.paddingLeft = ce(W / 2 + B);
              const re = Math.floor(1e3 * W * m), me = vt(re), be = new kn([new qn("phase", me)], {
                width: "400em",
                height: ce(re / 1e3),
                viewBox: "0 0 400000 " + re,
                preserveAspectRatio: "xMinYMin slice"
              });
              y = G.makeSvgSpan(["hide-tail"], [be], u), y.style.height = ce(W), _ = c.depth + B + H;
            } else {
              /cancel/.test(d) ? E || c.classes.push("cancel-pad") : d === "angl" ? c.classes.push("anglpad") : c.classes.push("boxpad");
              let B = 0, H = 0, U = 0;
              /box/.test(d) ? (U = Math.max(
                u.fontMetrics().fboxrule,
                // default
                u.minRuleThickness
                // User override.
              ), B = u.fontMetrics().fboxsep + (d === "colorbox" ? 0 : U), H = B) : d === "angl" ? (U = Math.max(u.fontMetrics().defaultRuleThickness, u.minRuleThickness), B = 4 * U, H = Math.max(0, 0.25 - c.depth)) : (B = E ? 0.2 : 0, H = B), y = En.encloseSpan(c, d, B, H, u), /fbox|boxed|fcolorbox/.test(d) ? (y.style.borderStyle = "solid", y.style.borderWidth = ce(U)) : d === "angl" && U !== 0.049 && (y.style.borderTopWidth = ce(U), y.style.borderRightWidth = ce(U)), _ = c.depth + H, a.backgroundColor && (y.style.backgroundColor = a.backgroundColor, a.borderColor && (y.style.borderColor = a.borderColor));
            }
            let M;
            if (a.backgroundColor)
              M = G.makeVList({
                positionType: "individualShift",
                children: [
                  // Put the color background behind inner;
                  {
                    type: "elem",
                    elem: y,
                    shift: _
                  },
                  {
                    type: "elem",
                    elem: c,
                    shift: 0
                  }
                ]
              }, u);
            else {
              const B = /cancel|phase/.test(d) ? ["svg-align"] : [];
              M = G.makeVList({
                positionType: "individualShift",
                children: [
                  // Write the \cancel stroke on top of inner.
                  {
                    type: "elem",
                    elem: c,
                    shift: 0
                  },
                  {
                    type: "elem",
                    elem: y,
                    shift: _,
                    wrapperClasses: B
                  }
                ]
              }, u);
            }
            return /cancel/.test(d) && (M.height = c.height, M.depth = c.depth), /cancel/.test(d) && !E ? G.makeSpan(["mord", "cancel-lap"], [M], u) : G.makeSpan(["mord"], [M], u);
          }, Nu = (a, u) => {
            let c = 0;
            const d = new oe.MathNode(a.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [je(a.body, u)]);
            switch (a.label) {
              case "\\cancel":
                d.setAttribute("notation", "updiagonalstrike");
                break;
              case "\\bcancel":
                d.setAttribute("notation", "downdiagonalstrike");
                break;
              case "\\phase":
                d.setAttribute("notation", "phasorangle");
                break;
              case "\\sout":
                d.setAttribute("notation", "horizontalstrike");
                break;
              case "\\fbox":
                d.setAttribute("notation", "box");
                break;
              case "\\angl":
                d.setAttribute("notation", "actuarial");
                break;
              case "\\fcolorbox":
              case "\\colorbox":
                if (c = u.fontMetrics().fboxsep * u.fontMetrics().ptPerEm, d.setAttribute("width", "+" + 2 * c + "pt"), d.setAttribute("height", "+" + 2 * c + "pt"), d.setAttribute("lspace", c + "pt"), d.setAttribute("voffset", c + "pt"), a.label === "\\fcolorbox") {
                  const m = Math.max(
                    u.fontMetrics().fboxrule,
                    // default
                    u.minRuleThickness
                    // user override
                  );
                  d.setAttribute("style", "border: " + m + "em solid " + String(a.borderColor));
                }
                break;
              case "\\xcancel":
                d.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
                break;
            }
            return a.backgroundColor && d.setAttribute("mathbackground", a.backgroundColor), d;
          };
          de({
            type: "enclose",
            names: ["\\colorbox"],
            props: {
              numArgs: 2,
              allowedInText: true,
              argTypes: ["color", "text"]
            },
            handler(a, u, c) {
              let {
                parser: d,
                funcName: m
              } = a;
              const y = Ae(u[0], "color-token").color, _ = u[1];
              return {
                type: "enclose",
                mode: d.mode,
                label: m,
                backgroundColor: y,
                body: _
              };
            },
            htmlBuilder: Mu,
            mathmlBuilder: Nu
          }), de({
            type: "enclose",
            names: ["\\fcolorbox"],
            props: {
              numArgs: 3,
              allowedInText: true,
              argTypes: ["color", "color", "text"]
            },
            handler(a, u, c) {
              let {
                parser: d,
                funcName: m
              } = a;
              const y = Ae(u[0], "color-token").color, _ = Ae(u[1], "color-token").color, E = u[2];
              return {
                type: "enclose",
                mode: d.mode,
                label: m,
                backgroundColor: _,
                borderColor: y,
                body: E
              };
            },
            htmlBuilder: Mu,
            mathmlBuilder: Nu
          }), de({
            type: "enclose",
            names: ["\\fbox"],
            props: {
              numArgs: 1,
              argTypes: ["hbox"],
              allowedInText: true
            },
            handler(a, u) {
              let {
                parser: c
              } = a;
              return {
                type: "enclose",
                mode: c.mode,
                label: "\\fbox",
                body: u[0]
              };
            }
          }), de({
            type: "enclose",
            names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
            props: {
              numArgs: 1
            },
            handler(a, u) {
              let {
                parser: c,
                funcName: d
              } = a;
              const m = u[0];
              return {
                type: "enclose",
                mode: c.mode,
                label: d,
                body: m
              };
            },
            htmlBuilder: Mu,
            mathmlBuilder: Nu
          }), de({
            type: "enclose",
            names: ["\\angl"],
            props: {
              numArgs: 1,
              argTypes: ["hbox"],
              allowedInText: false
            },
            handler(a, u) {
              let {
                parser: c
              } = a;
              return {
                type: "enclose",
                mode: c.mode,
                label: "\\angl",
                body: u[0]
              };
            }
          });
          const fc = {};
          function on(a) {
            let {
              type: u,
              names: c,
              props: d,
              handler: m,
              htmlBuilder: y,
              mathmlBuilder: _
            } = a;
            const E = {
              type: u,
              numArgs: d.numArgs || 0,
              allowedInText: false,
              numOptionalArgs: 0,
              handler: m
            };
            for (let M = 0; M < c.length; ++M)
              fc[c[M]] = E;
            y && (xs[u] = y), _ && (ws[u] = _);
          }
          const hc = {};
          function C(a, u) {
            hc[a] = u;
          }
          class Ot {
            // The + prefix indicates that these fields aren't writeable
            // Lexer holding the input string.
            // Start offset, zero-based inclusive.
            // End offset, zero-based exclusive.
            constructor(u, c, d) {
              this.lexer = void 0, this.start = void 0, this.end = void 0, this.lexer = u, this.start = c, this.end = d;
            }
            /**
             * Merges two `SourceLocation`s from location providers, given they are
             * provided in order of appearance.
             * - Returns the first one's location if only the first is provided.
             * - Returns a merged range of the first and the last if both are provided
             *   and their lexers match.
             * - Otherwise, returns null.
             */
            static range(u, c) {
              return c ? !u || !u.loc || !c.loc || u.loc.lexer !== c.loc.lexer ? null : new Ot(u.loc.lexer, u.loc.start, c.loc.end) : u && u.loc;
            }
          }
          class Ht {
            // don't expand the token
            // used in \noexpand
            constructor(u, c) {
              this.text = void 0, this.loc = void 0, this.noexpand = void 0, this.treatAsRelax = void 0, this.text = u, this.loc = c;
            }
            /**
             * Given a pair of tokens (this and endToken), compute a `Token` encompassing
             * the whole input range enclosed by these two.
             */
            range(u, c) {
              return new Ht(c, Ot.range(this, u));
            }
          }
          function dc(a) {
            const u = [];
            a.consumeSpaces();
            let c = a.fetch().text;
            for (c === "\\relax" && (a.consume(), a.consumeSpaces(), c = a.fetch().text); c === "\\hline" || c === "\\hdashline"; )
              a.consume(), u.push(c === "\\hdashline"), a.consumeSpaces(), c = a.fetch().text;
            return u;
          }
          const Ts = (a) => {
            if (!a.parser.settings.displayMode)
              throw new s("{" + a.envName + "} can be used only in display mode.");
          };
          function Iu(a) {
            if (a.indexOf("ed") === -1)
              return a.indexOf("*") === -1;
          }
          function Pn(a, u, c) {
            let {
              hskipBeforeAndAfter: d,
              addJot: m,
              cols: y,
              arraystretch: _,
              colSeparationType: E,
              autoTag: M,
              singleRow: B,
              emptySingleRow: H,
              maxNumCols: U,
              leqno: W
            } = u;
            if (a.gullet.beginGroup(), B || a.gullet.macros.set("\\cr", "\\\\\\relax"), !_) {
              const Ve = a.gullet.expandMacroAsText("\\arraystretch");
              if (Ve == null)
                _ = 1;
              else if (_ = parseFloat(Ve), !_ || _ < 0)
                throw new s("Invalid \\arraystretch: " + Ve);
            }
            a.gullet.beginGroup();
            let re = [];
            const me = [re], be = [], Ne = [], Ee = M != null ? [] : void 0;
            function Ie() {
              M && a.gullet.macros.set("\\@eqnsw", "1", true);
            }
            function ze() {
              Ee && (a.gullet.macros.get("\\df@tag") ? (Ee.push(a.subparse([new Ht("\\df@tag")])), a.gullet.macros.set("\\df@tag", void 0, true)) : Ee.push(!!M && a.gullet.macros.get("\\@eqnsw") === "1"));
            }
            for (Ie(), Ne.push(dc(a)); ; ) {
              let Ve = a.parseExpression(false, B ? "\\end" : "\\\\");
              a.gullet.endGroup(), a.gullet.beginGroup(), Ve = {
                type: "ordgroup",
                mode: a.mode,
                body: Ve
              }, c && (Ve = {
                type: "styling",
                mode: a.mode,
                style: c,
                body: [Ve]
              }), re.push(Ve);
              const _t = a.fetch().text;
              if (_t === "&") {
                if (U && re.length === U) {
                  if (B || E)
                    throw new s("Too many tab characters: &", a.nextToken);
                  a.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
                }
                a.consume();
              } else if (_t === "\\end") {
                ze(), re.length === 1 && Ve.type === "styling" && Ve.body[0].body.length === 0 && (me.length > 1 || !H) && me.pop(), Ne.length < me.length + 1 && Ne.push([]);
                break;
              } else if (_t === "\\\\") {
                a.consume();
                let ft;
                a.gullet.future().text !== " " && (ft = a.parseSizeGroup(true)), be.push(ft ? ft.value : null), ze(), Ne.push(dc(a)), re = [], me.push(re), Ie();
              } else
                throw new s("Expected & or \\\\ or \\cr or \\end", a.nextToken);
            }
            return a.gullet.endGroup(), a.gullet.endGroup(), {
              type: "array",
              mode: a.mode,
              addJot: m,
              arraystretch: _,
              body: me,
              cols: y,
              rowGaps: be,
              hskipBeforeAndAfter: d,
              hLinesBeforeRow: Ne,
              colSeparationType: E,
              tags: Ee,
              leqno: W
            };
          }
          function Fu(a) {
            return a.slice(0, 1) === "d" ? "display" : "text";
          }
          const an = function(a, u) {
            let c, d;
            const m = a.body.length, y = a.hLinesBeforeRow;
            let _ = 0, E = new Array(m);
            const M = [], B = Math.max(
              // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
              u.fontMetrics().arrayRuleWidth,
              u.minRuleThickness
              // User override.
            ), H = 1 / u.fontMetrics().ptPerEm;
            let U = 5 * H;
            a.colSeparationType && a.colSeparationType === "small" && (U = 0.2778 * (u.havingStyle(ne.SCRIPT).sizeMultiplier / u.sizeMultiplier));
            const W = a.colSeparationType === "CD" ? Qe({
              number: 3,
              unit: "ex"
            }, u) : 12 * H, re = 3 * H, me = a.arraystretch * W, be = 0.7 * me, Ne = 0.3 * me;
            let Ee = 0;
            function Ie(Be) {
              for (let Re = 0; Re < Be.length; ++Re)
                Re > 0 && (Ee += 0.25), M.push({
                  pos: Ee,
                  isDashed: Be[Re]
                });
            }
            for (Ie(y[0]), c = 0; c < a.body.length; ++c) {
              const Be = a.body[c];
              let Re = be, Xe = Ne;
              _ < Be.length && (_ = Be.length);
              const Ze = new Array(Be.length);
              for (d = 0; d < Be.length; ++d) {
                const Ut = Fe(Be[d], u);
                Xe < Ut.depth && (Xe = Ut.depth), Re < Ut.height && (Re = Ut.height), Ze[d] = Ut;
              }
              const it = a.rowGaps[c];
              let nt = 0;
              it && (nt = Qe(it, u), nt > 0 && (nt += Ne, Xe < nt && (Xe = nt), nt = 0)), a.addJot && (Xe += re), Ze.height = Re, Ze.depth = Xe, Ee += Re, Ze.pos = Ee, Ee += Xe + nt, E[c] = Ze, Ie(y[c + 1]);
            }
            const ze = Ee / 2 + u.fontMetrics().axisHeight, Ve = a.cols || [], _t = [];
            let ft, jt;
            const Tr = [];
            if (a.tags && a.tags.some((Be) => Be))
              for (c = 0; c < m; ++c) {
                const Be = E[c], Re = Be.pos - ze, Xe = a.tags[c];
                let Ze;
                Xe === true ? Ze = G.makeSpan(["eqn-num"], [], u) : Xe === false ? Ze = G.makeSpan([], [], u) : Ze = G.makeSpan([], ct(Xe, u, true), u), Ze.depth = Be.depth, Ze.height = Be.height, Tr.push({
                  type: "elem",
                  elem: Ze,
                  shift: Re
                });
              }
            for (
              d = 0, jt = 0;
              // Continue while either there are more columns or more column
              // descriptions, so trailing separators don't get lost.
              d < _ || jt < Ve.length;
              ++d, ++jt
            ) {
              let Be = Ve[jt] || {}, Re = true;
              for (; Be.type === "separator"; ) {
                if (Re || (ft = G.makeSpan(["arraycolsep"], []), ft.style.width = ce(u.fontMetrics().doubleRuleSep), _t.push(ft)), Be.separator === "|" || Be.separator === ":") {
                  const it = Be.separator === "|" ? "solid" : "dashed", nt = G.makeSpan(["vertical-separator"], [], u);
                  nt.style.height = ce(Ee), nt.style.borderRightWidth = ce(B), nt.style.borderRightStyle = it, nt.style.margin = "0 " + ce(-B / 2);
                  const Ut = Ee - ze;
                  Ut && (nt.style.verticalAlign = ce(-Ut)), _t.push(nt);
                } else
                  throw new s("Invalid separator type: " + Be.separator);
                jt++, Be = Ve[jt] || {}, Re = false;
              }
              if (d >= _)
                continue;
              let Xe;
              (d > 0 || a.hskipBeforeAndAfter) && (Xe = D.deflt(Be.pregap, U), Xe !== 0 && (ft = G.makeSpan(["arraycolsep"], []), ft.style.width = ce(Xe), _t.push(ft)));
              let Ze = [];
              for (c = 0; c < m; ++c) {
                const it = E[c], nt = it[d];
                if (!nt)
                  continue;
                const Ut = it.pos - ze;
                nt.depth = it.depth, nt.height = it.height, Ze.push({
                  type: "elem",
                  elem: nt,
                  shift: Ut
                });
              }
              Ze = G.makeVList({
                positionType: "individualShift",
                children: Ze
              }, u), Ze = G.makeSpan(["col-align-" + (Be.align || "c")], [Ze]), _t.push(Ze), (d < _ - 1 || a.hskipBeforeAndAfter) && (Xe = D.deflt(Be.postgap, U), Xe !== 0 && (ft = G.makeSpan(["arraycolsep"], []), ft.style.width = ce(Xe), _t.push(ft)));
            }
            if (E = G.makeSpan(["mtable"], _t), M.length > 0) {
              const Be = G.makeLineSpan("hline", u, B), Re = G.makeLineSpan("hdashline", u, B), Xe = [{
                type: "elem",
                elem: E,
                shift: 0
              }];
              for (; M.length > 0; ) {
                const Ze = M.pop(), it = Ze.pos - ze;
                Ze.isDashed ? Xe.push({
                  type: "elem",
                  elem: Re,
                  shift: it
                }) : Xe.push({
                  type: "elem",
                  elem: Be,
                  shift: it
                });
              }
              E = G.makeVList({
                positionType: "individualShift",
                children: Xe
              }, u);
            }
            if (Tr.length === 0)
              return G.makeSpan(["mord"], [E], u);
            {
              let Be = G.makeVList({
                positionType: "individualShift",
                children: Tr
              }, u);
              return Be = G.makeSpan(["tag"], [Be], u), G.makeFragment([E, Be]);
            }
          }, lm = {
            c: "center ",
            l: "left ",
            r: "right "
          }, ln = function(a, u) {
            const c = [], d = new oe.MathNode("mtd", [], ["mtr-glue"]), m = new oe.MathNode("mtd", [], ["mml-eqn-num"]);
            for (let U = 0; U < a.body.length; U++) {
              const W = a.body[U], re = [];
              for (let me = 0; me < W.length; me++)
                re.push(new oe.MathNode("mtd", [je(W[me], u)]));
              a.tags && a.tags[U] && (re.unshift(d), re.push(d), a.leqno ? re.unshift(m) : re.push(m)), c.push(new oe.MathNode("mtr", re));
            }
            let y = new oe.MathNode("mtable", c);
            const _ = a.arraystretch === 0.5 ? 0.1 : 0.16 + a.arraystretch - 1 + (a.addJot ? 0.09 : 0);
            y.setAttribute("rowspacing", ce(_));
            let E = "", M = "";
            if (a.cols && a.cols.length > 0) {
              const U = a.cols;
              let W = "", re = false, me = 0, be = U.length;
              U[0].type === "separator" && (E += "top ", me = 1), U[U.length - 1].type === "separator" && (E += "bottom ", be -= 1);
              for (let Ne = me; Ne < be; Ne++)
                U[Ne].type === "align" ? (M += lm[U[Ne].align], re && (W += "none "), re = true) : U[Ne].type === "separator" && re && (W += U[Ne].separator === "|" ? "solid " : "dashed ", re = false);
              y.setAttribute("columnalign", M.trim()), /[sd]/.test(W) && y.setAttribute("columnlines", W.trim());
            }
            if (a.colSeparationType === "align") {
              const U = a.cols || [];
              let W = "";
              for (let re = 1; re < U.length; re++)
                W += re % 2 ? "0em " : "1em ";
              y.setAttribute("columnspacing", W.trim());
            } else a.colSeparationType === "alignat" || a.colSeparationType === "gather" ? y.setAttribute("columnspacing", "0em") : a.colSeparationType === "small" ? y.setAttribute("columnspacing", "0.2778em") : a.colSeparationType === "CD" ? y.setAttribute("columnspacing", "0.5em") : y.setAttribute("columnspacing", "1em");
            let B = "";
            const H = a.hLinesBeforeRow;
            E += H[0].length > 0 ? "left " : "", E += H[H.length - 1].length > 0 ? "right " : "";
            for (let U = 1; U < H.length - 1; U++)
              B += H[U].length === 0 ? "none " : H[U][0] ? "dashed " : "solid ";
            return /[sd]/.test(B) && y.setAttribute("rowlines", B.trim()), E !== "" && (y = new oe.MathNode("menclose", [y]), y.setAttribute("notation", E.trim())), a.arraystretch && a.arraystretch < 1 && (y = new oe.MathNode("mstyle", [y]), y.setAttribute("scriptlevel", "1")), y;
          }, pc = function(a, u) {
            a.envName.indexOf("ed") === -1 && Ts(a);
            const c = [], d = a.envName.indexOf("at") > -1 ? "alignat" : "align", m = a.envName === "split", y = Pn(a.parser, {
              cols: c,
              addJot: true,
              autoTag: m ? void 0 : Iu(a.envName),
              emptySingleRow: true,
              colSeparationType: d,
              maxNumCols: m ? 2 : void 0,
              leqno: a.parser.settings.leqno
            }, "display");
            let _, E = 0;
            const M = {
              type: "ordgroup",
              mode: a.mode,
              body: []
            };
            if (u[0] && u[0].type === "ordgroup") {
              let H = "";
              for (let U = 0; U < u[0].body.length; U++) {
                const W = Ae(u[0].body[U], "textord");
                H += W.text;
              }
              _ = Number(H), E = _ * 2;
            }
            const B = !E;
            y.body.forEach(function(H) {
              for (let U = 1; U < H.length; U += 2) {
                const W = Ae(H[U], "styling");
                Ae(W.body[0], "ordgroup").body.unshift(M);
              }
              if (B)
                E < H.length && (E = H.length);
              else {
                const U = H.length / 2;
                if (_ < U)
                  throw new s("Too many math in a row: " + ("expected " + _ + ", but got " + U), H[0]);
              }
            });
            for (let H = 0; H < E; ++H) {
              let U = "r", W = 0;
              H % 2 === 1 ? U = "l" : H > 0 && B && (W = 1), c[H] = {
                type: "align",
                align: U,
                pregap: W,
                postgap: 0
              };
            }
            return y.colSeparationType = B ? "align" : "alignat", y;
          };
          on({
            type: "array",
            names: ["array", "darray"],
            props: {
              numArgs: 1
            },
            handler(a, u) {
              const m = (_s(u[0]) ? [u[0]] : Ae(u[0], "ordgroup").body).map(function(_) {
                const M = wu(_).text;
                if ("lcr".indexOf(M) !== -1)
                  return {
                    type: "align",
                    align: M
                  };
                if (M === "|")
                  return {
                    type: "separator",
                    separator: "|"
                  };
                if (M === ":")
                  return {
                    type: "separator",
                    separator: ":"
                  };
                throw new s("Unknown column alignment: " + M, _);
              }), y = {
                cols: m,
                hskipBeforeAndAfter: true,
                // \@preamble in lttab.dtx
                maxNumCols: m.length
              };
              return Pn(a.parser, y, Fu(a.envName));
            },
            htmlBuilder: an,
            mathmlBuilder: ln
          }), on({
            type: "array",
            names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
            props: {
              numArgs: 0
            },
            handler(a) {
              const u = {
                matrix: null,
                pmatrix: ["(", ")"],
                bmatrix: ["[", "]"],
                Bmatrix: ["\\{", "\\}"],
                vmatrix: ["|", "|"],
                Vmatrix: ["\\Vert", "\\Vert"]
              }[a.envName.replace("*", "")];
              let c = "c";
              const d = {
                hskipBeforeAndAfter: false,
                cols: [{
                  type: "align",
                  align: c
                }]
              };
              if (a.envName.charAt(a.envName.length - 1) === "*") {
                const _ = a.parser;
                if (_.consumeSpaces(), _.fetch().text === "[") {
                  if (_.consume(), _.consumeSpaces(), c = _.fetch().text, "lcr".indexOf(c) === -1)
                    throw new s("Expected l or c or r", _.nextToken);
                  _.consume(), _.consumeSpaces(), _.expect("]"), _.consume(), d.cols = [{
                    type: "align",
                    align: c
                  }];
                }
              }
              const m = Pn(a.parser, d, Fu(a.envName)), y = Math.max(0, ...m.body.map((_) => _.length));
              return m.cols = new Array(y).fill({
                type: "align",
                align: c
              }), u ? {
                type: "leftright",
                mode: a.mode,
                body: [m],
                left: u[0],
                right: u[1],
                rightColor: void 0
                // \right uninfluenced by \color in array
              } : m;
            },
            htmlBuilder: an,
            mathmlBuilder: ln
          }), on({
            type: "array",
            names: ["smallmatrix"],
            props: {
              numArgs: 0
            },
            handler(a) {
              const u = {
                arraystretch: 0.5
              }, c = Pn(a.parser, u, "script");
              return c.colSeparationType = "small", c;
            },
            htmlBuilder: an,
            mathmlBuilder: ln
          }), on({
            type: "array",
            names: ["subarray"],
            props: {
              numArgs: 1
            },
            handler(a, u) {
              const m = (_s(u[0]) ? [u[0]] : Ae(u[0], "ordgroup").body).map(function(_) {
                const M = wu(_).text;
                if ("lc".indexOf(M) !== -1)
                  return {
                    type: "align",
                    align: M
                  };
                throw new s("Unknown column alignment: " + M, _);
              });
              if (m.length > 1)
                throw new s("{subarray} can contain only one column");
              let y = {
                cols: m,
                hskipBeforeAndAfter: false,
                arraystretch: 0.5
              };
              if (y = Pn(a.parser, y, "script"), y.body.length > 0 && y.body[0].length > 1)
                throw new s("{subarray} can contain only one column");
              return y;
            },
            htmlBuilder: an,
            mathmlBuilder: ln
          }), on({
            type: "array",
            names: ["cases", "dcases", "rcases", "drcases"],
            props: {
              numArgs: 0
            },
            handler(a) {
              const u = {
                arraystretch: 1.2,
                cols: [{
                  type: "align",
                  align: "l",
                  pregap: 0,
                  // TODO(kevinb) get the current style.
                  // For now we use the metrics for TEXT style which is what we were
                  // doing before.  Before attempting to get the current style we
                  // should look at TeX's behavior especially for \over and matrices.
                  postgap: 1
                  /* 1em quad */
                }, {
                  type: "align",
                  align: "l",
                  pregap: 0,
                  postgap: 0
                }]
              }, c = Pn(a.parser, u, Fu(a.envName));
              return {
                type: "leftright",
                mode: a.mode,
                body: [c],
                left: a.envName.indexOf("r") > -1 ? "." : "\\{",
                right: a.envName.indexOf("r") > -1 ? "\\}" : ".",
                rightColor: void 0
              };
            },
            htmlBuilder: an,
            mathmlBuilder: ln
          }), on({
            type: "array",
            names: ["align", "align*", "aligned", "split"],
            props: {
              numArgs: 0
            },
            handler: pc,
            htmlBuilder: an,
            mathmlBuilder: ln
          }), on({
            type: "array",
            names: ["gathered", "gather", "gather*"],
            props: {
              numArgs: 0
            },
            handler(a) {
              D.contains(["gather", "gather*"], a.envName) && Ts(a);
              const u = {
                cols: [{
                  type: "align",
                  align: "c"
                }],
                addJot: true,
                colSeparationType: "gather",
                autoTag: Iu(a.envName),
                emptySingleRow: true,
                leqno: a.parser.settings.leqno
              };
              return Pn(a.parser, u, "display");
            },
            htmlBuilder: an,
            mathmlBuilder: ln
          }), on({
            type: "array",
            names: ["alignat", "alignat*", "alignedat"],
            props: {
              numArgs: 1
            },
            handler: pc,
            htmlBuilder: an,
            mathmlBuilder: ln
          }), on({
            type: "array",
            names: ["equation", "equation*"],
            props: {
              numArgs: 0
            },
            handler(a) {
              Ts(a);
              const u = {
                autoTag: Iu(a.envName),
                emptySingleRow: true,
                singleRow: true,
                maxNumCols: 1,
                leqno: a.parser.settings.leqno
              };
              return Pn(a.parser, u, "display");
            },
            htmlBuilder: an,
            mathmlBuilder: ln
          }), on({
            type: "array",
            names: ["CD"],
            props: {
              numArgs: 0
            },
            handler(a) {
              return Ts(a), Y2(a.parser);
            },
            htmlBuilder: an,
            mathmlBuilder: ln
          }), C("\\nonumber", "\\gdef\\@eqnsw{0}"), C("\\notag", "\\nonumber"), de({
            type: "text",
            // Doesn't matter what this is.
            names: ["\\hline", "\\hdashline"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInMath: true
            },
            handler(a, u) {
              throw new s(a.funcName + " valid only within array environment");
            }
          });
          var mc = fc;
          de({
            type: "environment",
            names: ["\\begin", "\\end"],
            props: {
              numArgs: 1,
              argTypes: ["text"]
            },
            handler(a, u) {
              let {
                parser: c,
                funcName: d
              } = a;
              const m = u[0];
              if (m.type !== "ordgroup")
                throw new s("Invalid environment name", m);
              let y = "";
              for (let _ = 0; _ < m.body.length; ++_)
                y += Ae(m.body[_], "textord").text;
              if (d === "\\begin") {
                if (!mc.hasOwnProperty(y))
                  throw new s("No such environment: " + y, m);
                const _ = mc[y], {
                  args: E,
                  optArgs: M
                } = c.parseArguments("\\begin{" + y + "}", _), B = {
                  mode: c.mode,
                  envName: y,
                  parser: c
                }, H = _.handler(B, E, M);
                c.expect("\\end", false);
                const U = c.nextToken, W = Ae(c.parseFunction(), "environment");
                if (W.name !== y)
                  throw new s("Mismatch: \\begin{" + y + "} matched by \\end{" + W.name + "}", U);
                return H;
              }
              return {
                type: "environment",
                mode: c.mode,
                name: y,
                nameGroup: m
              };
            }
          });
          const gc = (a, u) => {
            const c = a.font, d = u.withFont(c);
            return Fe(a.body, d);
          }, bc = (a, u) => {
            const c = a.font, d = u.withFont(c);
            return je(a.body, d);
          }, yc = {
            "\\Bbb": "\\mathbb",
            "\\bold": "\\mathbf",
            "\\frak": "\\mathfrak",
            "\\bm": "\\boldsymbol"
          };
          de({
            type: "font",
            names: [
              // styles, except \boldsymbol defined below
              "\\mathrm",
              "\\mathit",
              "\\mathbf",
              "\\mathnormal",
              "\\mathsfit",
              // families
              "\\mathbb",
              "\\mathcal",
              "\\mathfrak",
              "\\mathscr",
              "\\mathsf",
              "\\mathtt",
              // aliases, except \bm defined below
              "\\Bbb",
              "\\bold",
              "\\frak"
            ],
            props: {
              numArgs: 1,
              allowedInArgument: true
            },
            handler: (a, u) => {
              let {
                parser: c,
                funcName: d
              } = a;
              const m = vs(u[0]);
              let y = d;
              return y in yc && (y = yc[y]), {
                type: "font",
                mode: c.mode,
                font: y.slice(1),
                body: m
              };
            },
            htmlBuilder: gc,
            mathmlBuilder: bc
          }), de({
            type: "mclass",
            names: ["\\boldsymbol", "\\bm"],
            props: {
              numArgs: 1
            },
            handler: (a, u) => {
              let {
                parser: c
              } = a;
              const d = u[0], m = D.isCharacterBox(d);
              return {
                type: "mclass",
                mode: c.mode,
                mclass: As(d),
                body: [{
                  type: "font",
                  mode: c.mode,
                  font: "boldsymbol",
                  body: d
                }],
                isCharacterBox: m
              };
            }
          }), de({
            type: "font",
            names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler: (a, u) => {
              let {
                parser: c,
                funcName: d,
                breakOnTokenText: m
              } = a;
              const {
                mode: y
              } = c, _ = c.parseExpression(true, m), E = "math" + d.slice(1);
              return {
                type: "font",
                mode: y,
                font: E,
                body: {
                  type: "ordgroup",
                  mode: c.mode,
                  body: _
                }
              };
            },
            htmlBuilder: gc,
            mathmlBuilder: bc
          });
          const xc = (a, u) => {
            let c = u;
            return a === "display" ? c = c.id >= ne.SCRIPT.id ? c.text() : ne.DISPLAY : a === "text" && c.size === ne.DISPLAY.size ? c = ne.TEXT : a === "script" ? c = ne.SCRIPT : a === "scriptscript" && (c = ne.SCRIPTSCRIPT), c;
          }, Bu = (a, u) => {
            const c = xc(a.size, u.style), d = c.fracNum(), m = c.fracDen();
            let y;
            y = u.havingStyle(d);
            const _ = Fe(a.numer, y, u);
            if (a.continued) {
              const Ie = 8.5 / u.fontMetrics().ptPerEm, ze = 3.5 / u.fontMetrics().ptPerEm;
              _.height = _.height < Ie ? Ie : _.height, _.depth = _.depth < ze ? ze : _.depth;
            }
            y = u.havingStyle(m);
            const E = Fe(a.denom, y, u);
            let M, B, H;
            a.hasBarLine ? (a.barSize ? (B = Qe(a.barSize, u), M = G.makeLineSpan("frac-line", u, B)) : M = G.makeLineSpan("frac-line", u), B = M.height, H = M.height) : (M = null, B = 0, H = u.fontMetrics().defaultRuleThickness);
            let U, W, re;
            c.size === ne.DISPLAY.size || a.size === "display" ? (U = u.fontMetrics().num1, B > 0 ? W = 3 * H : W = 7 * H, re = u.fontMetrics().denom1) : (B > 0 ? (U = u.fontMetrics().num2, W = H) : (U = u.fontMetrics().num3, W = 3 * H), re = u.fontMetrics().denom2);
            let me;
            if (M) {
              const Ie = u.fontMetrics().axisHeight;
              U - _.depth - (Ie + 0.5 * B) < W && (U += W - (U - _.depth - (Ie + 0.5 * B))), Ie - 0.5 * B - (E.height - re) < W && (re += W - (Ie - 0.5 * B - (E.height - re)));
              const ze = -(Ie - 0.5 * B);
              me = G.makeVList({
                positionType: "individualShift",
                children: [{
                  type: "elem",
                  elem: E,
                  shift: re
                }, {
                  type: "elem",
                  elem: M,
                  shift: ze
                }, {
                  type: "elem",
                  elem: _,
                  shift: -U
                }]
              }, u);
            } else {
              const Ie = U - _.depth - (E.height - re);
              Ie < W && (U += 0.5 * (W - Ie), re += 0.5 * (W - Ie)), me = G.makeVList({
                positionType: "individualShift",
                children: [{
                  type: "elem",
                  elem: E,
                  shift: re
                }, {
                  type: "elem",
                  elem: _,
                  shift: -U
                }]
              }, u);
            }
            y = u.havingStyle(c), me.height *= y.sizeMultiplier / u.sizeMultiplier, me.depth *= y.sizeMultiplier / u.sizeMultiplier;
            let be;
            c.size === ne.DISPLAY.size ? be = u.fontMetrics().delim1 : c.size === ne.SCRIPTSCRIPT.size ? be = u.havingStyle(ne.SCRIPT).fontMetrics().delim2 : be = u.fontMetrics().delim2;
            let Ne, Ee;
            return a.leftDelim == null ? Ne = di(u, ["mopen"]) : Ne = Cn.customSizedDelim(a.leftDelim, be, true, u.havingStyle(c), a.mode, ["mopen"]), a.continued ? Ee = G.makeSpan([]) : a.rightDelim == null ? Ee = di(u, ["mclose"]) : Ee = Cn.customSizedDelim(a.rightDelim, be, true, u.havingStyle(c), a.mode, ["mclose"]), G.makeSpan(["mord"].concat(y.sizingClasses(u)), [Ne, G.makeSpan(["mfrac"], [me]), Ee], u);
          }, Ou = (a, u) => {
            let c = new oe.MathNode("mfrac", [je(a.numer, u), je(a.denom, u)]);
            if (!a.hasBarLine)
              c.setAttribute("linethickness", "0px");
            else if (a.barSize) {
              const m = Qe(a.barSize, u);
              c.setAttribute("linethickness", ce(m));
            }
            const d = xc(a.size, u.style);
            if (d.size !== u.style.size) {
              c = new oe.MathNode("mstyle", [c]);
              const m = d.size === ne.DISPLAY.size ? "true" : "false";
              c.setAttribute("displaystyle", m), c.setAttribute("scriptlevel", "0");
            }
            if (a.leftDelim != null || a.rightDelim != null) {
              const m = [];
              if (a.leftDelim != null) {
                const y = new oe.MathNode("mo", [new oe.TextNode(a.leftDelim.replace("\\", ""))]);
                y.setAttribute("fence", "true"), m.push(y);
              }
              if (m.push(c), a.rightDelim != null) {
                const y = new oe.MathNode("mo", [new oe.TextNode(a.rightDelim.replace("\\", ""))]);
                y.setAttribute("fence", "true"), m.push(y);
              }
              return bu(m);
            }
            return c;
          };
          de({
            type: "genfrac",
            names: [
              "\\dfrac",
              "\\frac",
              "\\tfrac",
              "\\dbinom",
              "\\binom",
              "\\tbinom",
              "\\\\atopfrac",
              // canâ€™t be entered directly
              "\\\\bracefrac",
              "\\\\brackfrac"
              // ditto
            ],
            props: {
              numArgs: 2,
              allowedInArgument: true
            },
            handler: (a, u) => {
              let {
                parser: c,
                funcName: d
              } = a;
              const m = u[0], y = u[1];
              let _, E = null, M = null, B = "auto";
              switch (d) {
                case "\\dfrac":
                case "\\frac":
                case "\\tfrac":
                  _ = true;
                  break;
                case "\\\\atopfrac":
                  _ = false;
                  break;
                case "\\dbinom":
                case "\\binom":
                case "\\tbinom":
                  _ = false, E = "(", M = ")";
                  break;
                case "\\\\bracefrac":
                  _ = false, E = "\\{", M = "\\}";
                  break;
                case "\\\\brackfrac":
                  _ = false, E = "[", M = "]";
                  break;
                default:
                  throw new Error("Unrecognized genfrac command");
              }
              switch (d) {
                case "\\dfrac":
                case "\\dbinom":
                  B = "display";
                  break;
                case "\\tfrac":
                case "\\tbinom":
                  B = "text";
                  break;
              }
              return {
                type: "genfrac",
                mode: c.mode,
                continued: false,
                numer: m,
                denom: y,
                hasBarLine: _,
                leftDelim: E,
                rightDelim: M,
                size: B,
                barSize: null
              };
            },
            htmlBuilder: Bu,
            mathmlBuilder: Ou
          }), de({
            type: "genfrac",
            names: ["\\cfrac"],
            props: {
              numArgs: 2
            },
            handler: (a, u) => {
              let {
                parser: c,
                funcName: d
              } = a;
              const m = u[0], y = u[1];
              return {
                type: "genfrac",
                mode: c.mode,
                continued: true,
                numer: m,
                denom: y,
                hasBarLine: true,
                leftDelim: null,
                rightDelim: null,
                size: "display",
                barSize: null
              };
            }
          }), de({
            type: "infix",
            names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
            props: {
              numArgs: 0,
              infix: true
            },
            handler(a) {
              let {
                parser: u,
                funcName: c,
                token: d
              } = a, m;
              switch (c) {
                case "\\over":
                  m = "\\frac";
                  break;
                case "\\choose":
                  m = "\\binom";
                  break;
                case "\\atop":
                  m = "\\\\atopfrac";
                  break;
                case "\\brace":
                  m = "\\\\bracefrac";
                  break;
                case "\\brack":
                  m = "\\\\brackfrac";
                  break;
                default:
                  throw new Error("Unrecognized infix genfrac command");
              }
              return {
                type: "infix",
                mode: u.mode,
                replaceWith: m,
                token: d
              };
            }
          });
          const wc = ["display", "text", "script", "scriptscript"], vc = function(a) {
            let u = null;
            return a.length > 0 && (u = a, u = u === "." ? null : u), u;
          };
          de({
            type: "genfrac",
            names: ["\\genfrac"],
            props: {
              numArgs: 6,
              allowedInArgument: true,
              argTypes: ["math", "math", "size", "text", "math", "math"]
            },
            handler(a, u) {
              let {
                parser: c
              } = a;
              const d = u[4], m = u[5], y = vs(u[0]), _ = y.type === "atom" && y.family === "open" ? vc(y.text) : null, E = vs(u[1]), M = E.type === "atom" && E.family === "close" ? vc(E.text) : null, B = Ae(u[2], "size");
              let H, U = null;
              B.isBlank ? H = true : (U = B.value, H = U.number > 0);
              let W = "auto", re = u[3];
              if (re.type === "ordgroup") {
                if (re.body.length > 0) {
                  const me = Ae(re.body[0], "textord");
                  W = wc[Number(me.text)];
                }
              } else
                re = Ae(re, "textord"), W = wc[Number(re.text)];
              return {
                type: "genfrac",
                mode: c.mode,
                numer: d,
                denom: m,
                continued: false,
                hasBarLine: H,
                barSize: U,
                leftDelim: _,
                rightDelim: M,
                size: W
              };
            },
            htmlBuilder: Bu,
            mathmlBuilder: Ou
          }), de({
            type: "infix",
            names: ["\\above"],
            props: {
              numArgs: 1,
              argTypes: ["size"],
              infix: true
            },
            handler(a, u) {
              let {
                parser: c,
                funcName: d,
                token: m
              } = a;
              return {
                type: "infix",
                mode: c.mode,
                replaceWith: "\\\\abovefrac",
                size: Ae(u[0], "size").value,
                token: m
              };
            }
          }), de({
            type: "genfrac",
            names: ["\\\\abovefrac"],
            props: {
              numArgs: 3,
              argTypes: ["math", "size", "math"]
            },
            handler: (a, u) => {
              let {
                parser: c,
                funcName: d
              } = a;
              const m = u[0], y = A(Ae(u[1], "infix").size), _ = u[2], E = y.number > 0;
              return {
                type: "genfrac",
                mode: c.mode,
                numer: m,
                denom: _,
                continued: false,
                hasBarLine: E,
                barSize: y,
                leftDelim: null,
                rightDelim: null,
                size: "auto"
              };
            },
            htmlBuilder: Bu,
            mathmlBuilder: Ou
          });
          const kc = (a, u) => {
            const c = u.style;
            let d, m;
            a.type === "supsub" ? (d = a.sup ? Fe(a.sup, u.havingStyle(c.sup()), u) : Fe(a.sub, u.havingStyle(c.sub()), u), m = Ae(a.base, "horizBrace")) : m = Ae(a, "horizBrace");
            const y = Fe(m.base, u.havingBaseStyle(ne.DISPLAY)), _ = En.svgSpan(m, u);
            let E;
            if (m.isOver ? (E = G.makeVList({
              positionType: "firstBaseline",
              children: [{
                type: "elem",
                elem: y
              }, {
                type: "kern",
                size: 0.1
              }, {
                type: "elem",
                elem: _
              }]
            }, u), E.children[0].children[0].children[1].classes.push("svg-align")) : (E = G.makeVList({
              positionType: "bottom",
              positionData: y.depth + 0.1 + _.height,
              children: [{
                type: "elem",
                elem: _
              }, {
                type: "kern",
                size: 0.1
              }, {
                type: "elem",
                elem: y
              }]
            }, u), E.children[0].children[0].children[0].classes.push("svg-align")), d) {
              const M = G.makeSpan(["mord", m.isOver ? "mover" : "munder"], [E], u);
              m.isOver ? E = G.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: M
                }, {
                  type: "kern",
                  size: 0.2
                }, {
                  type: "elem",
                  elem: d
                }]
              }, u) : E = G.makeVList({
                positionType: "bottom",
                positionData: M.depth + 0.2 + d.height + d.depth,
                children: [{
                  type: "elem",
                  elem: d
                }, {
                  type: "kern",
                  size: 0.2
                }, {
                  type: "elem",
                  elem: M
                }]
              }, u);
            }
            return G.makeSpan(["mord", m.isOver ? "mover" : "munder"], [E], u);
          };
          de({
            type: "horizBrace",
            names: ["\\overbrace", "\\underbrace"],
            props: {
              numArgs: 1
            },
            handler(a, u) {
              let {
                parser: c,
                funcName: d
              } = a;
              return {
                type: "horizBrace",
                mode: c.mode,
                label: d,
                isOver: /^\\over/.test(d),
                base: u[0]
              };
            },
            htmlBuilder: kc,
            mathmlBuilder: (a, u) => {
              const c = En.mathMLnode(a.label);
              return new oe.MathNode(a.isOver ? "mover" : "munder", [je(a.base, u), c]);
            }
          }), de({
            type: "href",
            names: ["\\href"],
            props: {
              numArgs: 2,
              argTypes: ["url", "original"],
              allowedInText: true
            },
            handler: (a, u) => {
              let {
                parser: c
              } = a;
              const d = u[1], m = Ae(u[0], "url").url;
              return c.settings.isTrusted({
                command: "\\href",
                url: m
              }) ? {
                type: "href",
                mode: c.mode,
                href: m,
                body: st(d)
              } : c.formatUnsupportedCmd("\\href");
            },
            htmlBuilder: (a, u) => {
              const c = ct(a.body, u, false);
              return G.makeAnchor(a.href, [], c, u);
            },
            mathmlBuilder: (a, u) => {
              let c = Rn(a.body, u);
              return c instanceof Bt || (c = new Bt("mrow", [c])), c.setAttribute("href", a.href), c;
            }
          }), de({
            type: "href",
            names: ["\\url"],
            props: {
              numArgs: 1,
              argTypes: ["url"],
              allowedInText: true
            },
            handler: (a, u) => {
              let {
                parser: c
              } = a;
              const d = Ae(u[0], "url").url;
              if (!c.settings.isTrusted({
                command: "\\url",
                url: d
              }))
                return c.formatUnsupportedCmd("\\url");
              const m = [];
              for (let _ = 0; _ < d.length; _++) {
                let E = d[_];
                E === "~" && (E = "\\textasciitilde"), m.push({
                  type: "textord",
                  mode: "text",
                  text: E
                });
              }
              const y = {
                type: "text",
                mode: c.mode,
                font: "\\texttt",
                body: m
              };
              return {
                type: "href",
                mode: c.mode,
                href: d,
                body: st(y)
              };
            }
          }), de({
            type: "hbox",
            names: ["\\hbox"],
            props: {
              numArgs: 1,
              argTypes: ["text"],
              allowedInText: true,
              primitive: true
            },
            handler(a, u) {
              let {
                parser: c
              } = a;
              return {
                type: "hbox",
                mode: c.mode,
                body: st(u[0])
              };
            },
            htmlBuilder(a, u) {
              const c = ct(a.body, u, false);
              return G.makeFragment(c);
            },
            mathmlBuilder(a, u) {
              return new oe.MathNode("mrow", Ct(a.body, u));
            }
          }), de({
            type: "html",
            names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
            props: {
              numArgs: 2,
              argTypes: ["raw", "original"],
              allowedInText: true
            },
            handler: (a, u) => {
              let {
                parser: c,
                funcName: d,
                token: m
              } = a;
              const y = Ae(u[0], "raw").string, _ = u[1];
              c.settings.strict && c.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
              let E;
              const M = {};
              switch (d) {
                case "\\htmlClass":
                  M.class = y, E = {
                    command: "\\htmlClass",
                    class: y
                  };
                  break;
                case "\\htmlId":
                  M.id = y, E = {
                    command: "\\htmlId",
                    id: y
                  };
                  break;
                case "\\htmlStyle":
                  M.style = y, E = {
                    command: "\\htmlStyle",
                    style: y
                  };
                  break;
                case "\\htmlData": {
                  const B = y.split(",");
                  for (let H = 0; H < B.length; H++) {
                    const U = B[H].split("=");
                    if (U.length !== 2)
                      throw new s("Error parsing key-value for \\htmlData");
                    M["data-" + U[0].trim()] = U[1].trim();
                  }
                  E = {
                    command: "\\htmlData",
                    attributes: M
                  };
                  break;
                }
                default:
                  throw new Error("Unrecognized html command");
              }
              return c.settings.isTrusted(E) ? {
                type: "html",
                mode: c.mode,
                attributes: M,
                body: st(_)
              } : c.formatUnsupportedCmd(d);
            },
            htmlBuilder: (a, u) => {
              const c = ct(a.body, u, false), d = ["enclosing"];
              a.attributes.class && d.push(...a.attributes.class.trim().split(/\s+/));
              const m = G.makeSpan(d, c, u);
              for (const y in a.attributes)
                y !== "class" && a.attributes.hasOwnProperty(y) && m.setAttribute(y, a.attributes[y]);
              return m;
            },
            mathmlBuilder: (a, u) => Rn(a.body, u)
          }), de({
            type: "htmlmathml",
            names: ["\\html@mathml"],
            props: {
              numArgs: 2,
              allowedInText: true
            },
            handler: (a, u) => {
              let {
                parser: c
              } = a;
              return {
                type: "htmlmathml",
                mode: c.mode,
                html: st(u[0]),
                mathml: st(u[1])
              };
            },
            htmlBuilder: (a, u) => {
              const c = ct(a.html, u, false);
              return G.makeFragment(c);
            },
            mathmlBuilder: (a, u) => Rn(a.mathml, u)
          });
          const zu = function(a) {
            if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(a))
              return {
                number: +a,
                unit: "bp"
              };
            {
              const u = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(a);
              if (!u)
                throw new s("Invalid size: '" + a + "' in \\includegraphics");
              const c = {
                number: +(u[1] + u[2]),
                // sign + magnitude, cast to number
                unit: u[3]
              };
              if (!Cl(c))
                throw new s("Invalid unit: '" + c.unit + "' in \\includegraphics.");
              return c;
            }
          };
          de({
            type: "includegraphics",
            names: ["\\includegraphics"],
            props: {
              numArgs: 1,
              numOptionalArgs: 1,
              argTypes: ["raw", "url"],
              allowedInText: false
            },
            handler: (a, u, c) => {
              let {
                parser: d
              } = a, m = {
                number: 0,
                unit: "em"
              }, y = {
                number: 0.9,
                unit: "em"
              }, _ = {
                number: 0,
                unit: "em"
              }, E = "";
              if (c[0]) {
                const H = Ae(c[0], "raw").string.split(",");
                for (let U = 0; U < H.length; U++) {
                  const W = H[U].split("=");
                  if (W.length === 2) {
                    const re = W[1].trim();
                    switch (W[0].trim()) {
                      case "alt":
                        E = re;
                        break;
                      case "width":
                        m = zu(re);
                        break;
                      case "height":
                        y = zu(re);
                        break;
                      case "totalheight":
                        _ = zu(re);
                        break;
                      default:
                        throw new s("Invalid key: '" + W[0] + "' in \\includegraphics.");
                    }
                  }
                }
              }
              const M = Ae(u[0], "url").url;
              return E === "" && (E = M, E = E.replace(/^.*[\\/]/, ""), E = E.substring(0, E.lastIndexOf("."))), d.settings.isTrusted({
                command: "\\includegraphics",
                url: M
              }) ? {
                type: "includegraphics",
                mode: d.mode,
                alt: E,
                width: m,
                height: y,
                totalheight: _,
                src: M
              } : d.formatUnsupportedCmd("\\includegraphics");
            },
            htmlBuilder: (a, u) => {
              const c = Qe(a.height, u);
              let d = 0;
              a.totalheight.number > 0 && (d = Qe(a.totalheight, u) - c);
              let m = 0;
              a.width.number > 0 && (m = Qe(a.width, u));
              const y = {
                height: ce(c + d)
              };
              m > 0 && (y.width = ce(m)), d > 0 && (y.verticalAlign = ce(-d));
              const _ = new m2(a.src, a.alt, y);
              return _.height = c, _.depth = d, _;
            },
            mathmlBuilder: (a, u) => {
              const c = new oe.MathNode("mglyph", []);
              c.setAttribute("alt", a.alt);
              const d = Qe(a.height, u);
              let m = 0;
              if (a.totalheight.number > 0 && (m = Qe(a.totalheight, u) - d, c.setAttribute("valign", ce(-m))), c.setAttribute("height", ce(d + m)), a.width.number > 0) {
                const y = Qe(a.width, u);
                c.setAttribute("width", ce(y));
              }
              return c.setAttribute("src", a.src), c;
            }
          }), de({
            type: "kern",
            names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
            props: {
              numArgs: 1,
              argTypes: ["size"],
              primitive: true,
              allowedInText: true
            },
            handler(a, u) {
              let {
                parser: c,
                funcName: d
              } = a;
              const m = Ae(u[0], "size");
              if (c.settings.strict) {
                const y = d[1] === "m", _ = m.value.unit === "mu";
                y ? (_ || c.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + d + " supports only mu units, " + ("not " + m.value.unit + " units")), c.mode !== "math" && c.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + d + " works only in math mode")) : _ && c.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + d + " doesn't support mu units");
              }
              return {
                type: "kern",
                mode: c.mode,
                dimension: m.value
              };
            },
            htmlBuilder(a, u) {
              return G.makeGlue(a.dimension, u);
            },
            mathmlBuilder(a, u) {
              const c = Qe(a.dimension, u);
              return new oe.SpaceNode(c);
            }
          }), de({
            type: "lap",
            names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: (a, u) => {
              let {
                parser: c,
                funcName: d
              } = a;
              const m = u[0];
              return {
                type: "lap",
                mode: c.mode,
                alignment: d.slice(5),
                body: m
              };
            },
            htmlBuilder: (a, u) => {
              let c;
              a.alignment === "clap" ? (c = G.makeSpan([], [Fe(a.body, u)]), c = G.makeSpan(["inner"], [c], u)) : c = G.makeSpan(["inner"], [Fe(a.body, u)]);
              const d = G.makeSpan(["fix"], []);
              let m = G.makeSpan([a.alignment], [c, d], u);
              const y = G.makeSpan(["strut"]);
              return y.style.height = ce(m.height + m.depth), m.depth && (y.style.verticalAlign = ce(-m.depth)), m.children.unshift(y), m = G.makeSpan(["thinbox"], [m], u), G.makeSpan(["mord", "vbox"], [m], u);
            },
            mathmlBuilder: (a, u) => {
              const c = new oe.MathNode("mpadded", [je(a.body, u)]);
              if (a.alignment !== "rlap") {
                const d = a.alignment === "llap" ? "-1" : "-0.5";
                c.setAttribute("lspace", d + "width");
              }
              return c.setAttribute("width", "0px"), c;
            }
          }), de({
            type: "styling",
            names: ["\\(", "$"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInMath: false
            },
            handler(a, u) {
              let {
                funcName: c,
                parser: d
              } = a;
              const m = d.mode;
              d.switchMode("math");
              const y = c === "\\(" ? "\\)" : "$", _ = d.parseExpression(false, y);
              return d.expect(y), d.switchMode(m), {
                type: "styling",
                mode: d.mode,
                style: "text",
                body: _
              };
            }
          }), de({
            type: "text",
            // Doesn't matter what this is.
            names: ["\\)", "\\]"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInMath: false
            },
            handler(a, u) {
              throw new s("Mismatched " + a.funcName);
            }
          });
          const _c = (a, u) => {
            switch (u.style.size) {
              case ne.DISPLAY.size:
                return a.display;
              case ne.TEXT.size:
                return a.text;
              case ne.SCRIPT.size:
                return a.script;
              case ne.SCRIPTSCRIPT.size:
                return a.scriptscript;
              default:
                return a.text;
            }
          };
          de({
            type: "mathchoice",
            names: ["\\mathchoice"],
            props: {
              numArgs: 4,
              primitive: true
            },
            handler: (a, u) => {
              let {
                parser: c
              } = a;
              return {
                type: "mathchoice",
                mode: c.mode,
                display: st(u[0]),
                text: st(u[1]),
                script: st(u[2]),
                scriptscript: st(u[3])
              };
            },
            htmlBuilder: (a, u) => {
              const c = _c(a, u), d = ct(c, u, false);
              return G.makeFragment(d);
            },
            mathmlBuilder: (a, u) => {
              const c = _c(a, u);
              return Rn(c, u);
            }
          });
          const Sc = (a, u, c, d, m, y, _) => {
            a = G.makeSpan([], [a]);
            const E = c && D.isCharacterBox(c);
            let M, B;
            if (u) {
              const W = Fe(u, d.havingStyle(m.sup()), d);
              B = {
                elem: W,
                kern: Math.max(d.fontMetrics().bigOpSpacing1, d.fontMetrics().bigOpSpacing3 - W.depth)
              };
            }
            if (c) {
              const W = Fe(c, d.havingStyle(m.sub()), d);
              M = {
                elem: W,
                kern: Math.max(d.fontMetrics().bigOpSpacing2, d.fontMetrics().bigOpSpacing4 - W.height)
              };
            }
            let H;
            if (B && M) {
              const W = d.fontMetrics().bigOpSpacing5 + M.elem.height + M.elem.depth + M.kern + a.depth + _;
              H = G.makeVList({
                positionType: "bottom",
                positionData: W,
                children: [{
                  type: "kern",
                  size: d.fontMetrics().bigOpSpacing5
                }, {
                  type: "elem",
                  elem: M.elem,
                  marginLeft: ce(-y)
                }, {
                  type: "kern",
                  size: M.kern
                }, {
                  type: "elem",
                  elem: a
                }, {
                  type: "kern",
                  size: B.kern
                }, {
                  type: "elem",
                  elem: B.elem,
                  marginLeft: ce(y)
                }, {
                  type: "kern",
                  size: d.fontMetrics().bigOpSpacing5
                }]
              }, d);
            } else if (M) {
              const W = a.height - _;
              H = G.makeVList({
                positionType: "top",
                positionData: W,
                children: [{
                  type: "kern",
                  size: d.fontMetrics().bigOpSpacing5
                }, {
                  type: "elem",
                  elem: M.elem,
                  marginLeft: ce(-y)
                }, {
                  type: "kern",
                  size: M.kern
                }, {
                  type: "elem",
                  elem: a
                }]
              }, d);
            } else if (B) {
              const W = a.depth + _;
              H = G.makeVList({
                positionType: "bottom",
                positionData: W,
                children: [{
                  type: "elem",
                  elem: a
                }, {
                  type: "kern",
                  size: B.kern
                }, {
                  type: "elem",
                  elem: B.elem,
                  marginLeft: ce(y)
                }, {
                  type: "kern",
                  size: d.fontMetrics().bigOpSpacing5
                }]
              }, d);
            } else
              return a;
            const U = [H];
            if (M && y !== 0 && !E) {
              const W = G.makeSpan(["mspace"], [], d);
              W.style.marginRight = ce(y), U.unshift(W);
            }
            return G.makeSpan(["mop", "op-limits"], U, d);
          }, Ac = ["\\smallint"], Cr = (a, u) => {
            let c, d, m = false, y;
            a.type === "supsub" ? (c = a.sup, d = a.sub, y = Ae(a.base, "op"), m = true) : y = Ae(a, "op");
            const _ = u.style;
            let E = false;
            _.size === ne.DISPLAY.size && y.symbol && !D.contains(Ac, y.name) && (E = true);
            let M;
            if (y.symbol) {
              const U = E ? "Size2-Regular" : "Size1-Regular";
              let W = "";
              if ((y.name === "\\oiint" || y.name === "\\oiiint") && (W = y.name.slice(1), y.name = W === "oiint" ? "\\iint" : "\\iiint"), M = G.makeSymbol(y.name, U, "math", u, ["mop", "op-symbol", E ? "large-op" : "small-op"]), W.length > 0) {
                const re = M.italic, me = G.staticSvg(W + "Size" + (E ? "2" : "1"), u);
                M = G.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: M,
                    shift: 0
                  }, {
                    type: "elem",
                    elem: me,
                    shift: E ? 0.08 : 0
                  }]
                }, u), y.name = "\\" + W, M.classes.unshift("mop"), M.italic = re;
              }
            } else if (y.body) {
              const U = ct(y.body, u, true);
              U.length === 1 && U[0] instanceof Rt ? (M = U[0], M.classes[0] = "mop") : M = G.makeSpan(["mop"], U, u);
            } else {
              const U = [];
              for (let W = 1; W < y.name.length; W++)
                U.push(G.mathsym(y.name[W], y.mode, u));
              M = G.makeSpan(["mop"], U, u);
            }
            let B = 0, H = 0;
            return (M instanceof Rt || y.name === "\\oiint" || y.name === "\\oiiint") && !y.suppressBaseShift && (B = (M.height - M.depth) / 2 - u.fontMetrics().axisHeight, H = M.italic), m ? Sc(M, c, d, u, _, H, B) : (B && (M.style.position = "relative", M.style.top = ce(B)), M);
          }, gi = (a, u) => {
            let c;
            if (a.symbol)
              c = new Bt("mo", [Pt(a.name, a.mode)]), D.contains(Ac, a.name) && c.setAttribute("largeop", "false");
            else if (a.body)
              c = new Bt("mo", Ct(a.body, u));
            else {
              c = new Bt("mi", [new un(a.name.slice(1))]);
              const d = new Bt("mo", [Pt("â¡", "text")]);
              a.parentIsSupSub ? c = new Bt("mrow", [c, d]) : c = Hl([c, d]);
            }
            return c;
          }, cm = {
            "âˆ": "\\prod",
            "âˆ": "\\coprod",
            "âˆ‘": "\\sum",
            "â‹€": "\\bigwedge",
            "â‹": "\\bigvee",
            "â‹‚": "\\bigcap",
            "â‹ƒ": "\\bigcup",
            "â¨€": "\\bigodot",
            "â¨": "\\bigoplus",
            "â¨‚": "\\bigotimes",
            "â¨„": "\\biguplus",
            "â¨†": "\\bigsqcup"
          };
          de({
            type: "op",
            names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "âˆ", "âˆ", "âˆ‘", "â‹€", "â‹", "â‹‚", "â‹ƒ", "â¨€", "â¨", "â¨‚", "â¨„", "â¨†"],
            props: {
              numArgs: 0
            },
            handler: (a, u) => {
              let {
                parser: c,
                funcName: d
              } = a, m = d;
              return m.length === 1 && (m = cm[m]), {
                type: "op",
                mode: c.mode,
                limits: true,
                parentIsSupSub: false,
                symbol: true,
                name: m
              };
            },
            htmlBuilder: Cr,
            mathmlBuilder: gi
          }), de({
            type: "op",
            names: ["\\mathop"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler: (a, u) => {
              let {
                parser: c
              } = a;
              const d = u[0];
              return {
                type: "op",
                mode: c.mode,
                limits: false,
                parentIsSupSub: false,
                symbol: false,
                body: st(d)
              };
            },
            htmlBuilder: Cr,
            mathmlBuilder: gi
          });
          const fm = {
            "âˆ«": "\\int",
            "âˆ¬": "\\iint",
            "âˆ­": "\\iiint",
            "âˆ®": "\\oint",
            "âˆ¯": "\\oiint",
            "âˆ°": "\\oiiint"
          };
          de({
            type: "op",
            names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
            props: {
              numArgs: 0
            },
            handler(a) {
              let {
                parser: u,
                funcName: c
              } = a;
              return {
                type: "op",
                mode: u.mode,
                limits: false,
                parentIsSupSub: false,
                symbol: false,
                name: c
              };
            },
            htmlBuilder: Cr,
            mathmlBuilder: gi
          }), de({
            type: "op",
            names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
            props: {
              numArgs: 0
            },
            handler(a) {
              let {
                parser: u,
                funcName: c
              } = a;
              return {
                type: "op",
                mode: u.mode,
                limits: true,
                parentIsSupSub: false,
                symbol: false,
                name: c
              };
            },
            htmlBuilder: Cr,
            mathmlBuilder: gi
          }), de({
            type: "op",
            names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "âˆ«", "âˆ¬", "âˆ­", "âˆ®", "âˆ¯", "âˆ°"],
            props: {
              numArgs: 0
            },
            handler(a) {
              let {
                parser: u,
                funcName: c
              } = a, d = c;
              return d.length === 1 && (d = fm[d]), {
                type: "op",
                mode: u.mode,
                limits: false,
                parentIsSupSub: false,
                symbol: true,
                name: d
              };
            },
            htmlBuilder: Cr,
            mathmlBuilder: gi
          });
          const Ec = (a, u) => {
            let c, d, m = false, y;
            a.type === "supsub" ? (c = a.sup, d = a.sub, y = Ae(a.base, "operatorname"), m = true) : y = Ae(a, "operatorname");
            let _;
            if (y.body.length > 0) {
              const E = y.body.map((B) => {
                const H = B.text;
                return typeof H == "string" ? {
                  type: "textord",
                  mode: B.mode,
                  text: H
                } : B;
              }), M = ct(E, u.withFont("mathrm"), true);
              for (let B = 0; B < M.length; B++) {
                const H = M[B];
                H instanceof Rt && (H.text = H.text.replace(/\u2212/, "-").replace(/\u2217/, "*"));
              }
              _ = G.makeSpan(["mop"], M, u);
            } else
              _ = G.makeSpan(["mop"], [], u);
            return m ? Sc(_, c, d, u, u.style, 0, 0) : _;
          };
          de({
            type: "operatorname",
            names: ["\\operatorname@", "\\operatornamewithlimits"],
            props: {
              numArgs: 1
            },
            handler: (a, u) => {
              let {
                parser: c,
                funcName: d
              } = a;
              const m = u[0];
              return {
                type: "operatorname",
                mode: c.mode,
                body: st(m),
                alwaysHandleSupSub: d === "\\operatornamewithlimits",
                limits: false,
                parentIsSupSub: false
              };
            },
            htmlBuilder: Ec,
            mathmlBuilder: (a, u) => {
              let c = Ct(a.body, u.withFont("mathrm")), d = true;
              for (let _ = 0; _ < c.length; _++) {
                const E = c[_];
                if (!(E instanceof oe.SpaceNode)) if (E instanceof oe.MathNode)
                  switch (E.type) {
                    case "mi":
                    case "mn":
                    case "ms":
                    case "mspace":
                    case "mtext":
                      break;
                    case "mo": {
                      const M = E.children[0];
                      E.children.length === 1 && M instanceof oe.TextNode ? M.text = M.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : d = false;
                      break;
                    }
                    default:
                      d = false;
                  }
                else
                  d = false;
              }
              if (d) {
                const _ = c.map((E) => E.toText()).join("");
                c = [new oe.TextNode(_)];
              }
              const m = new oe.MathNode("mi", c);
              m.setAttribute("mathvariant", "normal");
              const y = new oe.MathNode("mo", [Pt("â¡", "text")]);
              return a.parentIsSupSub ? new oe.MathNode("mrow", [m, y]) : oe.newDocumentFragment([m, y]);
            }
          }), C("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@"), ir({
            type: "ordgroup",
            htmlBuilder(a, u) {
              return a.semisimple ? G.makeFragment(ct(a.body, u, false)) : G.makeSpan(["mord"], ct(a.body, u, true), u);
            },
            mathmlBuilder(a, u) {
              return Rn(a.body, u, true);
            }
          }), de({
            type: "overline",
            names: ["\\overline"],
            props: {
              numArgs: 1
            },
            handler(a, u) {
              let {
                parser: c
              } = a;
              const d = u[0];
              return {
                type: "overline",
                mode: c.mode,
                body: d
              };
            },
            htmlBuilder(a, u) {
              const c = Fe(a.body, u.havingCrampedStyle()), d = G.makeLineSpan("overline-line", u), m = u.fontMetrics().defaultRuleThickness, y = G.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: c
                }, {
                  type: "kern",
                  size: 3 * m
                }, {
                  type: "elem",
                  elem: d
                }, {
                  type: "kern",
                  size: m
                }]
              }, u);
              return G.makeSpan(["mord", "overline"], [y], u);
            },
            mathmlBuilder(a, u) {
              const c = new oe.MathNode("mo", [new oe.TextNode("â€¾")]);
              c.setAttribute("stretchy", "true");
              const d = new oe.MathNode("mover", [je(a.body, u), c]);
              return d.setAttribute("accent", "true"), d;
            }
          }), de({
            type: "phantom",
            names: ["\\phantom"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: (a, u) => {
              let {
                parser: c
              } = a;
              const d = u[0];
              return {
                type: "phantom",
                mode: c.mode,
                body: st(d)
              };
            },
            htmlBuilder: (a, u) => {
              const c = ct(a.body, u.withPhantom(), false);
              return G.makeFragment(c);
            },
            mathmlBuilder: (a, u) => {
              const c = Ct(a.body, u);
              return new oe.MathNode("mphantom", c);
            }
          }), de({
            type: "hphantom",
            names: ["\\hphantom"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: (a, u) => {
              let {
                parser: c
              } = a;
              const d = u[0];
              return {
                type: "hphantom",
                mode: c.mode,
                body: d
              };
            },
            htmlBuilder: (a, u) => {
              let c = G.makeSpan([], [Fe(a.body, u.withPhantom())]);
              if (c.height = 0, c.depth = 0, c.children)
                for (let d = 0; d < c.children.length; d++)
                  c.children[d].height = 0, c.children[d].depth = 0;
              return c = G.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: c
                }]
              }, u), G.makeSpan(["mord"], [c], u);
            },
            mathmlBuilder: (a, u) => {
              const c = Ct(st(a.body), u), d = new oe.MathNode("mphantom", c), m = new oe.MathNode("mpadded", [d]);
              return m.setAttribute("height", "0px"), m.setAttribute("depth", "0px"), m;
            }
          }), de({
            type: "vphantom",
            names: ["\\vphantom"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: (a, u) => {
              let {
                parser: c
              } = a;
              const d = u[0];
              return {
                type: "vphantom",
                mode: c.mode,
                body: d
              };
            },
            htmlBuilder: (a, u) => {
              const c = G.makeSpan(["inner"], [Fe(a.body, u.withPhantom())]), d = G.makeSpan(["fix"], []);
              return G.makeSpan(["mord", "rlap"], [c, d], u);
            },
            mathmlBuilder: (a, u) => {
              const c = Ct(st(a.body), u), d = new oe.MathNode("mphantom", c), m = new oe.MathNode("mpadded", [d]);
              return m.setAttribute("width", "0px"), m;
            }
          }), de({
            type: "raisebox",
            names: ["\\raisebox"],
            props: {
              numArgs: 2,
              argTypes: ["size", "hbox"],
              allowedInText: true
            },
            handler(a, u) {
              let {
                parser: c
              } = a;
              const d = Ae(u[0], "size").value, m = u[1];
              return {
                type: "raisebox",
                mode: c.mode,
                dy: d,
                body: m
              };
            },
            htmlBuilder(a, u) {
              const c = Fe(a.body, u), d = Qe(a.dy, u);
              return G.makeVList({
                positionType: "shift",
                positionData: -d,
                children: [{
                  type: "elem",
                  elem: c
                }]
              }, u);
            },
            mathmlBuilder(a, u) {
              const c = new oe.MathNode("mpadded", [je(a.body, u)]), d = a.dy.number + a.dy.unit;
              return c.setAttribute("voffset", d), c;
            }
          }), de({
            type: "internal",
            names: ["\\relax"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInArgument: true
            },
            handler(a) {
              let {
                parser: u
              } = a;
              return {
                type: "internal",
                mode: u.mode
              };
            }
          }), de({
            type: "rule",
            names: ["\\rule"],
            props: {
              numArgs: 2,
              numOptionalArgs: 1,
              allowedInText: true,
              allowedInMath: true,
              argTypes: ["size", "size", "size"]
            },
            handler(a, u, c) {
              let {
                parser: d
              } = a;
              const m = c[0], y = Ae(u[0], "size"), _ = Ae(u[1], "size");
              return {
                type: "rule",
                mode: d.mode,
                shift: m && Ae(m, "size").value,
                width: y.value,
                height: _.value
              };
            },
            htmlBuilder(a, u) {
              const c = G.makeSpan(["mord", "rule"], [], u), d = Qe(a.width, u), m = Qe(a.height, u), y = a.shift ? Qe(a.shift, u) : 0;
              return c.style.borderRightWidth = ce(d), c.style.borderTopWidth = ce(m), c.style.bottom = ce(y), c.width = d, c.height = m + y, c.depth = -y, c.maxFontSize = m * 1.125 * u.sizeMultiplier, c;
            },
            mathmlBuilder(a, u) {
              const c = Qe(a.width, u), d = Qe(a.height, u), m = a.shift ? Qe(a.shift, u) : 0, y = u.color && u.getColor() || "black", _ = new oe.MathNode("mspace");
              _.setAttribute("mathbackground", y), _.setAttribute("width", ce(c)), _.setAttribute("height", ce(d));
              const E = new oe.MathNode("mpadded", [_]);
              return m >= 0 ? E.setAttribute("height", ce(m)) : (E.setAttribute("height", ce(m)), E.setAttribute("depth", ce(-m))), E.setAttribute("voffset", ce(m)), E;
            }
          });
          function Cc(a, u, c) {
            const d = ct(a, u, false), m = u.sizeMultiplier / c.sizeMultiplier;
            for (let y = 0; y < d.length; y++) {
              const _ = d[y].classes.indexOf("sizing");
              _ < 0 ? Array.prototype.push.apply(d[y].classes, u.sizingClasses(c)) : d[y].classes[_ + 1] === "reset-size" + u.size && (d[y].classes[_ + 1] = "reset-size" + c.size), d[y].height *= m, d[y].depth *= m;
            }
            return G.makeFragment(d);
          }
          const Tc = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
          de({
            type: "sizing",
            names: Tc,
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler: (a, u) => {
              let {
                breakOnTokenText: c,
                funcName: d,
                parser: m
              } = a;
              const y = m.parseExpression(false, c);
              return {
                type: "sizing",
                mode: m.mode,
                // Figure out what size to use based on the list of functions above
                size: Tc.indexOf(d) + 1,
                body: y
              };
            },
            htmlBuilder: (a, u) => {
              const c = u.havingSize(a.size);
              return Cc(a.body, c, u);
            },
            mathmlBuilder: (a, u) => {
              const c = u.havingSize(a.size), d = Ct(a.body, c), m = new oe.MathNode("mstyle", d);
              return m.setAttribute("mathsize", ce(c.sizeMultiplier)), m;
            }
          }), de({
            type: "smash",
            names: ["\\smash"],
            props: {
              numArgs: 1,
              numOptionalArgs: 1,
              allowedInText: true
            },
            handler: (a, u, c) => {
              let {
                parser: d
              } = a, m = false, y = false;
              const _ = c[0] && Ae(c[0], "ordgroup");
              if (_) {
                let M = "";
                for (let B = 0; B < _.body.length; ++B)
                  if (M = _.body[B].text, M === "t")
                    m = true;
                  else if (M === "b")
                    y = true;
                  else {
                    m = false, y = false;
                    break;
                  }
              } else
                m = true, y = true;
              const E = u[0];
              return {
                type: "smash",
                mode: d.mode,
                body: E,
                smashHeight: m,
                smashDepth: y
              };
            },
            htmlBuilder: (a, u) => {
              const c = G.makeSpan([], [Fe(a.body, u)]);
              if (!a.smashHeight && !a.smashDepth)
                return c;
              if (a.smashHeight && (c.height = 0, c.children))
                for (let m = 0; m < c.children.length; m++)
                  c.children[m].height = 0;
              if (a.smashDepth && (c.depth = 0, c.children))
                for (let m = 0; m < c.children.length; m++)
                  c.children[m].depth = 0;
              const d = G.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: c
                }]
              }, u);
              return G.makeSpan(["mord"], [d], u);
            },
            mathmlBuilder: (a, u) => {
              const c = new oe.MathNode("mpadded", [je(a.body, u)]);
              return a.smashHeight && c.setAttribute("height", "0px"), a.smashDepth && c.setAttribute("depth", "0px"), c;
            }
          }), de({
            type: "sqrt",
            names: ["\\sqrt"],
            props: {
              numArgs: 1,
              numOptionalArgs: 1
            },
            handler(a, u, c) {
              let {
                parser: d
              } = a;
              const m = c[0], y = u[0];
              return {
                type: "sqrt",
                mode: d.mode,
                body: y,
                index: m
              };
            },
            htmlBuilder(a, u) {
              let c = Fe(a.body, u.havingCrampedStyle());
              c.height === 0 && (c.height = u.fontMetrics().xHeight), c = G.wrapFragment(c, u);
              const m = u.fontMetrics().defaultRuleThickness;
              let y = m;
              u.style.id < ne.TEXT.id && (y = u.fontMetrics().xHeight);
              let _ = m + y / 4;
              const E = c.height + c.depth + _ + m, {
                span: M,
                ruleWidth: B,
                advanceWidth: H
              } = Cn.sqrtImage(E, u), U = M.height - B;
              U > c.height + c.depth + _ && (_ = (_ + U - c.height - c.depth) / 2);
              const W = M.height - c.height - _ - B;
              c.style.paddingLeft = ce(H);
              const re = G.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: c,
                  wrapperClasses: ["svg-align"]
                }, {
                  type: "kern",
                  size: -(c.height + W)
                }, {
                  type: "elem",
                  elem: M
                }, {
                  type: "kern",
                  size: B
                }]
              }, u);
              if (a.index) {
                const me = u.havingStyle(ne.SCRIPTSCRIPT), be = Fe(a.index, me, u), Ne = 0.6 * (re.height - re.depth), Ee = G.makeVList({
                  positionType: "shift",
                  positionData: -Ne,
                  children: [{
                    type: "elem",
                    elem: be
                  }]
                }, u), Ie = G.makeSpan(["root"], [Ee]);
                return G.makeSpan(["mord", "sqrt"], [Ie, re], u);
              } else
                return G.makeSpan(["mord", "sqrt"], [re], u);
            },
            mathmlBuilder(a, u) {
              const {
                body: c,
                index: d
              } = a;
              return d ? new oe.MathNode("mroot", [je(c, u), je(d, u)]) : new oe.MathNode("msqrt", [je(c, u)]);
            }
          });
          const Dc = {
            display: ne.DISPLAY,
            text: ne.TEXT,
            script: ne.SCRIPT,
            scriptscript: ne.SCRIPTSCRIPT
          };
          de({
            type: "styling",
            names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
            props: {
              numArgs: 0,
              allowedInText: true,
              primitive: true
            },
            handler(a, u) {
              let {
                breakOnTokenText: c,
                funcName: d,
                parser: m
              } = a;
              const y = m.parseExpression(true, c), _ = d.slice(1, d.length - 5);
              return {
                type: "styling",
                mode: m.mode,
                // Figure out what style to use by pulling out the style from
                // the function name
                style: _,
                body: y
              };
            },
            htmlBuilder(a, u) {
              const c = Dc[a.style], d = u.havingStyle(c).withFont("");
              return Cc(a.body, d, u);
            },
            mathmlBuilder(a, u) {
              const c = Dc[a.style], d = u.havingStyle(c), m = Ct(a.body, d), y = new oe.MathNode("mstyle", m), E = {
                display: ["0", "true"],
                text: ["0", "false"],
                script: ["1", "false"],
                scriptscript: ["2", "false"]
              }[a.style];
              return y.setAttribute("scriptlevel", E[0]), y.setAttribute("displaystyle", E[1]), y;
            }
          });
          const hm = function(a, u) {
            const c = a.base;
            return c ? c.type === "op" ? c.limits && (u.style.size === ne.DISPLAY.size || c.alwaysHandleSupSub) ? Cr : null : c.type === "operatorname" ? c.alwaysHandleSupSub && (u.style.size === ne.DISPLAY.size || c.limits) ? Ec : null : c.type === "accent" ? D.isCharacterBox(c.base) ? vu : null : c.type === "horizBrace" && !a.sub === c.isOver ? kc : null : null;
          };
          ir({
            type: "supsub",
            htmlBuilder(a, u) {
              const c = hm(a, u);
              if (c)
                return c(a, u);
              const {
                base: d,
                sup: m,
                sub: y
              } = a, _ = Fe(d, u);
              let E, M;
              const B = u.fontMetrics();
              let H = 0, U = 0;
              const W = d && D.isCharacterBox(d);
              if (m) {
                const ze = u.havingStyle(u.style.sup());
                E = Fe(m, ze, u), W || (H = _.height - ze.fontMetrics().supDrop * ze.sizeMultiplier / u.sizeMultiplier);
              }
              if (y) {
                const ze = u.havingStyle(u.style.sub());
                M = Fe(y, ze, u), W || (U = _.depth + ze.fontMetrics().subDrop * ze.sizeMultiplier / u.sizeMultiplier);
              }
              let re;
              u.style === ne.DISPLAY ? re = B.sup1 : u.style.cramped ? re = B.sup3 : re = B.sup2;
              const me = u.sizeMultiplier, be = ce(0.5 / B.ptPerEm / me);
              let Ne = null;
              if (M) {
                const ze = a.base && a.base.type === "op" && a.base.name && (a.base.name === "\\oiint" || a.base.name === "\\oiiint");
                (_ instanceof Rt || ze) && (Ne = ce(-_.italic));
              }
              let Ee;
              if (E && M) {
                H = Math.max(H, re, E.depth + 0.25 * B.xHeight), U = Math.max(U, B.sub2);
                const Ve = 4 * B.defaultRuleThickness;
                if (H - E.depth - (M.height - U) < Ve) {
                  U = Ve - (H - E.depth) + M.height;
                  const ft = 0.8 * B.xHeight - (H - E.depth);
                  ft > 0 && (H += ft, U -= ft);
                }
                const _t = [{
                  type: "elem",
                  elem: M,
                  shift: U,
                  marginRight: be,
                  marginLeft: Ne
                }, {
                  type: "elem",
                  elem: E,
                  shift: -H,
                  marginRight: be
                }];
                Ee = G.makeVList({
                  positionType: "individualShift",
                  children: _t
                }, u);
              } else if (M) {
                U = Math.max(U, B.sub1, M.height - 0.8 * B.xHeight);
                const ze = [{
                  type: "elem",
                  elem: M,
                  marginLeft: Ne,
                  marginRight: be
                }];
                Ee = G.makeVList({
                  positionType: "shift",
                  positionData: U,
                  children: ze
                }, u);
              } else if (E)
                H = Math.max(H, re, E.depth + 0.25 * B.xHeight), Ee = G.makeVList({
                  positionType: "shift",
                  positionData: -H,
                  children: [{
                    type: "elem",
                    elem: E,
                    marginRight: be
                  }]
                }, u);
              else
                throw new Error("supsub must have either sup or sub.");
              const Ie = mu(_, "right") || "mord";
              return G.makeSpan([Ie], [_, G.makeSpan(["msupsub"], [Ee])], u);
            },
            mathmlBuilder(a, u) {
              let c = false, d, m;
              a.base && a.base.type === "horizBrace" && (m = !!a.sup, m === a.base.isOver && (c = true, d = a.base.isOver)), a.base && (a.base.type === "op" || a.base.type === "operatorname") && (a.base.parentIsSupSub = true);
              const y = [je(a.base, u)];
              a.sub && y.push(je(a.sub, u)), a.sup && y.push(je(a.sup, u));
              let _;
              if (c)
                _ = d ? "mover" : "munder";
              else if (a.sub)
                if (a.sup) {
                  const E = a.base;
                  E && E.type === "op" && E.limits && u.style === ne.DISPLAY || E && E.type === "operatorname" && E.alwaysHandleSupSub && (u.style === ne.DISPLAY || E.limits) ? _ = "munderover" : _ = "msubsup";
                } else {
                  const E = a.base;
                  E && E.type === "op" && E.limits && (u.style === ne.DISPLAY || E.alwaysHandleSupSub) || E && E.type === "operatorname" && E.alwaysHandleSupSub && (E.limits || u.style === ne.DISPLAY) ? _ = "munder" : _ = "msub";
                }
              else {
                const E = a.base;
                E && E.type === "op" && E.limits && (u.style === ne.DISPLAY || E.alwaysHandleSupSub) || E && E.type === "operatorname" && E.alwaysHandleSupSub && (E.limits || u.style === ne.DISPLAY) ? _ = "mover" : _ = "msup";
              }
              return new oe.MathNode(_, y);
            }
          }), ir({
            type: "atom",
            htmlBuilder(a, u) {
              return G.mathsym(a.text, a.mode, u, ["m" + a.family]);
            },
            mathmlBuilder(a, u) {
              const c = new oe.MathNode("mo", [Pt(a.text, a.mode)]);
              if (a.family === "bin") {
                const d = yu(a, u);
                d === "bold-italic" && c.setAttribute("mathvariant", d);
              } else a.family === "punct" ? c.setAttribute("separator", "true") : (a.family === "open" || a.family === "close") && c.setAttribute("stretchy", "false");
              return c;
            }
          });
          const Mc = {
            mi: "italic",
            mn: "normal",
            mtext: "normal"
          };
          ir({
            type: "mathord",
            htmlBuilder(a, u) {
              return G.makeOrd(a, u, "mathord");
            },
            mathmlBuilder(a, u) {
              const c = new oe.MathNode("mi", [Pt(a.text, a.mode, u)]), d = yu(a, u) || "italic";
              return d !== Mc[c.type] && c.setAttribute("mathvariant", d), c;
            }
          }), ir({
            type: "textord",
            htmlBuilder(a, u) {
              return G.makeOrd(a, u, "textord");
            },
            mathmlBuilder(a, u) {
              const c = Pt(a.text, a.mode, u), d = yu(a, u) || "normal";
              let m;
              return a.mode === "text" ? m = new oe.MathNode("mtext", [c]) : /[0-9]/.test(a.text) ? m = new oe.MathNode("mn", [c]) : a.text === "\\prime" ? m = new oe.MathNode("mo", [c]) : m = new oe.MathNode("mi", [c]), d !== Mc[m.type] && m.setAttribute("mathvariant", d), m;
            }
          });
          const $u = {
            "\\nobreak": "nobreak",
            "\\allowbreak": "allowbreak"
          }, Lu = {
            " ": {},
            "\\ ": {},
            "~": {
              className: "nobreak"
            },
            "\\space": {},
            "\\nobreakspace": {
              className: "nobreak"
            }
          };
          ir({
            type: "spacing",
            htmlBuilder(a, u) {
              if (Lu.hasOwnProperty(a.text)) {
                const c = Lu[a.text].className || "";
                if (a.mode === "text") {
                  const d = G.makeOrd(a, u, "textord");
                  return d.classes.push(c), d;
                } else
                  return G.makeSpan(["mspace", c], [G.mathsym(a.text, a.mode, u)], u);
              } else {
                if ($u.hasOwnProperty(a.text))
                  return G.makeSpan(["mspace", $u[a.text]], [], u);
                throw new s('Unknown type of space "' + a.text + '"');
              }
            },
            mathmlBuilder(a, u) {
              let c;
              if (Lu.hasOwnProperty(a.text))
                c = new oe.MathNode("mtext", [new oe.TextNode("Â ")]);
              else {
                if ($u.hasOwnProperty(a.text))
                  return new oe.MathNode("mspace");
                throw new s('Unknown type of space "' + a.text + '"');
              }
              return c;
            }
          });
          const Nc = () => {
            const a = new oe.MathNode("mtd", []);
            return a.setAttribute("width", "50%"), a;
          };
          ir({
            type: "tag",
            mathmlBuilder(a, u) {
              const c = new oe.MathNode("mtable", [new oe.MathNode("mtr", [Nc(), new oe.MathNode("mtd", [Rn(a.body, u)]), Nc(), new oe.MathNode("mtd", [Rn(a.tag, u)])])]);
              return c.setAttribute("width", "100%"), c;
            }
          });
          const Ic = {
            "\\text": void 0,
            "\\textrm": "textrm",
            "\\textsf": "textsf",
            "\\texttt": "texttt",
            "\\textnormal": "textrm"
          }, Fc = {
            "\\textbf": "textbf",
            "\\textmd": "textmd"
          }, dm = {
            "\\textit": "textit",
            "\\textup": "textup"
          }, Bc = (a, u) => {
            const c = a.font;
            if (c) {
              if (Ic[c])
                return u.withTextFontFamily(Ic[c]);
              if (Fc[c])
                return u.withTextFontWeight(Fc[c]);
              if (c === "\\emph")
                return u.fontShape === "textit" ? u.withTextFontShape("textup") : u.withTextFontShape("textit");
            } else return u;
            return u.withTextFontShape(dm[c]);
          };
          de({
            type: "text",
            names: [
              // Font families
              "\\text",
              "\\textrm",
              "\\textsf",
              "\\texttt",
              "\\textnormal",
              // Font weights
              "\\textbf",
              "\\textmd",
              // Font Shapes
              "\\textit",
              "\\textup",
              "\\emph"
            ],
            props: {
              numArgs: 1,
              argTypes: ["text"],
              allowedInArgument: true,
              allowedInText: true
            },
            handler(a, u) {
              let {
                parser: c,
                funcName: d
              } = a;
              const m = u[0];
              return {
                type: "text",
                mode: c.mode,
                body: st(m),
                font: d
              };
            },
            htmlBuilder(a, u) {
              const c = Bc(a, u), d = ct(a.body, c, true);
              return G.makeSpan(["mord", "text"], d, c);
            },
            mathmlBuilder(a, u) {
              const c = Bc(a, u);
              return Rn(a.body, c);
            }
          }), de({
            type: "underline",
            names: ["\\underline"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler(a, u) {
              let {
                parser: c
              } = a;
              return {
                type: "underline",
                mode: c.mode,
                body: u[0]
              };
            },
            htmlBuilder(a, u) {
              const c = Fe(a.body, u), d = G.makeLineSpan("underline-line", u), m = u.fontMetrics().defaultRuleThickness, y = G.makeVList({
                positionType: "top",
                positionData: c.height,
                children: [{
                  type: "kern",
                  size: m
                }, {
                  type: "elem",
                  elem: d
                }, {
                  type: "kern",
                  size: 3 * m
                }, {
                  type: "elem",
                  elem: c
                }]
              }, u);
              return G.makeSpan(["mord", "underline"], [y], u);
            },
            mathmlBuilder(a, u) {
              const c = new oe.MathNode("mo", [new oe.TextNode("â€¾")]);
              c.setAttribute("stretchy", "true");
              const d = new oe.MathNode("munder", [je(a.body, u), c]);
              return d.setAttribute("accentunder", "true"), d;
            }
          }), de({
            type: "vcenter",
            names: ["\\vcenter"],
            props: {
              numArgs: 1,
              argTypes: ["original"],
              // In LaTeX, \vcenter can act only on a box.
              allowedInText: false
            },
            handler(a, u) {
              let {
                parser: c
              } = a;
              return {
                type: "vcenter",
                mode: c.mode,
                body: u[0]
              };
            },
            htmlBuilder(a, u) {
              const c = Fe(a.body, u), d = u.fontMetrics().axisHeight, m = 0.5 * (c.height - d - (c.depth + d));
              return G.makeVList({
                positionType: "shift",
                positionData: m,
                children: [{
                  type: "elem",
                  elem: c
                }]
              }, u);
            },
            mathmlBuilder(a, u) {
              return new oe.MathNode("mpadded", [je(a.body, u)], ["vcenter"]);
            }
          }), de({
            type: "verb",
            names: ["\\verb"],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler(a, u, c) {
              throw new s("\\verb ended by end of line instead of matching delimiter");
            },
            htmlBuilder(a, u) {
              const c = Oc(a), d = [], m = u.havingStyle(u.style.text());
              for (let y = 0; y < c.length; y++) {
                let _ = c[y];
                _ === "~" && (_ = "\\textasciitilde"), d.push(G.makeSymbol(_, "Typewriter-Regular", a.mode, m, ["mord", "texttt"]));
              }
              return G.makeSpan(["mord", "text"].concat(m.sizingClasses(u)), G.tryCombineChars(d), m);
            },
            mathmlBuilder(a, u) {
              const c = new oe.TextNode(Oc(a)), d = new oe.MathNode("mtext", [c]);
              return d.setAttribute("mathvariant", "monospace"), d;
            }
          });
          const Oc = (a) => a.body.replace(/ /g, a.star ? "â£" : "Â ");
          var Hn = Rl;
          const zc = `[ \r
	]`, pm = "\\\\[a-zA-Z@]+", mm = "\\\\[^\uD800-\uDFFF]", gm = "(" + pm + ")" + zc + "*", bm = `\\\\(
|[ \r	]+
?)[ \r	]*`, qu = "[Ì€-Í¯]", ym = new RegExp(qu + "+$"), xm = "(" + zc + "+)|" + // whitespace
          (bm + "|") + // \whitespace
          "([!-\\[\\]-â€§â€ª-íŸ¿ï¤€-ï¿¿]" + // single codepoint
          (qu + "*") + // ...plus accents
          "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
          (qu + "*") + // ...plus accents
          "|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
          ("|" + gm) + // \macroName + spaces
          ("|" + mm + ")");
          class $c {
            // Category codes. The lexer only supports comment characters (14) for now.
            // MacroExpander additionally distinguishes active (13).
            constructor(u, c) {
              this.input = void 0, this.settings = void 0, this.tokenRegex = void 0, this.catcodes = void 0, this.input = u, this.settings = c, this.tokenRegex = new RegExp(xm, "g"), this.catcodes = {
                "%": 14,
                // comment character
                "~": 13
                // active character
              };
            }
            setCatcode(u, c) {
              this.catcodes[u] = c;
            }
            /**
             * This function lexes a single token.
             */
            lex() {
              const u = this.input, c = this.tokenRegex.lastIndex;
              if (c === u.length)
                return new Ht("EOF", new Ot(this, c, c));
              const d = this.tokenRegex.exec(u);
              if (d === null || d.index !== c)
                throw new s("Unexpected character: '" + u[c] + "'", new Ht(u[c], new Ot(this, c, c + 1)));
              const m = d[6] || d[3] || (d[2] ? "\\ " : " ");
              if (this.catcodes[m] === 14) {
                const y = u.indexOf(`
`, this.tokenRegex.lastIndex);
                return y === -1 ? (this.tokenRegex.lastIndex = u.length, this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)")) : this.tokenRegex.lastIndex = y + 1, this.lex();
              }
              return new Ht(m, new Ot(this, c, this.tokenRegex.lastIndex));
            }
          }
          class wm {
            /**
             * Both arguments are optional.  The first argument is an object of
             * built-in mappings which never change.  The second argument is an object
             * of initial (global-level) mappings, which will constantly change
             * according to any global/top-level `set`s done.
             */
            constructor(u, c) {
              u === void 0 && (u = {}), c === void 0 && (c = {}), this.current = void 0, this.builtins = void 0, this.undefStack = void 0, this.current = c, this.builtins = u, this.undefStack = [];
            }
            /**
             * Start a new nested group, affecting future local `set`s.
             */
            beginGroup() {
              this.undefStack.push({});
            }
            /**
             * End current nested group, restoring values before the group began.
             */
            endGroup() {
              if (this.undefStack.length === 0)
                throw new s("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
              const u = this.undefStack.pop();
              for (const c in u)
                u.hasOwnProperty(c) && (u[c] == null ? delete this.current[c] : this.current[c] = u[c]);
            }
            /**
             * Ends all currently nested groups (if any), restoring values before the
             * groups began.  Useful in case of an error in the middle of parsing.
             */
            endGroups() {
              for (; this.undefStack.length > 0; )
                this.endGroup();
            }
            /**
             * Detect whether `name` has a definition.  Equivalent to
             * `get(name) != null`.
             */
            has(u) {
              return this.current.hasOwnProperty(u) || this.builtins.hasOwnProperty(u);
            }
            /**
             * Get the current value of a name, or `undefined` if there is no value.
             *
             * Note: Do not use `if (namespace.get(...))` to detect whether a macro
             * is defined, as the definition may be the empty string which evaluates
             * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
             * `if (namespace.has(...))`.
             */
            get(u) {
              return this.current.hasOwnProperty(u) ? this.current[u] : this.builtins[u];
            }
            /**
             * Set the current value of a name, and optionally set it globally too.
             * Local set() sets the current value and (when appropriate) adds an undo
             * operation to the undo stack.  Global set() may change the undo
             * operation at every level, so takes time linear in their number.
             * A value of undefined means to delete existing definitions.
             */
            set(u, c, d) {
              if (d === void 0 && (d = false), d) {
                for (let m = 0; m < this.undefStack.length; m++)
                  delete this.undefStack[m][u];
                this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][u] = c);
              } else {
                const m = this.undefStack[this.undefStack.length - 1];
                m && !m.hasOwnProperty(u) && (m[u] = this.current[u]);
              }
              c == null ? delete this.current[u] : this.current[u] = c;
            }
          }
          var vm = hc;
          C("\\noexpand", function(a) {
            const u = a.popToken();
            return a.isExpandable(u.text) && (u.noexpand = true, u.treatAsRelax = true), {
              tokens: [u],
              numArgs: 0
            };
          }), C("\\expandafter", function(a) {
            const u = a.popToken();
            return a.expandOnce(true), {
              tokens: [u],
              numArgs: 0
            };
          }), C("\\@firstoftwo", function(a) {
            return {
              tokens: a.consumeArgs(2)[0],
              numArgs: 0
            };
          }), C("\\@secondoftwo", function(a) {
            return {
              tokens: a.consumeArgs(2)[1],
              numArgs: 0
            };
          }), C("\\@ifnextchar", function(a) {
            const u = a.consumeArgs(3);
            a.consumeSpaces();
            const c = a.future();
            return u[0].length === 1 && u[0][0].text === c.text ? {
              tokens: u[1],
              numArgs: 0
            } : {
              tokens: u[2],
              numArgs: 0
            };
          }), C("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}"), C("\\TextOrMath", function(a) {
            const u = a.consumeArgs(2);
            return a.mode === "text" ? {
              tokens: u[0],
              numArgs: 0
            } : {
              tokens: u[1],
              numArgs: 0
            };
          });
          const Lc = {
            0: 0,
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 5,
            6: 6,
            7: 7,
            8: 8,
            9: 9,
            a: 10,
            A: 10,
            b: 11,
            B: 11,
            c: 12,
            C: 12,
            d: 13,
            D: 13,
            e: 14,
            E: 14,
            f: 15,
            F: 15
          };
          C("\\char", function(a) {
            let u = a.popToken(), c, d = "";
            if (u.text === "'")
              c = 8, u = a.popToken();
            else if (u.text === '"')
              c = 16, u = a.popToken();
            else if (u.text === "`")
              if (u = a.popToken(), u.text[0] === "\\")
                d = u.text.charCodeAt(1);
              else {
                if (u.text === "EOF")
                  throw new s("\\char` missing argument");
                d = u.text.charCodeAt(0);
              }
            else
              c = 10;
            if (c) {
              if (d = Lc[u.text], d == null || d >= c)
                throw new s("Invalid base-" + c + " digit " + u.text);
              let m;
              for (; (m = Lc[a.future().text]) != null && m < c; )
                d *= c, d += m, a.popToken();
            }
            return "\\@char{" + d + "}";
          });
          const Ru = (a, u, c, d) => {
            let m = a.consumeArg().tokens;
            if (m.length !== 1)
              throw new s("\\newcommand's first argument must be a macro name");
            const y = m[0].text, _ = a.isDefined(y);
            if (_ && !u)
              throw new s("\\newcommand{" + y + "} attempting to redefine " + (y + "; use \\renewcommand"));
            if (!_ && !c)
              throw new s("\\renewcommand{" + y + "} when command " + y + " does not yet exist; use \\newcommand");
            let E = 0;
            if (m = a.consumeArg().tokens, m.length === 1 && m[0].text === "[") {
              let M = "", B = a.expandNextToken();
              for (; B.text !== "]" && B.text !== "EOF"; )
                M += B.text, B = a.expandNextToken();
              if (!M.match(/^\s*[0-9]+\s*$/))
                throw new s("Invalid number of arguments: " + M);
              E = parseInt(M), m = a.consumeArg().tokens;
            }
            return _ && d || a.macros.set(y, {
              tokens: m,
              numArgs: E
            }), "";
          };
          C("\\newcommand", (a) => Ru(a, false, true, false)), C("\\renewcommand", (a) => Ru(a, true, false, false)), C("\\providecommand", (a) => Ru(a, true, true, true)), C("\\message", (a) => {
            const u = a.consumeArgs(1)[0];
            return console.log(u.reverse().map((c) => c.text).join("")), "";
          }), C("\\errmessage", (a) => {
            const u = a.consumeArgs(1)[0];
            return console.error(u.reverse().map((c) => c.text).join("")), "";
          }), C("\\show", (a) => {
            const u = a.popToken(), c = u.text;
            return console.log(u, a.macros.get(c), Hn[c], et.math[c], et.text[c]), "";
          }), C("\\bgroup", "{"), C("\\egroup", "}"), C("~", "\\nobreakspace"), C("\\lq", "`"), C("\\rq", "'"), C("\\aa", "\\r a"), C("\\AA", "\\r A"), C("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`Â©}"), C("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}"), C("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`Â®}"), C("â„¬", "\\mathscr{B}"), C("â„°", "\\mathscr{E}"), C("â„±", "\\mathscr{F}"), C("â„‹", "\\mathscr{H}"), C("â„", "\\mathscr{I}"), C("â„’", "\\mathscr{L}"), C("â„³", "\\mathscr{M}"), C("â„›", "\\mathscr{R}"), C("â„­", "\\mathfrak{C}"), C("â„Œ", "\\mathfrak{H}"), C("â„¨", "\\mathfrak{Z}"), C("\\Bbbk", "\\Bbb{k}"), C("Â·", "\\cdotp"), C("\\llap", "\\mathllap{\\textrm{#1}}"), C("\\rlap", "\\mathrlap{\\textrm{#1}}"), C("\\clap", "\\mathclap{\\textrm{#1}}"), C("\\mathstrut", "\\vphantom{(}"), C("\\underbar", "\\underline{\\text{#1}}"), C("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}'), C("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`â‰ }}"), C("\\ne", "\\neq"), C("â‰ ", "\\neq"), C("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`âˆ‰}}"), C("âˆ‰", "\\notin"), C("â‰˜", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`â‰˜}}"), C("â‰™", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`â‰˜}}"), C("â‰š", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`â‰š}}"), C("â‰›", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`â‰›}}"), C("â‰", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`â‰}}"), C("â‰", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`â‰}}"), C("â‰Ÿ", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`â‰Ÿ}}"), C("âŸ‚", "\\perp"), C("â€¼", "\\mathclose{!\\mkern-0.8mu!}"), C("âˆŒ", "\\notni"), C("âŒœ", "\\ulcorner"), C("âŒ", "\\urcorner"), C("âŒ", "\\llcorner"), C("âŒŸ", "\\lrcorner"), C("Â©", "\\copyright"), C("Â®", "\\textregistered"), C("ï¸", "\\textregistered"), C("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}'), C("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}'), C("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}'), C("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}'), C("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}"), C("â‹®", "\\vdots"), C("\\varGamma", "\\mathit{\\Gamma}"), C("\\varDelta", "\\mathit{\\Delta}"), C("\\varTheta", "\\mathit{\\Theta}"), C("\\varLambda", "\\mathit{\\Lambda}"), C("\\varXi", "\\mathit{\\Xi}"), C("\\varPi", "\\mathit{\\Pi}"), C("\\varSigma", "\\mathit{\\Sigma}"), C("\\varUpsilon", "\\mathit{\\Upsilon}"), C("\\varPhi", "\\mathit{\\Phi}"), C("\\varPsi", "\\mathit{\\Psi}"), C("\\varOmega", "\\mathit{\\Omega}"), C("\\substack", "\\begin{subarray}{c}#1\\end{subarray}"), C("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax"), C("\\boxed", "\\fbox{$\\displaystyle{#1}$}"), C("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;"), C("\\implies", "\\DOTSB\\;\\Longrightarrow\\;"), C("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;"), C("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}"), C("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
          const qc = {
            ",": "\\dotsc",
            "\\not": "\\dotsb",
            // \keybin@ checks for the following:
            "+": "\\dotsb",
            "=": "\\dotsb",
            "<": "\\dotsb",
            ">": "\\dotsb",
            "-": "\\dotsb",
            "*": "\\dotsb",
            ":": "\\dotsb",
            // Symbols whose definition starts with \DOTSB:
            "\\DOTSB": "\\dotsb",
            "\\coprod": "\\dotsb",
            "\\bigvee": "\\dotsb",
            "\\bigwedge": "\\dotsb",
            "\\biguplus": "\\dotsb",
            "\\bigcap": "\\dotsb",
            "\\bigcup": "\\dotsb",
            "\\prod": "\\dotsb",
            "\\sum": "\\dotsb",
            "\\bigotimes": "\\dotsb",
            "\\bigoplus": "\\dotsb",
            "\\bigodot": "\\dotsb",
            "\\bigsqcup": "\\dotsb",
            "\\And": "\\dotsb",
            "\\longrightarrow": "\\dotsb",
            "\\Longrightarrow": "\\dotsb",
            "\\longleftarrow": "\\dotsb",
            "\\Longleftarrow": "\\dotsb",
            "\\longleftrightarrow": "\\dotsb",
            "\\Longleftrightarrow": "\\dotsb",
            "\\mapsto": "\\dotsb",
            "\\longmapsto": "\\dotsb",
            "\\hookrightarrow": "\\dotsb",
            "\\doteq": "\\dotsb",
            // Symbols whose definition starts with \mathbin:
            "\\mathbin": "\\dotsb",
            // Symbols whose definition starts with \mathrel:
            "\\mathrel": "\\dotsb",
            "\\relbar": "\\dotsb",
            "\\Relbar": "\\dotsb",
            "\\xrightarrow": "\\dotsb",
            "\\xleftarrow": "\\dotsb",
            // Symbols whose definition starts with \DOTSI:
            "\\DOTSI": "\\dotsi",
            "\\int": "\\dotsi",
            "\\oint": "\\dotsi",
            "\\iint": "\\dotsi",
            "\\iiint": "\\dotsi",
            "\\iiiint": "\\dotsi",
            "\\idotsint": "\\dotsi",
            // Symbols whose definition starts with \DOTSX:
            "\\DOTSX": "\\dotsx"
          };
          C("\\dots", function(a) {
            let u = "\\dotso";
            const c = a.expandAfterFuture().text;
            return c in qc ? u = qc[c] : (c.slice(0, 4) === "\\not" || c in et.math && D.contains(["bin", "rel"], et.math[c].group)) && (u = "\\dotsb"), u;
          });
          const Pu = {
            // \rightdelim@ checks for the following:
            ")": true,
            "]": true,
            "\\rbrack": true,
            "\\}": true,
            "\\rbrace": true,
            "\\rangle": true,
            "\\rceil": true,
            "\\rfloor": true,
            "\\rgroup": true,
            "\\rmoustache": true,
            "\\right": true,
            "\\bigr": true,
            "\\biggr": true,
            "\\Bigr": true,
            "\\Biggr": true,
            // \extra@ also tests for the following:
            $: true,
            // \extrap@ checks for the following:
            ";": true,
            ".": true,
            ",": true
          };
          C("\\dotso", function(a) {
            return a.future().text in Pu ? "\\ldots\\," : "\\ldots";
          }), C("\\dotsc", function(a) {
            const u = a.future().text;
            return u in Pu && u !== "," ? "\\ldots\\," : "\\ldots";
          }), C("\\cdots", function(a) {
            return a.future().text in Pu ? "\\@cdots\\," : "\\@cdots";
          }), C("\\dotsb", "\\cdots"), C("\\dotsm", "\\cdots"), C("\\dotsi", "\\!\\cdots"), C("\\dotsx", "\\ldots\\,"), C("\\DOTSI", "\\relax"), C("\\DOTSB", "\\relax"), C("\\DOTSX", "\\relax"), C("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax"), C("\\,", "\\tmspace+{3mu}{.1667em}"), C("\\thinspace", "\\,"), C("\\>", "\\mskip{4mu}"), C("\\:", "\\tmspace+{4mu}{.2222em}"), C("\\medspace", "\\:"), C("\\;", "\\tmspace+{5mu}{.2777em}"), C("\\thickspace", "\\;"), C("\\!", "\\tmspace-{3mu}{.1667em}"), C("\\negthinspace", "\\!"), C("\\negmedspace", "\\tmspace-{4mu}{.2222em}"), C("\\negthickspace", "\\tmspace-{5mu}{.277em}"), C("\\enspace", "\\kern.5em "), C("\\enskip", "\\hskip.5em\\relax"), C("\\quad", "\\hskip1em\\relax"), C("\\qquad", "\\hskip2em\\relax"), C("\\tag", "\\@ifstar\\tag@literal\\tag@paren"), C("\\tag@paren", "\\tag@literal{({#1})}"), C("\\tag@literal", (a) => {
            if (a.macros.get("\\df@tag"))
              throw new s("Multiple \\tag");
            return "\\gdef\\df@tag{\\text{#1}}";
          }), C("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}"), C("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)"), C("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}"), C("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1"), C("\\newline", "\\\\\\relax"), C("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
          const Rc = ce(sn["Main-Regular"][84][1] - 0.7 * sn["Main-Regular"][65][1]);
          C("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + Rc + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}"), C("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + Rc + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}"), C("\\hspace", "\\@ifstar\\@hspacer\\@hspace"), C("\\@hspace", "\\hskip #1\\relax"), C("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax"), C("\\ordinarycolon", ":"), C("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}"), C("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}'), C("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}'), C("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}'), C("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}'), C("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}'), C("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}'), C("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}'), C("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}'), C("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}'), C("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}'), C("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}'), C("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}'), C("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}'), C("âˆ·", "\\dblcolon"), C("âˆ¹", "\\eqcolon"), C("â‰”", "\\coloneqq"), C("â‰•", "\\eqqcolon"), C("â©´", "\\Coloneqq"), C("\\ratio", "\\vcentcolon"), C("\\coloncolon", "\\dblcolon"), C("\\colonequals", "\\coloneqq"), C("\\coloncolonequals", "\\Coloneqq"), C("\\equalscolon", "\\eqqcolon"), C("\\equalscoloncolon", "\\Eqqcolon"), C("\\colonminus", "\\coloneq"), C("\\coloncolonminus", "\\Coloneq"), C("\\minuscolon", "\\eqcolon"), C("\\minuscoloncolon", "\\Eqcolon"), C("\\coloncolonapprox", "\\Colonapprox"), C("\\coloncolonsim", "\\Colonsim"), C("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}"), C("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}"), C("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}"), C("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}"), C("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`âˆŒ}}"), C("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}"), C("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}"), C("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}"), C("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}"), C("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}"), C("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}"), C("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}"), C("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}"), C("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{â‰©}"), C("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{â‰¨}"), C("\\ngeqq", "\\html@mathml{\\@ngeqq}{â‰±}"), C("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{â‰±}"), C("\\nleqq", "\\html@mathml{\\@nleqq}{â‰°}"), C("\\nleqslant", "\\html@mathml{\\@nleqslant}{â‰°}"), C("\\nshortmid", "\\html@mathml{\\@nshortmid}{âˆ¤}"), C("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{âˆ¦}"), C("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{âŠˆ}"), C("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{âŠ‰}"), C("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{âŠŠ}"), C("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{â«‹}"), C("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{âŠ‹}"), C("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{â«Œ}"), C("\\imath", "\\html@mathml{\\@imath}{Ä±}"), C("\\jmath", "\\html@mathml{\\@jmath}{È·}"), C("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`âŸ¦}}"), C("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`âŸ§}}"), C("âŸ¦", "\\llbracket"), C("âŸ§", "\\rrbracket"), C("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`â¦ƒ}}"), C("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`â¦„}}"), C("â¦ƒ", "\\lBrace"), C("â¦„", "\\rBrace"), C("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`â¦µ}}"), C("â¦µ", "\\minuso"), C("\\darr", "\\downarrow"), C("\\dArr", "\\Downarrow"), C("\\Darr", "\\Downarrow"), C("\\lang", "\\langle"), C("\\rang", "\\rangle"), C("\\uarr", "\\uparrow"), C("\\uArr", "\\Uparrow"), C("\\Uarr", "\\Uparrow"), C("\\N", "\\mathbb{N}"), C("\\R", "\\mathbb{R}"), C("\\Z", "\\mathbb{Z}"), C("\\alef", "\\aleph"), C("\\alefsym", "\\aleph"), C("\\Alpha", "\\mathrm{A}"), C("\\Beta", "\\mathrm{B}"), C("\\bull", "\\bullet"), C("\\Chi", "\\mathrm{X}"), C("\\clubs", "\\clubsuit"), C("\\cnums", "\\mathbb{C}"), C("\\Complex", "\\mathbb{C}"), C("\\Dagger", "\\ddagger"), C("\\diamonds", "\\diamondsuit"), C("\\empty", "\\emptyset"), C("\\Epsilon", "\\mathrm{E}"), C("\\Eta", "\\mathrm{H}"), C("\\exist", "\\exists"), C("\\harr", "\\leftrightarrow"), C("\\hArr", "\\Leftrightarrow"), C("\\Harr", "\\Leftrightarrow"), C("\\hearts", "\\heartsuit"), C("\\image", "\\Im"), C("\\infin", "\\infty"), C("\\Iota", "\\mathrm{I}"), C("\\isin", "\\in"), C("\\Kappa", "\\mathrm{K}"), C("\\larr", "\\leftarrow"), C("\\lArr", "\\Leftarrow"), C("\\Larr", "\\Leftarrow"), C("\\lrarr", "\\leftrightarrow"), C("\\lrArr", "\\Leftrightarrow"), C("\\Lrarr", "\\Leftrightarrow"), C("\\Mu", "\\mathrm{M}"), C("\\natnums", "\\mathbb{N}"), C("\\Nu", "\\mathrm{N}"), C("\\Omicron", "\\mathrm{O}"), C("\\plusmn", "\\pm"), C("\\rarr", "\\rightarrow"), C("\\rArr", "\\Rightarrow"), C("\\Rarr", "\\Rightarrow"), C("\\real", "\\Re"), C("\\reals", "\\mathbb{R}"), C("\\Reals", "\\mathbb{R}"), C("\\Rho", "\\mathrm{P}"), C("\\sdot", "\\cdot"), C("\\sect", "\\S"), C("\\spades", "\\spadesuit"), C("\\sub", "\\subset"), C("\\sube", "\\subseteq"), C("\\supe", "\\supseteq"), C("\\Tau", "\\mathrm{T}"), C("\\thetasym", "\\vartheta"), C("\\weierp", "\\wp"), C("\\Zeta", "\\mathrm{Z}"), C("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}"), C("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}"), C("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits"), C("\\bra", "\\mathinner{\\langle{#1}|}"), C("\\ket", "\\mathinner{|{#1}\\rangle}"), C("\\braket", "\\mathinner{\\langle{#1}\\rangle}"), C("\\Bra", "\\left\\langle#1\\right|"), C("\\Ket", "\\left|#1\\right\\rangle");
          const Pc = (a) => (u) => {
            const c = u.consumeArg().tokens, d = u.consumeArg().tokens, m = u.consumeArg().tokens, y = u.consumeArg().tokens, _ = u.macros.get("|"), E = u.macros.get("\\|");
            u.macros.beginGroup();
            const M = (U) => (W) => {
              a && (W.macros.set("|", _), m.length && W.macros.set("\\|", E));
              let re = U;
              return !U && m.length && W.future().text === "|" && (W.popToken(), re = true), {
                tokens: re ? m : d,
                numArgs: 0
              };
            };
            u.macros.set("|", M(false)), m.length && u.macros.set("\\|", M(true));
            const B = u.consumeArg().tokens, H = u.expandTokens([
              ...y,
              ...B,
              ...c
              // reversed
            ]);
            return u.macros.endGroup(), {
              tokens: H.reverse(),
              numArgs: 0
            };
          };
          C("\\bra@ket", Pc(false)), C("\\bra@set", Pc(true)), C("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}"), C("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}"), C("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}"), C("\\angln", "{\\angl n}"), C("\\blue", "\\textcolor{##6495ed}{#1}"), C("\\orange", "\\textcolor{##ffa500}{#1}"), C("\\pink", "\\textcolor{##ff00af}{#1}"), C("\\red", "\\textcolor{##df0030}{#1}"), C("\\green", "\\textcolor{##28ae7b}{#1}"), C("\\gray", "\\textcolor{gray}{#1}"), C("\\purple", "\\textcolor{##9d38bd}{#1}"), C("\\blueA", "\\textcolor{##ccfaff}{#1}"), C("\\blueB", "\\textcolor{##80f6ff}{#1}"), C("\\blueC", "\\textcolor{##63d9ea}{#1}"), C("\\blueD", "\\textcolor{##11accd}{#1}"), C("\\blueE", "\\textcolor{##0c7f99}{#1}"), C("\\tealA", "\\textcolor{##94fff5}{#1}"), C("\\tealB", "\\textcolor{##26edd5}{#1}"), C("\\tealC", "\\textcolor{##01d1c1}{#1}"), C("\\tealD", "\\textcolor{##01a995}{#1}"), C("\\tealE", "\\textcolor{##208170}{#1}"), C("\\greenA", "\\textcolor{##b6ffb0}{#1}"), C("\\greenB", "\\textcolor{##8af281}{#1}"), C("\\greenC", "\\textcolor{##74cf70}{#1}"), C("\\greenD", "\\textcolor{##1fab54}{#1}"), C("\\greenE", "\\textcolor{##0d923f}{#1}"), C("\\goldA", "\\textcolor{##ffd0a9}{#1}"), C("\\goldB", "\\textcolor{##ffbb71}{#1}"), C("\\goldC", "\\textcolor{##ff9c39}{#1}"), C("\\goldD", "\\textcolor{##e07d10}{#1}"), C("\\goldE", "\\textcolor{##a75a05}{#1}"), C("\\redA", "\\textcolor{##fca9a9}{#1}"), C("\\redB", "\\textcolor{##ff8482}{#1}"), C("\\redC", "\\textcolor{##f9685d}{#1}"), C("\\redD", "\\textcolor{##e84d39}{#1}"), C("\\redE", "\\textcolor{##bc2612}{#1}"), C("\\maroonA", "\\textcolor{##ffbde0}{#1}"), C("\\maroonB", "\\textcolor{##ff92c6}{#1}"), C("\\maroonC", "\\textcolor{##ed5fa6}{#1}"), C("\\maroonD", "\\textcolor{##ca337c}{#1}"), C("\\maroonE", "\\textcolor{##9e034e}{#1}"), C("\\purpleA", "\\textcolor{##ddd7ff}{#1}"), C("\\purpleB", "\\textcolor{##c6b9fc}{#1}"), C("\\purpleC", "\\textcolor{##aa87ff}{#1}"), C("\\purpleD", "\\textcolor{##7854ab}{#1}"), C("\\purpleE", "\\textcolor{##543b78}{#1}"), C("\\mintA", "\\textcolor{##f5f9e8}{#1}"), C("\\mintB", "\\textcolor{##edf2df}{#1}"), C("\\mintC", "\\textcolor{##e0e5cc}{#1}"), C("\\grayA", "\\textcolor{##f6f7f7}{#1}"), C("\\grayB", "\\textcolor{##f0f1f2}{#1}"), C("\\grayC", "\\textcolor{##e3e5e6}{#1}"), C("\\grayD", "\\textcolor{##d6d8da}{#1}"), C("\\grayE", "\\textcolor{##babec2}{#1}"), C("\\grayF", "\\textcolor{##888d93}{#1}"), C("\\grayG", "\\textcolor{##626569}{#1}"), C("\\grayH", "\\textcolor{##3b3e40}{#1}"), C("\\grayI", "\\textcolor{##21242c}{#1}"), C("\\kaBlue", "\\textcolor{##314453}{#1}"), C("\\kaGreen", "\\textcolor{##71B307}{#1}");
          const Hc = {
            "^": true,
            // Parser.js
            _: true,
            // Parser.js
            "\\limits": true,
            // Parser.js
            "\\nolimits": true
            // Parser.js
          };
          class km {
            constructor(u, c, d) {
              this.settings = void 0, this.expansionCount = void 0, this.lexer = void 0, this.macros = void 0, this.stack = void 0, this.mode = void 0, this.settings = c, this.expansionCount = 0, this.feed(u), this.macros = new wm(vm, c.macros), this.mode = d, this.stack = [];
            }
            /**
             * Feed a new input string to the same MacroExpander
             * (with existing macros etc.).
             */
            feed(u) {
              this.lexer = new $c(u, this.settings);
            }
            /**
             * Switches between "text" and "math" modes.
             */
            switchMode(u) {
              this.mode = u;
            }
            /**
             * Start a new group nesting within all namespaces.
             */
            beginGroup() {
              this.macros.beginGroup();
            }
            /**
             * End current group nesting within all namespaces.
             */
            endGroup() {
              this.macros.endGroup();
            }
            /**
             * Ends all currently nested groups (if any), restoring values before the
             * groups began.  Useful in case of an error in the middle of parsing.
             */
            endGroups() {
              this.macros.endGroups();
            }
            /**
             * Returns the topmost token on the stack, without expanding it.
             * Similar in behavior to TeX's `\futurelet`.
             */
            future() {
              return this.stack.length === 0 && this.pushToken(this.lexer.lex()), this.stack[this.stack.length - 1];
            }
            /**
             * Remove and return the next unexpanded token.
             */
            popToken() {
              return this.future(), this.stack.pop();
            }
            /**
             * Add a given token to the token stack.  In particular, this get be used
             * to put back a token returned from one of the other methods.
             */
            pushToken(u) {
              this.stack.push(u);
            }
            /**
             * Append an array of tokens to the token stack.
             */
            pushTokens(u) {
              this.stack.push(...u);
            }
            /**
             * Find an macro argument without expanding tokens and append the array of
             * tokens to the token stack. Uses Token as a container for the result.
             */
            scanArgument(u) {
              let c, d, m;
              if (u) {
                if (this.consumeSpaces(), this.future().text !== "[")
                  return null;
                c = this.popToken(), {
                  tokens: m,
                  end: d
                } = this.consumeArg(["]"]);
              } else
                ({
                  tokens: m,
                  start: c,
                  end: d
                } = this.consumeArg());
              return this.pushToken(new Ht("EOF", d.loc)), this.pushTokens(m), c.range(d, "");
            }
            /**
             * Consume all following space tokens, without expansion.
             */
            consumeSpaces() {
              for (; this.future().text === " "; )
                this.stack.pop();
            }
            /**
             * Consume an argument from the token stream, and return the resulting array
             * of tokens and start/end token.
             */
            consumeArg(u) {
              const c = [], d = u && u.length > 0;
              d || this.consumeSpaces();
              const m = this.future();
              let y, _ = 0, E = 0;
              do {
                if (y = this.popToken(), c.push(y), y.text === "{")
                  ++_;
                else if (y.text === "}") {
                  if (--_, _ === -1)
                    throw new s("Extra }", y);
                } else if (y.text === "EOF")
                  throw new s("Unexpected end of input in a macro argument, expected '" + (u && d ? u[E] : "}") + "'", y);
                if (u && d)
                  if ((_ === 0 || _ === 1 && u[E] === "{") && y.text === u[E]) {
                    if (++E, E === u.length) {
                      c.splice(-E, E);
                      break;
                    }
                  } else
                    E = 0;
              } while (_ !== 0 || d);
              return m.text === "{" && c[c.length - 1].text === "}" && (c.pop(), c.shift()), c.reverse(), {
                tokens: c,
                start: m,
                end: y
              };
            }
            /**
             * Consume the specified number of (delimited) arguments from the token
             * stream and return the resulting array of arguments.
             */
            consumeArgs(u, c) {
              if (c) {
                if (c.length !== u + 1)
                  throw new s("The length of delimiters doesn't match the number of args!");
                const m = c[0];
                for (let y = 0; y < m.length; y++) {
                  const _ = this.popToken();
                  if (m[y] !== _.text)
                    throw new s("Use of the macro doesn't match its definition", _);
                }
              }
              const d = [];
              for (let m = 0; m < u; m++)
                d.push(this.consumeArg(c && c[m + 1]).tokens);
              return d;
            }
            /**
             * Increment `expansionCount` by the specified amount.
             * Throw an error if it exceeds `maxExpand`.
             */
            countExpansion(u) {
              if (this.expansionCount += u, this.expansionCount > this.settings.maxExpand)
                throw new s("Too many expansions: infinite loop or need to increase maxExpand setting");
            }
            /**
             * Expand the next token only once if possible.
             *
             * If the token is expanded, the resulting tokens will be pushed onto
             * the stack in reverse order, and the number of such tokens will be
             * returned.  This number might be zero or positive.
             *
             * If not, the return value is `false`, and the next token remains at the
             * top of the stack.
             *
             * In either case, the next token will be on the top of the stack,
             * or the stack will be empty (in case of empty expansion
             * and no other tokens).
             *
             * Used to implement `expandAfterFuture` and `expandNextToken`.
             *
             * If expandableOnly, only expandable tokens are expanded and
             * an undefined control sequence results in an error.
             */
            expandOnce(u) {
              const c = this.popToken(), d = c.text, m = c.noexpand ? null : this._getExpansion(d);
              if (m == null || u && m.unexpandable) {
                if (u && m == null && d[0] === "\\" && !this.isDefined(d))
                  throw new s("Undefined control sequence: " + d);
                return this.pushToken(c), false;
              }
              this.countExpansion(1);
              let y = m.tokens;
              const _ = this.consumeArgs(m.numArgs, m.delimiters);
              if (m.numArgs) {
                y = y.slice();
                for (let E = y.length - 1; E >= 0; --E) {
                  let M = y[E];
                  if (M.text === "#") {
                    if (E === 0)
                      throw new s("Incomplete placeholder at end of macro body", M);
                    if (M = y[--E], M.text === "#")
                      y.splice(E + 1, 1);
                    else if (/^[1-9]$/.test(M.text))
                      y.splice(E, 2, ..._[+M.text - 1]);
                    else
                      throw new s("Not a valid argument number", M);
                  }
                }
              }
              return this.pushTokens(y), y.length;
            }
            /**
             * Expand the next token only once (if possible), and return the resulting
             * top token on the stack (without removing anything from the stack).
             * Similar in behavior to TeX's `\expandafter\futurelet`.
             * Equivalent to expandOnce() followed by future().
             */
            expandAfterFuture() {
              return this.expandOnce(), this.future();
            }
            /**
             * Recursively expand first token, then return first non-expandable token.
             */
            expandNextToken() {
              for (; ; )
                if (this.expandOnce() === false) {
                  const u = this.stack.pop();
                  return u.treatAsRelax && (u.text = "\\relax"), u;
                }
              throw new Error();
            }
            /**
             * Fully expand the given macro name and return the resulting list of
             * tokens, or return `undefined` if no such macro is defined.
             */
            expandMacro(u) {
              return this.macros.has(u) ? this.expandTokens([new Ht(u)]) : void 0;
            }
            /**
             * Fully expand the given token stream and return the resulting list of
             * tokens.  Note that the input tokens are in reverse order, but the
             * output tokens are in forward order.
             */
            expandTokens(u) {
              const c = [], d = this.stack.length;
              for (this.pushTokens(u); this.stack.length > d; )
                if (this.expandOnce(true) === false) {
                  const m = this.stack.pop();
                  m.treatAsRelax && (m.noexpand = false, m.treatAsRelax = false), c.push(m);
                }
              return this.countExpansion(c.length), c;
            }
            /**
             * Fully expand the given macro name and return the result as a string,
             * or return `undefined` if no such macro is defined.
             */
            expandMacroAsText(u) {
              const c = this.expandMacro(u);
              return c && c.map((d) => d.text).join("");
            }
            /**
             * Returns the expanded macro as a reversed array of tokens and a macro
             * argument count.  Or returns `null` if no such macro.
             */
            _getExpansion(u) {
              const c = this.macros.get(u);
              if (c == null)
                return c;
              if (u.length === 1) {
                const m = this.lexer.catcodes[u];
                if (m != null && m !== 13)
                  return;
              }
              const d = typeof c == "function" ? c(this) : c;
              if (typeof d == "string") {
                let m = 0;
                if (d.indexOf("#") !== -1) {
                  const B = d.replace(/##/g, "");
                  for (; B.indexOf("#" + (m + 1)) !== -1; )
                    ++m;
                }
                const y = new $c(d, this.settings), _ = [];
                let E = y.lex();
                for (; E.text !== "EOF"; )
                  _.push(E), E = y.lex();
                return _.reverse(), {
                  tokens: _,
                  numArgs: m
                };
              }
              return d;
            }
            /**
             * Determine whether a command is currently "defined" (has some
             * functionality), meaning that it's a macro (in the current group),
             * a function, a symbol, or one of the special commands listed in
             * `implicitCommands`.
             */
            isDefined(u) {
              return this.macros.has(u) || Hn.hasOwnProperty(u) || et.math.hasOwnProperty(u) || et.text.hasOwnProperty(u) || Hc.hasOwnProperty(u);
            }
            /**
             * Determine whether a command is expandable.
             */
            isExpandable(u) {
              const c = this.macros.get(u);
              return c != null ? typeof c == "string" || typeof c == "function" || !c.unexpandable : Hn.hasOwnProperty(u) && !Hn[u].primitive;
            }
          }
          const jc = /^[â‚Šâ‚‹â‚Œâ‚â‚â‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰â‚â‚‘â‚•áµ¢â±¼â‚–â‚—â‚˜â‚™â‚’â‚šáµ£â‚›â‚œáµ¤áµ¥â‚“áµ¦áµ§áµ¨áµ©áµª]/, Ds = Object.freeze({
            "â‚Š": "+",
            "â‚‹": "-",
            "â‚Œ": "=",
            "â‚": "(",
            "â‚": ")",
            "â‚€": "0",
            "â‚": "1",
            "â‚‚": "2",
            "â‚ƒ": "3",
            "â‚„": "4",
            "â‚…": "5",
            "â‚†": "6",
            "â‚‡": "7",
            "â‚ˆ": "8",
            "â‚‰": "9",
            "â‚": "a",
            "â‚‘": "e",
            "â‚•": "h",
            "áµ¢": "i",
            "â±¼": "j",
            "â‚–": "k",
            "â‚—": "l",
            "â‚˜": "m",
            "â‚™": "n",
            "â‚’": "o",
            "â‚š": "p",
            "áµ£": "r",
            "â‚›": "s",
            "â‚œ": "t",
            "áµ¤": "u",
            "áµ¥": "v",
            "â‚“": "x",
            "áµ¦": "Î²",
            "áµ§": "Î³",
            "áµ¨": "Ï",
            "áµ©": "Ï•",
            "áµª": "Ï‡",
            "âº": "+",
            "â»": "-",
            "â¼": "=",
            "â½": "(",
            "â¾": ")",
            "â°": "0",
            "Â¹": "1",
            "Â²": "2",
            "Â³": "3",
            "â´": "4",
            "âµ": "5",
            "â¶": "6",
            "â·": "7",
            "â¸": "8",
            "â¹": "9",
            "á´¬": "A",
            "á´®": "B",
            "á´°": "D",
            "á´±": "E",
            "á´³": "G",
            "á´´": "H",
            "á´µ": "I",
            "á´¶": "J",
            "á´·": "K",
            "á´¸": "L",
            "á´¹": "M",
            "á´º": "N",
            "á´¼": "O",
            "á´¾": "P",
            "á´¿": "R",
            "áµ€": "T",
            "áµ": "U",
            "â±½": "V",
            "áµ‚": "W",
            "áµƒ": "a",
            "áµ‡": "b",
            "á¶œ": "c",
            "áµˆ": "d",
            "áµ‰": "e",
            "á¶ ": "f",
            "áµ": "g",
            Ê°: "h",
            "â±": "i",
            Ê²: "j",
            "áµ": "k",
            Ë¡: "l",
            "áµ": "m",
            â¿: "n",
            "áµ’": "o",
            "áµ–": "p",
            Ê³: "r",
            Ë¢: "s",
            "áµ—": "t",
            "áµ˜": "u",
            "áµ›": "v",
            Ê·: "w",
            Ë£: "x",
            Ê¸: "y",
            "á¶»": "z",
            "áµ": "Î²",
            "áµ": "Î³",
            "áµŸ": "Î´",
            "áµ ": "Ï•",
            "áµ¡": "Ï‡",
            "á¶¿": "Î¸"
          }), Hu = {
            "Ì": {
              text: "\\'",
              math: "\\acute"
            },
            "Ì€": {
              text: "\\`",
              math: "\\grave"
            },
            "Ìˆ": {
              text: '\\"',
              math: "\\ddot"
            },
            "Ìƒ": {
              text: "\\~",
              math: "\\tilde"
            },
            "Ì„": {
              text: "\\=",
              math: "\\bar"
            },
            "Ì†": {
              text: "\\u",
              math: "\\breve"
            },
            "ÌŒ": {
              text: "\\v",
              math: "\\check"
            },
            "Ì‚": {
              text: "\\^",
              math: "\\hat"
            },
            "Ì‡": {
              text: "\\.",
              math: "\\dot"
            },
            "ÌŠ": {
              text: "\\r",
              math: "\\mathring"
            },
            "Ì‹": {
              text: "\\H"
            },
            "Ì§": {
              text: "\\c"
            }
          }, Uc = {
            Ã¡: "aÌ",
            Ã : "aÌ€",
            Ã¤: "aÌˆ",
            ÇŸ: "aÌˆÌ„",
            Ã£: "aÌƒ",
            Ä: "aÌ„",
            Äƒ: "aÌ†",
            áº¯: "aÌ†Ì",
            áº±: "aÌ†Ì€",
            áºµ: "aÌ†Ìƒ",
            Ç: "aÌŒ",
            Ã¢: "aÌ‚",
            áº¥: "aÌ‚Ì",
            áº§: "aÌ‚Ì€",
            áº«: "aÌ‚Ìƒ",
            È§: "aÌ‡",
            Ç¡: "aÌ‡Ì„",
            Ã¥: "aÌŠ",
            Ç»: "aÌŠÌ",
            á¸ƒ: "bÌ‡",
            Ä‡: "cÌ",
            á¸‰: "cÌ§Ì",
            Ä: "cÌŒ",
            Ä‰: "cÌ‚",
            Ä‹: "cÌ‡",
            Ã§: "cÌ§",
            Ä: "dÌŒ",
            á¸‹: "dÌ‡",
            á¸‘: "dÌ§",
            Ã©: "eÌ",
            Ã¨: "eÌ€",
            Ã«: "eÌˆ",
            áº½: "eÌƒ",
            Ä“: "eÌ„",
            á¸—: "eÌ„Ì",
            á¸•: "eÌ„Ì€",
            Ä•: "eÌ†",
            á¸: "eÌ§Ì†",
            Ä›: "eÌŒ",
            Ãª: "eÌ‚",
            áº¿: "eÌ‚Ì",
            á»: "eÌ‚Ì€",
            á»…: "eÌ‚Ìƒ",
            Ä—: "eÌ‡",
            È©: "eÌ§",
            á¸Ÿ: "fÌ‡",
            Çµ: "gÌ",
            á¸¡: "gÌ„",
            ÄŸ: "gÌ†",
            Ç§: "gÌŒ",
            Ä: "gÌ‚",
            Ä¡: "gÌ‡",
            Ä£: "gÌ§",
            á¸§: "hÌˆ",
            ÈŸ: "hÌŒ",
            Ä¥: "hÌ‚",
            á¸£: "hÌ‡",
            á¸©: "hÌ§",
            Ã­: "iÌ",
            Ã¬: "iÌ€",
            Ã¯: "iÌˆ",
            á¸¯: "iÌˆÌ",
            Ä©: "iÌƒ",
            Ä«: "iÌ„",
            Ä­: "iÌ†",
            Ç: "iÌŒ",
            Ã®: "iÌ‚",
            Ç°: "jÌŒ",
            Äµ: "jÌ‚",
            á¸±: "kÌ",
            Ç©: "kÌŒ",
            Ä·: "kÌ§",
            Äº: "lÌ",
            Ä¾: "lÌŒ",
            Ä¼: "lÌ§",
            á¸¿: "mÌ",
            á¹: "mÌ‡",
            Å„: "nÌ",
            Ç¹: "nÌ€",
            Ã±: "nÌƒ",
            Åˆ: "nÌŒ",
            á¹…: "nÌ‡",
            Å†: "nÌ§",
            Ã³: "oÌ",
            Ã²: "oÌ€",
            Ã¶: "oÌˆ",
            È«: "oÌˆÌ„",
            Ãµ: "oÌƒ",
            á¹: "oÌƒÌ",
            á¹: "oÌƒÌˆ",
            È­: "oÌƒÌ„",
            Å: "oÌ„",
            á¹“: "oÌ„Ì",
            á¹‘: "oÌ„Ì€",
            Å: "oÌ†",
            Ç’: "oÌŒ",
            Ã´: "oÌ‚",
            á»‘: "oÌ‚Ì",
            á»“: "oÌ‚Ì€",
            á»—: "oÌ‚Ìƒ",
            È¯: "oÌ‡",
            È±: "oÌ‡Ì„",
            Å‘: "oÌ‹",
            á¹•: "pÌ",
            á¹—: "pÌ‡",
            Å•: "rÌ",
            Å™: "rÌŒ",
            á¹™: "rÌ‡",
            Å—: "rÌ§",
            Å›: "sÌ",
            á¹¥: "sÌÌ‡",
            Å¡: "sÌŒ",
            á¹§: "sÌŒÌ‡",
            Å: "sÌ‚",
            á¹¡: "sÌ‡",
            ÅŸ: "sÌ§",
            áº—: "tÌˆ",
            Å¥: "tÌŒ",
            á¹«: "tÌ‡",
            Å£: "tÌ§",
            Ãº: "uÌ",
            Ã¹: "uÌ€",
            Ã¼: "uÌˆ",
            Ç˜: "uÌˆÌ",
            Çœ: "uÌˆÌ€",
            Ç–: "uÌˆÌ„",
            Çš: "uÌˆÌŒ",
            Å©: "uÌƒ",
            á¹¹: "uÌƒÌ",
            Å«: "uÌ„",
            á¹»: "uÌ„Ìˆ",
            Å­: "uÌ†",
            Ç”: "uÌŒ",
            Ã»: "uÌ‚",
            Å¯: "uÌŠ",
            Å±: "uÌ‹",
            á¹½: "vÌƒ",
            áºƒ: "wÌ",
            áº: "wÌ€",
            áº…: "wÌˆ",
            Åµ: "wÌ‚",
            áº‡: "wÌ‡",
            áº˜: "wÌŠ",
            áº: "xÌˆ",
            áº‹: "xÌ‡",
            Ã½: "yÌ",
            á»³: "yÌ€",
            Ã¿: "yÌˆ",
            á»¹: "yÌƒ",
            È³: "yÌ„",
            Å·: "yÌ‚",
            áº: "yÌ‡",
            áº™: "yÌŠ",
            Åº: "zÌ",
            Å¾: "zÌŒ",
            áº‘: "zÌ‚",
            Å¼: "zÌ‡",
            Ã: "AÌ",
            Ã€: "AÌ€",
            Ã„: "AÌˆ",
            Ç: "AÌˆÌ„",
            Ãƒ: "AÌƒ",
            Ä€: "AÌ„",
            Ä‚: "AÌ†",
            áº®: "AÌ†Ì",
            áº°: "AÌ†Ì€",
            áº´: "AÌ†Ìƒ",
            Ç: "AÌŒ",
            Ã‚: "AÌ‚",
            áº¤: "AÌ‚Ì",
            áº¦: "AÌ‚Ì€",
            áºª: "AÌ‚Ìƒ",
            È¦: "AÌ‡",
            Ç : "AÌ‡Ì„",
            Ã…: "AÌŠ",
            Çº: "AÌŠÌ",
            á¸‚: "BÌ‡",
            Ä†: "CÌ",
            á¸ˆ: "CÌ§Ì",
            ÄŒ: "CÌŒ",
            Äˆ: "CÌ‚",
            ÄŠ: "CÌ‡",
            Ã‡: "CÌ§",
            Ä: "DÌŒ",
            á¸Š: "DÌ‡",
            á¸: "DÌ§",
            Ã‰: "EÌ",
            Ãˆ: "EÌ€",
            Ã‹: "EÌˆ",
            áº¼: "EÌƒ",
            Ä’: "EÌ„",
            á¸–: "EÌ„Ì",
            á¸”: "EÌ„Ì€",
            Ä”: "EÌ†",
            á¸œ: "EÌ§Ì†",
            Äš: "EÌŒ",
            ÃŠ: "EÌ‚",
            áº¾: "EÌ‚Ì",
            á»€: "EÌ‚Ì€",
            á»„: "EÌ‚Ìƒ",
            Ä–: "EÌ‡",
            È¨: "EÌ§",
            á¸: "FÌ‡",
            Ç´: "GÌ",
            á¸ : "GÌ„",
            Ä: "GÌ†",
            Ç¦: "GÌŒ",
            Äœ: "GÌ‚",
            Ä : "GÌ‡",
            Ä¢: "GÌ§",
            á¸¦: "HÌˆ",
            È: "HÌŒ",
            Ä¤: "HÌ‚",
            á¸¢: "HÌ‡",
            á¸¨: "HÌ§",
            Ã: "IÌ",
            ÃŒ: "IÌ€",
            Ã: "IÌˆ",
            á¸®: "IÌˆÌ",
            Ä¨: "IÌƒ",
            Äª: "IÌ„",
            Ä¬: "IÌ†",
            Ç: "IÌŒ",
            Ã: "IÌ‚",
            Ä°: "IÌ‡",
            Ä´: "JÌ‚",
            á¸°: "KÌ",
            Ç¨: "KÌŒ",
            Ä¶: "KÌ§",
            Ä¹: "LÌ",
            Ä½: "LÌŒ",
            Ä»: "LÌ§",
            á¸¾: "MÌ",
            á¹€: "MÌ‡",
            Åƒ: "NÌ",
            Ç¸: "NÌ€",
            Ã‘: "NÌƒ",
            Å‡: "NÌŒ",
            á¹„: "NÌ‡",
            Å…: "NÌ§",
            Ã“: "OÌ",
            Ã’: "OÌ€",
            Ã–: "OÌˆ",
            Èª: "OÌˆÌ„",
            Ã•: "OÌƒ",
            á¹Œ: "OÌƒÌ",
            á¹: "OÌƒÌˆ",
            È¬: "OÌƒÌ„",
            ÅŒ: "OÌ„",
            á¹’: "OÌ„Ì",
            á¹: "OÌ„Ì€",
            Å: "OÌ†",
            Ç‘: "OÌŒ",
            Ã”: "OÌ‚",
            á»: "OÌ‚Ì",
            á»’: "OÌ‚Ì€",
            á»–: "OÌ‚Ìƒ",
            È®: "OÌ‡",
            È°: "OÌ‡Ì„",
            Å: "OÌ‹",
            á¹”: "PÌ",
            á¹–: "PÌ‡",
            Å”: "RÌ",
            Å˜: "RÌŒ",
            á¹˜: "RÌ‡",
            Å–: "RÌ§",
            Åš: "SÌ",
            á¹¤: "SÌÌ‡",
            Å : "SÌŒ",
            á¹¦: "SÌŒÌ‡",
            Åœ: "SÌ‚",
            á¹ : "SÌ‡",
            Å: "SÌ§",
            Å¤: "TÌŒ",
            á¹ª: "TÌ‡",
            Å¢: "TÌ§",
            Ãš: "UÌ",
            Ã™: "UÌ€",
            Ãœ: "UÌˆ",
            Ç—: "UÌˆÌ",
            Ç›: "UÌˆÌ€",
            Ç•: "UÌˆÌ„",
            Ç™: "UÌˆÌŒ",
            Å¨: "UÌƒ",
            á¹¸: "UÌƒÌ",
            Åª: "UÌ„",
            á¹º: "UÌ„Ìˆ",
            Å¬: "UÌ†",
            Ç“: "UÌŒ",
            Ã›: "UÌ‚",
            Å®: "UÌŠ",
            Å°: "UÌ‹",
            á¹¼: "VÌƒ",
            áº‚: "WÌ",
            áº€: "WÌ€",
            áº„: "WÌˆ",
            Å´: "WÌ‚",
            áº†: "WÌ‡",
            áºŒ: "XÌˆ",
            áºŠ: "XÌ‡",
            Ã: "YÌ",
            á»²: "YÌ€",
            Å¸: "YÌˆ",
            á»¸: "YÌƒ",
            È²: "YÌ„",
            Å¶: "YÌ‚",
            áº: "YÌ‡",
            Å¹: "ZÌ",
            Å½: "ZÌŒ",
            áº: "ZÌ‚",
            Å»: "ZÌ‡",
            Î¬: "Î±Ì",
            á½°: "Î±Ì€",
            á¾±: "Î±Ì„",
            á¾°: "Î±Ì†",
            Î­: "ÎµÌ",
            á½²: "ÎµÌ€",
            Î®: "Î·Ì",
            á½´: "Î·Ì€",
            Î¯: "Î¹Ì",
            á½¶: "Î¹Ì€",
            ÏŠ: "Î¹Ìˆ",
            Î: "Î¹ÌˆÌ",
            á¿’: "Î¹ÌˆÌ€",
            á¿‘: "Î¹Ì„",
            á¿: "Î¹Ì†",
            ÏŒ: "Î¿Ì",
            á½¸: "Î¿Ì€",
            Ï: "Ï…Ì",
            á½º: "Ï…Ì€",
            Ï‹: "Ï…Ìˆ",
            Î°: "Ï…ÌˆÌ",
            á¿¢: "Ï…ÌˆÌ€",
            á¿¡: "Ï…Ì„",
            á¿ : "Ï…Ì†",
            Ï: "Ï‰Ì",
            á½¼: "Ï‰Ì€",
            Î: "Î¥Ì",
            á¿ª: "Î¥Ì€",
            Î«: "Î¥Ìˆ",
            á¿©: "Î¥Ì„",
            á¿¨: "Î¥Ì†",
            Î: "Î©Ì",
            á¿º: "Î©Ì€"
          };
          class Ms {
            constructor(u, c) {
              this.mode = void 0, this.gullet = void 0, this.settings = void 0, this.leftrightDepth = void 0, this.nextToken = void 0, this.mode = "math", this.gullet = new km(u, c, this.mode), this.settings = c, this.leftrightDepth = 0;
            }
            /**
             * Checks a result to make sure it has the right type, and throws an
             * appropriate error otherwise.
             */
            expect(u, c) {
              if (c === void 0 && (c = true), this.fetch().text !== u)
                throw new s("Expected '" + u + "', got '" + this.fetch().text + "'", this.fetch());
              c && this.consume();
            }
            /**
             * Discards the current lookahead token, considering it consumed.
             */
            consume() {
              this.nextToken = null;
            }
            /**
             * Return the current lookahead token, or if there isn't one (at the
             * beginning, or if the previous lookahead token was consume()d),
             * fetch the next token as the new lookahead token and return it.
             */
            fetch() {
              return this.nextToken == null && (this.nextToken = this.gullet.expandNextToken()), this.nextToken;
            }
            /**
             * Switches between "text" and "math" modes.
             */
            switchMode(u) {
              this.mode = u, this.gullet.switchMode(u);
            }
            /**
             * Main parsing function, which parses an entire input.
             */
            parse() {
              this.settings.globalGroup || this.gullet.beginGroup(), this.settings.colorIsTextColor && this.gullet.macros.set("\\color", "\\textcolor");
              try {
                const u = this.parseExpression(false);
                return this.expect("EOF"), this.settings.globalGroup || this.gullet.endGroup(), u;
              } finally {
                this.gullet.endGroups();
              }
            }
            /**
             * Fully parse a separate sequence of tokens as a separate job.
             * Tokens should be specified in reverse order, as in a MacroDefinition.
             */
            subparse(u) {
              const c = this.nextToken;
              this.consume(), this.gullet.pushToken(new Ht("}")), this.gullet.pushTokens(u);
              const d = this.parseExpression(false);
              return this.expect("}"), this.nextToken = c, d;
            }
            /**
             * Parses an "expression", which is a list of atoms.
             *
             * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
             *                 happens when functions have higher precedence han infix
             *                 nodes in implicit parses.
             *
             * `breakOnTokenText`: The text of the token that the expression should end
             *                     with, or `null` if something else should end the
             *                     expression.
             */
            parseExpression(u, c) {
              const d = [];
              for (; ; ) {
                this.mode === "math" && this.consumeSpaces();
                const m = this.fetch();
                if (Ms.endOfExpression.indexOf(m.text) !== -1 || c && m.text === c || u && Hn[m.text] && Hn[m.text].infix)
                  break;
                const y = this.parseAtom(c);
                if (y) {
                  if (y.type === "internal")
                    continue;
                } else break;
                d.push(y);
              }
              return this.mode === "text" && this.formLigatures(d), this.handleInfixNodes(d);
            }
            /**
             * Rewrites infix operators such as \over with corresponding commands such
             * as \frac.
             *
             * There can only be one infix operator per group.  If there's more than one
             * then the expression is ambiguous.  This can be resolved by adding {}.
             */
            handleInfixNodes(u) {
              let c = -1, d;
              for (let m = 0; m < u.length; m++)
                if (u[m].type === "infix") {
                  if (c !== -1)
                    throw new s("only one infix operator per group", u[m].token);
                  c = m, d = u[m].replaceWith;
                }
              if (c !== -1 && d) {
                let m, y;
                const _ = u.slice(0, c), E = u.slice(c + 1);
                _.length === 1 && _[0].type === "ordgroup" ? m = _[0] : m = {
                  type: "ordgroup",
                  mode: this.mode,
                  body: _
                }, E.length === 1 && E[0].type === "ordgroup" ? y = E[0] : y = {
                  type: "ordgroup",
                  mode: this.mode,
                  body: E
                };
                let M;
                return d === "\\\\abovefrac" ? M = this.callFunction(d, [m, u[c], y], []) : M = this.callFunction(d, [m, y], []), [M];
              } else
                return u;
            }
            /**
             * Handle a subscript or superscript with nice errors.
             */
            handleSupSubscript(u) {
              const c = this.fetch(), d = c.text;
              this.consume(), this.consumeSpaces();
              let m;
              do {
                var y;
                m = this.parseGroup(u);
              } while (((y = m) == null ? void 0 : y.type) === "internal");
              if (!m)
                throw new s("Expected group after '" + d + "'", c);
              return m;
            }
            /**
             * Converts the textual input of an unsupported command into a text node
             * contained within a color node whose color is determined by errorColor
             */
            formatUnsupportedCmd(u) {
              const c = [];
              for (let y = 0; y < u.length; y++)
                c.push({
                  type: "textord",
                  mode: "text",
                  text: u[y]
                });
              const d = {
                type: "text",
                mode: this.mode,
                body: c
              };
              return {
                type: "color",
                mode: this.mode,
                color: this.settings.errorColor,
                body: [d]
              };
            }
            /**
             * Parses a group with optional super/subscripts.
             */
            parseAtom(u) {
              const c = this.parseGroup("atom", u);
              if ((c == null ? void 0 : c.type) === "internal" || this.mode === "text")
                return c;
              let d, m;
              for (; ; ) {
                this.consumeSpaces();
                const y = this.fetch();
                if (y.text === "\\limits" || y.text === "\\nolimits") {
                  if (c && c.type === "op") {
                    const _ = y.text === "\\limits";
                    c.limits = _, c.alwaysHandleSupSub = true;
                  } else if (c && c.type === "operatorname")
                    c.alwaysHandleSupSub && (c.limits = y.text === "\\limits");
                  else
                    throw new s("Limit controls must follow a math operator", y);
                  this.consume();
                } else if (y.text === "^") {
                  if (d)
                    throw new s("Double superscript", y);
                  d = this.handleSupSubscript("superscript");
                } else if (y.text === "_") {
                  if (m)
                    throw new s("Double subscript", y);
                  m = this.handleSupSubscript("subscript");
                } else if (y.text === "'") {
                  if (d)
                    throw new s("Double superscript", y);
                  const _ = {
                    type: "textord",
                    mode: this.mode,
                    text: "\\prime"
                  }, E = [_];
                  for (this.consume(); this.fetch().text === "'"; )
                    E.push(_), this.consume();
                  this.fetch().text === "^" && E.push(this.handleSupSubscript("superscript")), d = {
                    type: "ordgroup",
                    mode: this.mode,
                    body: E
                  };
                } else if (Ds[y.text]) {
                  const _ = jc.test(y.text), E = [];
                  for (E.push(new Ht(Ds[y.text])), this.consume(); ; ) {
                    const B = this.fetch().text;
                    if (!Ds[B] || jc.test(B) !== _)
                      break;
                    E.unshift(new Ht(Ds[B])), this.consume();
                  }
                  const M = this.subparse(E);
                  _ ? m = {
                    type: "ordgroup",
                    mode: "math",
                    body: M
                  } : d = {
                    type: "ordgroup",
                    mode: "math",
                    body: M
                  };
                } else
                  break;
              }
              return d || m ? {
                type: "supsub",
                mode: this.mode,
                base: c,
                sup: d,
                sub: m
              } : c;
            }
            /**
             * Parses an entire function, including its base and all of its arguments.
             */
            parseFunction(u, c) {
              const d = this.fetch(), m = d.text, y = Hn[m];
              if (!y)
                return null;
              if (this.consume(), c && c !== "atom" && !y.allowedInArgument)
                throw new s("Got function '" + m + "' with no arguments" + (c ? " as " + c : ""), d);
              if (this.mode === "text" && !y.allowedInText)
                throw new s("Can't use function '" + m + "' in text mode", d);
              if (this.mode === "math" && y.allowedInMath === false)
                throw new s("Can't use function '" + m + "' in math mode", d);
              const {
                args: _,
                optArgs: E
              } = this.parseArguments(m, y);
              return this.callFunction(m, _, E, d, u);
            }
            /**
             * Call a function handler with a suitable context and arguments.
             */
            callFunction(u, c, d, m, y) {
              const _ = {
                funcName: u,
                parser: this,
                token: m,
                breakOnTokenText: y
              }, E = Hn[u];
              if (E && E.handler)
                return E.handler(_, c, d);
              throw new s("No function handler for " + u);
            }
            /**
             * Parses the arguments of a function or environment
             */
            parseArguments(u, c) {
              const d = c.numArgs + c.numOptionalArgs;
              if (d === 0)
                return {
                  args: [],
                  optArgs: []
                };
              const m = [], y = [];
              for (let _ = 0; _ < d; _++) {
                let E = c.argTypes && c.argTypes[_];
                const M = _ < c.numOptionalArgs;
                (c.primitive && E == null || // \sqrt expands into primitive if optional argument doesn't exist
                c.type === "sqrt" && _ === 1 && y[0] == null) && (E = "primitive");
                const B = this.parseGroupOfType("argument to '" + u + "'", E, M);
                if (M)
                  y.push(B);
                else if (B != null)
                  m.push(B);
                else
                  throw new s("Null argument, please report this as a bug");
              }
              return {
                args: m,
                optArgs: y
              };
            }
            /**
             * Parses a group when the mode is changing.
             */
            parseGroupOfType(u, c, d) {
              switch (c) {
                case "color":
                  return this.parseColorGroup(d);
                case "size":
                  return this.parseSizeGroup(d);
                case "url":
                  return this.parseUrlGroup(d);
                case "math":
                case "text":
                  return this.parseArgumentGroup(d, c);
                case "hbox": {
                  const m = this.parseArgumentGroup(d, "text");
                  return m != null ? {
                    type: "styling",
                    mode: m.mode,
                    body: [m],
                    style: "text"
                    // simulate \textstyle
                  } : null;
                }
                case "raw": {
                  const m = this.parseStringGroup("raw", d);
                  return m != null ? {
                    type: "raw",
                    mode: "text",
                    string: m.text
                  } : null;
                }
                case "primitive": {
                  if (d)
                    throw new s("A primitive argument cannot be optional");
                  const m = this.parseGroup(u);
                  if (m == null)
                    throw new s("Expected group as " + u, this.fetch());
                  return m;
                }
                case "original":
                case null:
                case void 0:
                  return this.parseArgumentGroup(d);
                default:
                  throw new s("Unknown group type as " + u, this.fetch());
              }
            }
            /**
             * Discard any space tokens, fetching the next non-space token.
             */
            consumeSpaces() {
              for (; this.fetch().text === " "; )
                this.consume();
            }
            /**
             * Parses a group, essentially returning the string formed by the
             * brace-enclosed tokens plus some position information.
             */
            parseStringGroup(u, c) {
              const d = this.gullet.scanArgument(c);
              if (d == null)
                return null;
              let m = "", y;
              for (; (y = this.fetch()).text !== "EOF"; )
                m += y.text, this.consume();
              return this.consume(), d.text = m, d;
            }
            /**
             * Parses a regex-delimited group: the largest sequence of tokens
             * whose concatenated strings match `regex`. Returns the string
             * formed by the tokens plus some position information.
             */
            parseRegexGroup(u, c) {
              const d = this.fetch();
              let m = d, y = "", _;
              for (; (_ = this.fetch()).text !== "EOF" && u.test(y + _.text); )
                m = _, y += m.text, this.consume();
              if (y === "")
                throw new s("Invalid " + c + ": '" + d.text + "'", d);
              return d.range(m, y);
            }
            /**
             * Parses a color description.
             */
            parseColorGroup(u) {
              const c = this.parseStringGroup("color", u);
              if (c == null)
                return null;
              const d = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(c.text);
              if (!d)
                throw new s("Invalid color: '" + c.text + "'", c);
              let m = d[0];
              return /^[0-9a-f]{6}$/i.test(m) && (m = "#" + m), {
                type: "color-token",
                mode: this.mode,
                color: m
              };
            }
            /**
             * Parses a size specification, consisting of magnitude and unit.
             */
            parseSizeGroup(u) {
              let c, d = false;
              if (this.gullet.consumeSpaces(), !u && this.gullet.future().text !== "{" ? c = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size") : c = this.parseStringGroup("size", u), !c)
                return null;
              !u && c.text.length === 0 && (c.text = "0pt", d = true);
              const m = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(c.text);
              if (!m)
                throw new s("Invalid size: '" + c.text + "'", c);
              const y = {
                number: +(m[1] + m[2]),
                // sign + magnitude, cast to number
                unit: m[3]
              };
              if (!Cl(y))
                throw new s("Invalid unit: '" + y.unit + "'", c);
              return {
                type: "size",
                mode: this.mode,
                value: y,
                isBlank: d
              };
            }
            /**
             * Parses an URL, checking escaped letters and allowed protocols,
             * and setting the catcode of % as an active character (as in \hyperref).
             */
            parseUrlGroup(u) {
              this.gullet.lexer.setCatcode("%", 13), this.gullet.lexer.setCatcode("~", 12);
              const c = this.parseStringGroup("url", u);
              if (this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), c == null)
                return null;
              const d = c.text.replace(/\\([#$%&~_^{}])/g, "$1");
              return {
                type: "url",
                mode: this.mode,
                url: d
              };
            }
            /**
             * Parses an argument with the mode specified.
             */
            parseArgumentGroup(u, c) {
              const d = this.gullet.scanArgument(u);
              if (d == null)
                return null;
              const m = this.mode;
              c && this.switchMode(c), this.gullet.beginGroup();
              const y = this.parseExpression(false, "EOF");
              this.expect("EOF"), this.gullet.endGroup();
              const _ = {
                type: "ordgroup",
                mode: this.mode,
                loc: d.loc,
                body: y
              };
              return c && this.switchMode(m), _;
            }
            /**
             * Parses an ordinary group, which is either a single nucleus (like "x")
             * or an expression in braces (like "{x+y}") or an implicit group, a group
             * that starts at the current position, and ends right before a higher explicit
             * group ends, or at EOF.
             */
            parseGroup(u, c) {
              const d = this.fetch(), m = d.text;
              let y;
              if (m === "{" || m === "\\begingroup") {
                this.consume();
                const _ = m === "{" ? "}" : "\\endgroup";
                this.gullet.beginGroup();
                const E = this.parseExpression(false, _), M = this.fetch();
                this.expect(_), this.gullet.endGroup(), y = {
                  type: "ordgroup",
                  mode: this.mode,
                  loc: Ot.range(d, M),
                  body: E,
                  // A group formed by \begingroup...\endgroup is a semi-simple group
                  // which doesn't affect spacing in math mode, i.e., is transparent.
                  // https://tex.stackexchange.com/questions/1930/when-should-one-
                  // use-begingroup-instead-of-bgroup
                  semisimple: m === "\\begingroup" || void 0
                };
              } else if (y = this.parseFunction(c, u) || this.parseSymbol(), y == null && m[0] === "\\" && !Hc.hasOwnProperty(m)) {
                if (this.settings.throwOnError)
                  throw new s("Undefined control sequence: " + m, d);
                y = this.formatUnsupportedCmd(m), this.consume();
              }
              return y;
            }
            /**
             * Form ligature-like combinations of characters for text mode.
             * This includes inputs like "--", "---", "``" and "''".
             * The result will simply replace multiple textord nodes with a single
             * character in each value by a single textord node having multiple
             * characters in its value.  The representation is still ASCII source.
             * The group will be modified in place.
             */
            formLigatures(u) {
              let c = u.length - 1;
              for (let d = 0; d < c; ++d) {
                const m = u[d], y = m.text;
                y === "-" && u[d + 1].text === "-" && (d + 1 < c && u[d + 2].text === "-" ? (u.splice(d, 3, {
                  type: "textord",
                  mode: "text",
                  loc: Ot.range(m, u[d + 2]),
                  text: "---"
                }), c -= 2) : (u.splice(d, 2, {
                  type: "textord",
                  mode: "text",
                  loc: Ot.range(m, u[d + 1]),
                  text: "--"
                }), c -= 1)), (y === "'" || y === "`") && u[d + 1].text === y && (u.splice(d, 2, {
                  type: "textord",
                  mode: "text",
                  loc: Ot.range(m, u[d + 1]),
                  text: y + y
                }), c -= 1);
              }
            }
            /**
             * Parse a single symbol out of the string. Here, we handle single character
             * symbols and special functions like \verb.
             */
            parseSymbol() {
              const u = this.fetch();
              let c = u.text;
              if (/^\\verb[^a-zA-Z]/.test(c)) {
                this.consume();
                let y = c.slice(5);
                const _ = y.charAt(0) === "*";
                if (_ && (y = y.slice(1)), y.length < 2 || y.charAt(0) !== y.slice(-1))
                  throw new s(`\\verb assertion failed --
                    please report what input caused this bug`);
                return y = y.slice(1, -1), {
                  type: "verb",
                  mode: "text",
                  body: y,
                  star: _
                };
              }
              Uc.hasOwnProperty(c[0]) && !et[this.mode][c[0]] && (this.settings.strict && this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + c[0] + '" used in math mode', u), c = Uc[c[0]] + c.slice(1));
              const d = ym.exec(c);
              d && (c = c.substring(0, d.index), c === "i" ? c = "Ä±" : c === "j" && (c = "È·"));
              let m;
              if (et[this.mode][c]) {
                this.settings.strict && this.mode === "math" && fu.indexOf(c) >= 0 && this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + c[0] + '" used in math mode', u);
                const y = et[this.mode][c].group, _ = Ot.range(u);
                let E;
                if (y2.hasOwnProperty(y)) {
                  const M = y;
                  E = {
                    type: "atom",
                    mode: this.mode,
                    family: M,
                    loc: _,
                    text: c
                  };
                } else
                  E = {
                    type: y,
                    mode: this.mode,
                    loc: _,
                    text: c
                  };
                m = E;
              } else if (c.charCodeAt(0) >= 128)
                this.settings.strict && (De(c.charCodeAt(0)) ? this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + c[0] + '" used in math mode', u) : this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + c[0] + '"' + (" (" + c.charCodeAt(0) + ")"), u)), m = {
                  type: "textord",
                  mode: "text",
                  loc: Ot.range(u),
                  text: c
                };
              else
                return null;
              if (this.consume(), d)
                for (let y = 0; y < d[0].length; y++) {
                  const _ = d[0][y];
                  if (!Hu[_])
                    throw new s("Unknown accent ' " + _ + "'", u);
                  const E = Hu[_][this.mode] || Hu[_].text;
                  if (!E)
                    throw new s("Accent " + _ + " unsupported in " + this.mode + " mode", u);
                  m = {
                    type: "accent",
                    mode: this.mode,
                    loc: Ot.range(u),
                    label: E,
                    isStretchy: false,
                    isShifty: true,
                    // $FlowFixMe
                    base: m
                  };
                }
              return m;
            }
          }
          Ms.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
          var ju = function(a, u) {
            if (!(typeof a == "string" || a instanceof String))
              throw new TypeError("KaTeX can only parse string typed expression");
            const c = new Ms(a, u);
            delete c.gullet.macros.current["\\df@tag"];
            let d = c.parse();
            if (delete c.gullet.macros.current["\\current@color"], delete c.gullet.macros.current["\\color"], c.gullet.macros.get("\\df@tag")) {
              if (!u.displayMode)
                throw new s("\\tag works only in display equations");
              d = [{
                type: "tag",
                mode: "text",
                body: d,
                tag: c.subparse([new Ht("\\df@tag")])
              }];
            }
            return d;
          };
          let Vc = function(a, u, c) {
            u.textContent = "";
            const d = Uu(a, c).toNode();
            u.appendChild(d);
          };
          typeof document < "u" && document.compatMode !== "CSS1Compat" && (typeof console < "u" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."), Vc = function() {
            throw new s("KaTeX doesn't work in quirks mode.");
          });
          const _m = function(a, u) {
            return Uu(a, u).toMarkup();
          }, Sm = function(a, u) {
            const c = new q(u);
            return ju(a, c);
          }, Gc = function(a, u, c) {
            if (c.throwOnError || !(a instanceof s))
              throw a;
            const d = G.makeSpan(["katex-error"], [new Rt(u)]);
            return d.setAttribute("title", a.toString()), d.setAttribute("style", "color:" + c.errorColor), d;
          }, Uu = function(a, u) {
            const c = new q(u);
            try {
              const d = ju(a, c);
              return q2(d, a, c);
            } catch (d) {
              return Gc(d, a, c);
            }
          };
          var Am = {
            /**
             * Current KaTeX version
             */
            version: "0.16.22",
            /**
             * Renders the given LaTeX into an HTML+MathML combination, and adds
             * it as a child to the specified DOM node.
             */
            render: Vc,
            /**
             * Renders the given LaTeX into an HTML+MathML combination string,
             * for sending to the client.
             */
            renderToString: _m,
            /**
             * KaTeX error, usually during parsing.
             */
            ParseError: s,
            /**
             * The schema of Settings
             */
            SETTINGS_SCHEMA: N,
            /**
             * Parses the given LaTeX into KaTeX's internal parse tree structure,
             * without rendering to HTML or MathML.
             *
             * NOTE: This method is not currently recommended for public use.
             * The internal tree representation is unstable and is very likely
             * to change. Use at your own risk.
             */
            __parse: Sm,
            /**
             * Renders the given LaTeX into an HTML+MathML internal DOM tree
             * representation, without flattening that representation to a string.
             *
             * NOTE: This method is not currently recommended for public use.
             * The internal tree representation is unstable and is very likely
             * to change. Use at your own risk.
             */
            __renderToDomTree: Uu,
            /**
             * Renders the given LaTeX into an HTML internal DOM tree representation,
             * without MathML and without flattening that representation to a string.
             *
             * NOTE: This method is not currently recommended for public use.
             * The internal tree representation is unstable and is very likely
             * to change. Use at your own risk.
             */
            __renderToHTMLTree: function(a, u) {
              const c = new q(u);
              try {
                const d = ju(a, c);
                return R2(d, a, c);
              } catch (d) {
                return Gc(d, a, c);
              }
            },
            /**
             * extends internal font metrics object with a new object
             * each key in the new object represents a font name
            */
            __setFontMetrics: l2,
            /**
             * adds a new symbol to builtin symbols table
             */
            __defineSymbol: g,
            /**
             * adds a new function to builtin function list,
             * which directly produce parse tree elements
             * and have their own html/mathml builders
             */
            __defineFunction: de,
            /**
             * adds a new macro to builtin macro list
             */
            __defineMacro: C,
            /**
             * Expose the dom tree node types, which can be useful for type checking nodes.
             *
             * NOTE: These methods are not currently recommended for public use.
             * The internal tree representation is unstable and is very likely
             * to change. Use at your own risk.
             */
            __domTree: {
              Span: hi,
              Anchor: lu,
              SymbolNode: Rt,
              SvgNode: kn,
              PathNode: qn,
              LineNode: cu
            }
          }, Em = Am;
          return r = r.default, r;
        }()
      );
    });
  }(e0)), e0.exports;
}
var Qf;
function r9() {
  if (Qf) return Fr;
  Qf = 1;
  var e10 = Fr && Fr.__importDefault || function(w) {
    return w && w.__esModule ? w : { default: w };
  };
  Object.defineProperty(Fr, "__esModule", { value: true });
  const t = e10(n9());
  function n(w, A) {
    const T = w.src[A - 1], D = w.src[A], N = w.src[A + 1];
    if (D !== "$")
      return { can_open: false, can_close: false };
    let O = false, q = false;
    return T !== "$" && T !== "\\" && (T === void 0 || r(T) || !i(T)) && (O = true), N !== "$" && (N == null || r(N) || !i(N)) && (q = true), { can_open: O, can_close: q };
  }
  function r(w) {
    return /^\s$/u.test(w);
  }
  function i(w) {
    return /^[\w\d]$/u.test(w);
  }
  function s(w, A) {
    const T = w.src[A - 1], D = w.src[A], N = w.src[A + 1], O = w.src[A + 2];
    return D === "$" && T !== "$" && T !== "\\" && N === "$" && O !== "$" ? { can_open: true, can_close: true } : { can_open: false, can_close: false };
  }
  function o(w, A) {
    if (w.src[w.pos] !== "$")
      return false;
    const T = w.tokens.at(-1);
    if ((T == null ? void 0 : T.type) === "html_inline" && /^<\w+.+[^/]>$/.test(T.content))
      return false;
    let D = n(w, w.pos);
    if (!D.can_open)
      return A || (w.pending += "$"), w.pos += 1, true;
    let N = w.pos + 1, O = N, q;
    for (; (O = w.src.indexOf("$", O)) !== -1; ) {
      for (q = O - 1; w.src[q] === "\\"; )
        q -= 1;
      if ((O - q) % 2 == 1)
        break;
      O += 1;
    }
    if (O === -1)
      return A || (w.pending += "$"), w.pos = N, true;
    if (O - N === 0)
      return A || (w.pending += "$$"), w.pos = N + 1, true;
    if (D = n(w, O), !D.can_close)
      return A || (w.pending += "$"), w.pos = N, true;
    if (!A) {
      const z = w.push("math_inline", "math", 0);
      z.markup = "$", z.content = w.src.slice(N, O);
    }
    return w.pos = O + 1, true;
  }
  function l(w, A, T, D) {
    let N = false, O = w.bMarks[A] + w.tShift[A], q = w.eMarks[A];
    if (O + 2 > q || w.src.slice(O, O + 2) !== "$$")
      return false;
    O += 2;
    let z = w.src.slice(O, q);
    const R = [...z.matchAll(/\$\$/g)];
    if (R.length === 1 && R[0].index === z.length - 2)
      z = z.trim().slice(0, -2), N = true;
    else if (R.length > 1)
      return false;
    if (D)
      return true;
    let J, K, V;
    for (K = A; !N && (K++, !(K >= T || (O = w.bMarks[K] + w.tShift[K], q = w.eMarks[K], O < q && w.tShift[K] < w.blkIndent))); )
      w.src.slice(O, q).trim().slice(-2) === "$$" ? (V = w.src.slice(0, q).lastIndexOf("$$"), J = w.src.slice(O, V), N = true) : w.src.slice(O, q).trim().includes("$$") && (V = w.src.slice(0, q).trim().indexOf("$$"), J = w.src.slice(O, V), N = true);
    w.line = K + 1;
    const te = w.push("math_block", "math", 0);
    return te.block = true, te.content = (z && z.trim() ? z + `
` : "") + w.getLines(A + 1, K, w.tShift[A], true) + (J && J.trim() ? J : ""), te.map = [A, w.line], te.markup = "$$", true;
  }
  function f(w, A, T, D) {
    const N = w.bMarks[A] + w.tShift[A], O = w.eMarks[A];
    if (!w.src.slice(N, O).match(/^\s*\\begin\s*\{([^{}]+)\}/))
      return false;
    if (A > 0) {
      const Z = w.bMarks[A - 1] + w.tShift[A - 1], se = w.eMarks[A - 1], fe = w.src.slice(Z, se);
      if (!/^\s*$/.test(fe))
        return false;
    }
    if (D)
      return true;
    const R = [];
    let J = A, K, V = false;
    e: for (; !V && !(J >= T); J++) {
      const Z = w.bMarks[J] + w.tShift[J], se = w.eMarks[J];
      if (Z < se && w.tShift[J] < w.blkIndent)
        break;
      const fe = w.src.slice(Z, se);
      for (const $ of fe.matchAll(/(\\begin|\\end)\s*\{([^{}]+)\}/g))
        if ($[1] === "\\begin")
          R.push($[2].trim());
        else if ($[1] === "\\end" && (R.pop(), !R.length)) {
          K = w.src.slice(Z, se), V = true;
          break e;
        }
    }
    w.line = J + 1;
    const te = w.push("math_block", "math", 0);
    return te.block = true, te.content = (w.getLines(A, J, w.tShift[A], true) + (K ?? "")).trim(), te.map = [A, w.line], te.markup = "$$", true;
  }
  function h2(w, A) {
    var T, D, N, O, q;
    if (w.src.slice(w.pos, w.pos + 2) !== "$$")
      return false;
    if (O = s(w, w.pos), !O.can_open)
      return A || (w.pending += "$$"), w.pos += 2, true;
    for (T = w.pos + 2, D = T; (D = w.src.indexOf("$$", D)) !== -1; ) {
      for (q = D - 1; w.src[q] === "\\"; )
        q -= 1;
      if ((D - q) % 2 == 1)
        break;
      D += 2;
    }
    return D === -1 ? (A || (w.pending += "$$"), w.pos = T, true) : D - T === 0 ? (A || (w.pending += "$$$$"), w.pos = T + 2, true) : (O = s(w, D), O.can_close ? (A || (N = w.push("math_block", "math", 0), N.block = true, N.markup = "$$", N.content = w.src.slice(T, D)), w.pos = D + 2, true) : (A || (w.pending += "$$"), w.pos = T, true));
  }
  function p(w, A) {
    const T = w.src.slice(w.pos);
    if (!/^\n\\begin/.test(T))
      return false;
    if (w.pos += 1, A)
      return true;
    const D = T.split(/\n/g).slice(1);
    let N;
    const O = [];
    e: for (var q = 0; q < D.length; ++q) {
      const J = D[q];
      for (const K of J.matchAll(/(\\begin|\\end)\s*\{([^{}]+)\}/g))
        if (K[1] === "\\begin")
          O.push(K[2].trim());
        else if (K[1] === "\\end" && (O.pop(), !O.length)) {
          N = q;
          break e;
        }
    }
    if (typeof N > "u")
      return false;
    const z = D.slice(0, N + 1).reduce((J, K) => J + K.length, 0) + N + 1, R = w.push("math_inline_bare_block", "math", 0);
    return R.block = true, R.markup = "$$", R.content = T.slice(1, z), w.pos = w.pos + z, true;
  }
  function b(w, A, T, D) {
    const N = w.tokens;
    for (let O = N.length - 1; O >= 0; O--) {
      const q = N[O], z = [];
      if (q.type !== "html_block")
        continue;
      const R = q.content;
      for (const J of R.matchAll(D)) {
        if (!J.groups)
          continue;
        const K = J.groups.html_before_math, V = J.groups.math, te = J.groups.html_after_math;
        K && z.push({ ...q, type: "html_block", map: null, content: K }), V && z.push({
          ...q,
          type: A,
          map: null,
          content: V,
          markup: T,
          block: true,
          tag: "math"
        }), te && z.push({ ...q, type: "html_block", map: null, content: te });
      }
      z.length > 0 && N.splice(O, 1, ...z);
    }
    return true;
  }
  function v(w) {
    return w.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
  function k(w, A) {
    const T = (A == null ? void 0 : A.katex) ?? t.default, D = A == null ? void 0 : A.enableBareBlocks, N = A == null ? void 0 : A.enableMathBlockInHtml, O = A == null ? void 0 : A.enableMathInlineInHtml, q = A == null ? void 0 : A.enableFencedBlocks;
    w.inline.ruler.after("escape", "math_inline", o), w.inline.ruler.after("escape", "math_inline_block", h2), D && w.inline.ruler.before("text", "math_inline_bare_block", p), w.block.ruler.after("blockquote", "math_block", (Z, se, fe, $) => D && f(Z, se, fe, $) ? true : l(Z, se, fe, $), {
      alt: ["paragraph", "reference", "blockquote", "list"]
    });
    const z = /(?<html_before_math>[\s\S]*?)\$\$(?<math>[\s\S]+?)\$\$(?<html_after_math>(?:(?!\$\$[\s\S]+?\$\$)[\s\S])*)/gm, R = /(?<html_before_math>[\s\S]*?)\$(?<math>.*?)\$(?<html_after_math>(?:(?!\$.*?\$)[\s\S])*)/gm;
    N && w.core.ruler.push("math_block_in_html_block", (Z) => b(Z, "math_block", "$$", z)), O && w.core.ruler.push("math_inline_in_html_block", (Z) => b(Z, "math_inline", "$", R));
    const J = (Z) => {
      const se = /\\begin\{(align|equation|gather|cd|alignat)\}/ig.test(Z);
      try {
        return T.renderToString(Z, { ...A, displayMode: se });
      } catch (fe) {
        return (A == null ? void 0 : A.throwOnError) && console.log(fe), `<span class="katex-error" title="${v(Z)}">${v(fe + "")}</span>`;
      }
    }, K = (Z, se) => {
      const fe = Z[se].content, X = fe.length > 2 && fe[0] === "`" && fe[fe.length - 1] === "`" ? fe.slice(1, -1) : fe;
      return J(X);
    }, V = (Z) => {
      try {
        return `<p class="katex-block">${T.renderToString(Z, { ...A, displayMode: true })}</p>`;
      } catch (se) {
        return (A == null ? void 0 : A.throwOnError) && console.log(se), `<p class="katex-block katex-error" title="${v(Z)}">${v(se + "")}</p>`;
      }
    }, te = (Z, se) => V(Z[se].content) + `
`;
    if (w.renderer.rules.math_inline = K, w.renderer.rules.math_inline_block = te, w.renderer.rules.math_inline_bare_block = te, w.renderer.rules.math_block = te, q) {
      const Z = "math", se = w.renderer.rules.fence;
      w.renderer.rules.fence = function(fe, $, X, j, Q) {
        const ee = fe[$];
        return ee.info.trim().toLowerCase() === Z && q ? V(ee.content) + `
` : (se == null ? void 0 : se.call(this, fe, $, X, j, Q)) || "";
      };
    }
  }
  return Fr.default = k, Fr;
}
var i9 = r9();
var s9 = e9(i9);
function u9() {
  const e10 = Xt({
    html: true,
    breaks: true
  });
  return e10.use(z7).use($7).use(R7).use(j7), e10;
}
function o9(e10) {
  return {
    transformer: e10,
    parser: new Ei(),
    beforeParse: new Ei(),
    afterParse: new Ei(),
    retransform: new Ei()
  };
}
var a9 = `<svg width="16" height="16" viewBox="0 -3 24 24"><path d="M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2m-9 14-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8z"/></svg>
`;
var l9 = `<svg width="16" height="16" viewBox="0 -3 24 24"><path fill-rule="evenodd" d="M6 5a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1zM3 6a3 3 0 0 1 3-3h12a3 3 0 0 1 3 3v12a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3v-5z" clip-rule="evenodd"/></svg>
`;
var c9 = "checkbox";
var eh = {
  " ": l9.trim(),
  x: a9.trim()
};
var f9 = {
  name: c9,
  transform(e10) {
    return e10.parser.tap((t) => {
      t.core.ruler.before("inline", "checkbox", (n) => {
        for (let r = 2; r < n.tokens.length; r += 1) {
          const i = n.tokens[r];
          if (i.type === "inline" && i.content) {
            const s = n.tokens[r - 1].type, o = n.tokens[r - 2].type;
            (s === "heading_open" || s === "paragraph_open" && o === "list_item_open") && (i.content = i.content.replace(
              /^\[(.)\] /,
              (l, f) => eh[f] ? `${eh[f]} ` : l
            ));
          }
        }
        return false;
      });
    }), {};
  }
};
var h9 = "frontmatter";
var d9 = {
  name: h9,
  transform(e10) {
    return e10.beforeParse.tap((t, n) => {
      var r;
      const { content: i } = n;
      if (!/^---\r?\n/.test(i)) return;
      const s = /\n---\r?\n/.exec(i);
      if (!s) return;
      const o = i.slice(4, s.index).trimEnd();
      let l;
      try {
        l = Qb(o.replace(/\r?\n|\r/g, `
`)), (l == null ? void 0 : l.markmap) && (l.markmap = p9(
          l.markmap
        ));
      } catch {
        return;
      }
      n.frontmatter = l, n.parserOptions = {
        ...n.parserOptions,
        ...(r = l == null ? void 0 : l.markmap) == null ? void 0 : r.htmlParser
      }, n.frontmatterInfo = {
        lines: i.slice(0, s.index).split(`
`).length + 1,
        offset: s.index + s[0].length
      };
    }), {};
  }
};
function p9(e10) {
  if (e10)
    return ["color", "extraJs", "extraCss"].forEach((t) => {
      e10[t] != null && (e10[t] = m9(e10[t]));
    }), ["duration", "maxWidth", "initialExpandLevel"].forEach((t) => {
      e10[t] != null && (e10[t] = g9(e10[t]));
    }), e10;
}
function m9(e10) {
  let t;
  return typeof e10 == "string" ? t = [e10] : Array.isArray(e10) && (t = e10.filter((n) => n && typeof n == "string")), (t == null ? void 0 : t.length) ? t : void 0;
}
function g9(e10) {
  if (!isNaN(+e10))
    return +e10;
}
function il(e10, t) {
  return t.type === "script" && t.data.src ? {
    ...t,
    data: {
      ...t.data,
      src: e10.getFullUrl(t.data.src)
    }
  } : t;
}
function b9(e10, t) {
  return t.type === "stylesheet" && t.data.href ? {
    ...t,
    data: {
      ...t.data,
      href: e10.getFullUrl(t.data.href)
    }
  } : t;
}
var th = "hljs";
var y9 = [
  "@highlightjs/cdn-assets@11.11.1/highlight.min.js"
].map((e10) => xa(e10));
var x9 = [
  "@highlightjs/cdn-assets@11.11.1/styles/default.min.css"
].map((e10) => e1(e10));
var w9 = {
  versions: {
    hljs: "11.11.1"
  },
  preloadScripts: y9,
  styles: x9
};
var Jo = {
  name: th,
  config: w9,
  transform(e10) {
    var t, n, r;
    let i;
    const s = ((n = (t = Jo.config) == null ? void 0 : t.preloadScripts) == null ? void 0 : n.map(
      (f) => il(e10.transformer.urlBuilder, f)
    )) || [], o = () => (i || (i = Qh(s)), i);
    let l = $r;
    return e10.parser.tap((f) => {
      f.set({
        highlight: (h2, p) => {
          l();
          const { hljs: b } = window;
          return b ? b.highlightAuto(h2, p ? [p] : void 0).value : (o().then(() => {
            e10.retransform.call();
          }), h2);
        }
      });
    }), e10.beforeParse.tap((f, h2) => {
      l = () => {
        h2.features[th] = true;
      };
    }), {
      styles: (r = Jo.config) == null ? void 0 : r.styles
    };
  }
};
function v9(e10, t, n) {
  return e10.map((r) => {
    if (typeof r == "string" && !r.includes("://")) {
      r.startsWith("npm:") || (r = `npm:${r}`);
      const i = 4 + t.length;
      r.startsWith(`npm:${t}/`) && (r = `${r.slice(0, i)}@${n}${r.slice(
        i
      )}`);
    }
    return r;
  });
}
var k9 = ["katex@0.16.18/dist/fonts/KaTeX_AMS-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Caligraphic-Bold.woff2", "katex@0.16.18/dist/fonts/KaTeX_Caligraphic-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Fraktur-Bold.woff2", "katex@0.16.18/dist/fonts/KaTeX_Fraktur-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Main-Bold.woff2", "katex@0.16.18/dist/fonts/KaTeX_Main-BoldItalic.woff2", "katex@0.16.18/dist/fonts/KaTeX_Main-Italic.woff2", "katex@0.16.18/dist/fonts/KaTeX_Main-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Math-BoldItalic.woff2", "katex@0.16.18/dist/fonts/KaTeX_Math-Italic.woff2", "katex@0.16.18/dist/fonts/KaTeX_SansSerif-Bold.woff2", "katex@0.16.18/dist/fonts/KaTeX_SansSerif-Italic.woff2", "katex@0.16.18/dist/fonts/KaTeX_SansSerif-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Script-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Size1-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Size2-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Size3-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Size4-Regular.woff2", "katex@0.16.18/dist/fonts/KaTeX_Typewriter-Regular.woff2"];
var mo = "katex";
var _9 = [
  "katex@0.16.18/dist/katex.min.js"
].map((e10) => xa(e10));
var np = xa(
  "webfontloader@1.6.28/webfontloader.js"
);
np.data.defer = true;
var S9 = ["katex@0.16.18/dist/katex.min.css"].map(
  (e10) => e1(e10)
);
var A9 = {
  versions: {
    katex: "0.16.18",
    webfontloader: "1.6.28"
  },
  preloadScripts: _9,
  scripts: [
    {
      type: "iife",
      data: {
        fn: (e10) => {
          window.WebFontConfig = {
            custom: {
              families: [
                "KaTeX_AMS",
                "KaTeX_Caligraphic:n4,n7",
                "KaTeX_Fraktur:n4,n7",
                "KaTeX_Main:n4,n7,i4,i7",
                "KaTeX_Math:i4,i7",
                "KaTeX_Script",
                "KaTeX_SansSerif:n4,n7,i4",
                "KaTeX_Size1",
                "KaTeX_Size2",
                "KaTeX_Size3",
                "KaTeX_Size4",
                "KaTeX_Typewriter"
              ]
            },
            active: () => {
              e10().refreshHook.call();
            }
          };
        },
        getParams({ getMarkmap: e10 }) {
          return [e10];
        }
      }
    },
    np
  ],
  styles: S9,
  resources: k9
};
function E9(e10) {
  return e10.default || e10;
}
var C9 = E9(s9);
var Mi = {
  name: mo,
  config: A9,
  transform(e10) {
    var t, n, r, i;
    let s;
    const o = ((n = (t = Mi.config) == null ? void 0 : t.preloadScripts) == null ? void 0 : n.map(
      (p) => il(e10.transformer.urlBuilder, p)
    )) || [], l = () => (s || (s = Qh(o)), s), f = (p, b) => {
      const { katex: v } = window;
      return v ? v.renderToString(p, {
        displayMode: b,
        throwOnError: false
      }) : (l().then(() => {
        e10.retransform.call();
      }), p);
    };
    let h2 = $r;
    return e10.parser.tap((p) => {
      p.use(C9), ["math_block", "math_inline"].forEach((b) => {
        const v = (k, w) => (h2(), f(k[w].content, !!k[w].block));
        p.renderer.rules[b] = v;
      });
    }), e10.beforeParse.tap((p, b) => {
      h2 = () => {
        b.features[mo] = true;
      };
    }), e10.afterParse.tap((p, b) => {
      var v;
      const k = (v = b.frontmatter) == null ? void 0 : v.markmap;
      k && ["extraJs", "extraCss"].forEach((w) => {
        var A, T;
        const D = k[w];
        D && (k[w] = v9(
          D,
          mo,
          ((T = (A = Mi.config) == null ? void 0 : A.versions) == null ? void 0 : T.katex) || ""
        ));
      });
    }), {
      styles: (r = Mi.config) == null ? void 0 : r.styles,
      scripts: (i = Mi.config) == null ? void 0 : i.scripts
    };
  }
};
var T9 = "npmUrl";
var D9 = {
  name: T9,
  transform(e10) {
    return e10.afterParse.tap((t, n) => {
      const { frontmatter: r } = n, i = r == null ? void 0 : r.markmap;
      i && ["extraJs", "extraCss"].forEach((s) => {
        const o = i[s];
        o && (i[s] = o.map((l) => l.startsWith("npm:") ? e10.transformer.urlBuilder.getFullUrl(
          l.slice(4)
        ) : l));
      });
    }), {};
  }
};
var M9 = "sourceLines";
var N9 = {
  name: M9,
  transform(e10) {
    let t = 0;
    return e10.beforeParse.tap((n, r) => {
      var i;
      t = ((i = r.frontmatterInfo) == null ? void 0 : i.lines) || 0;
    }), e10.parser.tap((n) => {
      n.renderer.renderAttrs = Jc(
        n.renderer.renderAttrs,
        (r, i) => {
          if (i.block && i.map) {
            const s = i.map.map((o) => o + t);
            i.attrSet("data-lines", s.join(","));
          }
          return r(i);
        }
      ), n.renderer.rules.fence && (n.renderer.rules.fence = Jc(
        n.renderer.rules.fence,
        (r, i, s, ...o) => {
          let l = r(i, s, ...o);
          const f = i[s];
          if (l.startsWith("<pre>") && f.map) {
            const h2 = f.map.map(
              (p) => p + t
            );
            l = l.slice(0, 4) + ` data-lines="${h2.join(",")}"` + l.slice(4);
          }
          return l;
        }
      ));
    }), {};
  }
};
var I9 = [
  d9,
  Mi,
  Jo,
  D9,
  f9,
  N9
];
var F9 = I9;
function rp(e10) {
  for (; !e10.content && e10.children.length === 1; )
    e10 = e10.children[0];
  for (; e10.children.length === 1 && !e10.children[0].content; )
    e10 = {
      ...e10,
      children: e10.children[0].children
    };
  return {
    ...e10,
    children: e10.children.map(rp)
  };
}
var B9 = class {
  constructor(t = F9) {
    this.assetsMap = {}, this.urlBuilder = new Hm(), this.hooks = o9(this), this.plugins = t.map(
      (i) => typeof i == "function" ? i() : i
    );
    const n = {};
    for (const { name: i, transform: s } of this.plugins)
      n[i] = s(this.hooks);
    this.assetsMap = n;
    const r = u9();
    this.md = r, this.hooks.parser.call(r);
  }
  transform(t, n) {
    var r;
    const i = {
      content: t,
      features: {},
      parserOptions: n
    };
    this.hooks.beforeParse.call(this.md, i);
    let { content: s } = i;
    i.frontmatterInfo && (s = s.slice(i.frontmatterInfo.offset));
    const o = this.md.render(s, {});
    this.hooks.afterParse.call(this.md, i);
    const l = rp(Y5(o, i.parserOptions));
    return l.content || (l.content = `${((r = i.frontmatter) == null ? void 0 : r.title) || ""}`), { ...i, root: l };
  }
  resolveJS(t) {
    return il(this.urlBuilder, t);
  }
  resolveCSS(t) {
    return b9(this.urlBuilder, t);
  }
  /**
   * Get all assets from enabled plugins or filter them by plugin names as keys.
   */
  getAssets(t) {
    const n = [], r = [];
    t ?? (t = this.plugins.map((i) => i.name));
    for (const i of t.map((s) => this.assetsMap[s]))
      i && (i.styles && n.push(...i.styles), i.scripts && r.push(...i.scripts));
    return {
      styles: n.map((i) => this.resolveCSS(i)),
      scripts: r.map((i) => this.resolveJS(i))
    };
  }
  /**
   * Get used assets by features object returned by `transform`.
   */
  getUsedAssets(t) {
    const n = this.plugins.map((r) => r.name).filter((r) => t[r]);
    return this.getAssets(n);
  }
};
var nh = class extends Map {
  constructor(t, n = $9) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), t != null) for (const [r, i] of t) this.set(r, i);
  }
  get(t) {
    return super.get(rh(this, t));
  }
  has(t) {
    return super.has(rh(this, t));
  }
  set(t, n) {
    return super.set(O9(this, t), n);
  }
  delete(t) {
    return super.delete(z9(this, t));
  }
};
function rh({ _intern: e10, _key: t }, n) {
  const r = t(n);
  return e10.has(r) ? e10.get(r) : n;
}
function O9({ _intern: e10, _key: t }, n) {
  const r = t(n);
  return e10.has(r) ? e10.get(r) : (e10.set(r, n), n);
}
function z9({ _intern: e10, _key: t }, n) {
  const r = t(n);
  return e10.has(r) && (n = e10.get(r), e10.delete(r)), n;
}
function $9(e10) {
  return e10 !== null && typeof e10 == "object" ? e10.valueOf() : e10;
}
function ih(e10, t) {
  let n;
  if (t === void 0)
    for (const r of e10)
      r != null && (n < r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e10)
      (i = t(i, ++r, e10)) != null && (n < i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function sh(e10, t) {
  let n;
  if (t === void 0)
    for (const r of e10)
      r != null && (n > r || n === void 0 && r >= r) && (n = r);
  else {
    let r = -1;
    for (let i of e10)
      (i = t(i, ++r, e10)) != null && (n > i || n === void 0 && i >= i) && (n = i);
  }
  return n;
}
function L9(e10, t) {
  let n, r = -1, i = -1;
  if (t === void 0)
    for (const s of e10)
      ++i, s != null && (n > s || n === void 0 && s >= s) && (n = s, r = i);
  else
    for (let s of e10)
      (s = t(s, ++i, e10)) != null && (n > s || n === void 0 && s >= s) && (n = s, r = i);
  return r;
}
var q9 = { value: () => {
} };
function sl() {
  for (var e10 = 0, t = arguments.length, n = {}, r; e10 < t; ++e10) {
    if (!(r = arguments[e10] + "") || r in n || /[\s.]/.test(r)) throw new Error("illegal type: " + r);
    n[r] = [];
  }
  return new t0(n);
}
function t0(e10) {
  this._ = e10;
}
function R9(e10, t) {
  return e10.trim().split(/^|\s+/).map(function(n) {
    var r = "", i = n.indexOf(".");
    if (i >= 0 && (r = n.slice(i + 1), n = n.slice(0, i)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
    return { type: n, name: r };
  });
}
t0.prototype = sl.prototype = {
  constructor: t0,
  on: function(e10, t) {
    var n = this._, r = R9(e10 + "", n), i, s = -1, o = r.length;
    if (arguments.length < 2) {
      for (; ++s < o; ) if ((i = (e10 = r[s]).type) && (i = P9(n[i], e10.name))) return i;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++s < o; )
      if (i = (e10 = r[s]).type) n[i] = uh(n[i], e10.name, t);
      else if (t == null) for (i in n) n[i] = uh(n[i], e10.name, null);
    return this;
  },
  copy: function() {
    var e10 = {}, t = this._;
    for (var n in t) e10[n] = t[n].slice();
    return new t0(e10);
  },
  call: function(e10, t) {
    if ((i = arguments.length - 2) > 0) for (var n = new Array(i), r = 0, i, s; r < i; ++r) n[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(e10)) throw new Error("unknown type: " + e10);
    for (s = this._[e10], r = 0, i = s.length; r < i; ++r) s[r].value.apply(t, n);
  },
  apply: function(e10, t, n) {
    if (!this._.hasOwnProperty(e10)) throw new Error("unknown type: " + e10);
    for (var r = this._[e10], i = 0, s = r.length; i < s; ++i) r[i].value.apply(t, n);
  }
};
function P9(e10, t) {
  for (var n = 0, r = e10.length, i; n < r; ++n)
    if ((i = e10[n]).name === t)
      return i.value;
}
function uh(e10, t, n) {
  for (var r = 0, i = e10.length; r < i; ++r)
    if (e10[r].name === t) {
      e10[r] = q9, e10 = e10.slice(0, r).concat(e10.slice(r + 1));
      break;
    }
  return n != null && e10.push({ name: t, value: n }), e10;
}
var Qo = "http://www.w3.org/1999/xhtml";
var oh = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Qo,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function J0(e10) {
  var t = e10 += "", n = t.indexOf(":");
  return n >= 0 && (t = e10.slice(0, n)) !== "xmlns" && (e10 = e10.slice(n + 1)), oh.hasOwnProperty(t) ? { space: oh[t], local: e10 } : e10;
}
function H9(e10) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === Qo && t.documentElement.namespaceURI === Qo ? t.createElement(e10) : t.createElementNS(n, e10);
  };
}
function j9(e10) {
  return function() {
    return this.ownerDocument.createElementNS(e10.space, e10.local);
  };
}
function ip(e10) {
  var t = J0(e10);
  return (t.local ? j9 : H9)(t);
}
function U9() {
}
function ul(e10) {
  return e10 == null ? U9 : function() {
    return this.querySelector(e10);
  };
}
function V9(e10) {
  typeof e10 != "function" && (e10 = ul(e10));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var s = t[i], o = s.length, l = r[i] = new Array(o), f, h2, p = 0; p < o; ++p)
      (f = s[p]) && (h2 = e10.call(f, f.__data__, p, s)) && ("__data__" in f && (h2.__data__ = f.__data__), l[p] = h2);
  return new qt(r, this._parents);
}
function G9(e10) {
  return e10 == null ? [] : Array.isArray(e10) ? e10 : Array.from(e10);
}
function W9() {
  return [];
}
function sp(e10) {
  return e10 == null ? W9 : function() {
    return this.querySelectorAll(e10);
  };
}
function K9(e10) {
  return function() {
    return G9(e10.apply(this, arguments));
  };
}
function X9(e10) {
  typeof e10 == "function" ? e10 = K9(e10) : e10 = sp(e10);
  for (var t = this._groups, n = t.length, r = [], i = [], s = 0; s < n; ++s)
    for (var o = t[s], l = o.length, f, h2 = 0; h2 < l; ++h2)
      (f = o[h2]) && (r.push(e10.call(f, f.__data__, h2, o)), i.push(f));
  return new qt(r, i);
}
function up(e10) {
  return function() {
    return this.matches(e10);
  };
}
function op(e10) {
  return function(t) {
    return t.matches(e10);
  };
}
var Y9 = Array.prototype.find;
function Z9(e10) {
  return function() {
    return Y9.call(this.children, e10);
  };
}
function J9() {
  return this.firstElementChild;
}
function Q9(e10) {
  return this.select(e10 == null ? J9 : Z9(typeof e10 == "function" ? e10 : op(e10)));
}
var ey = Array.prototype.filter;
function ty() {
  return Array.from(this.children);
}
function ny(e10) {
  return function() {
    return ey.call(this.children, e10);
  };
}
function ry(e10) {
  return this.selectAll(e10 == null ? ty : ny(typeof e10 == "function" ? e10 : op(e10)));
}
function iy(e10) {
  typeof e10 != "function" && (e10 = up(e10));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var s = t[i], o = s.length, l = r[i] = [], f, h2 = 0; h2 < o; ++h2)
      (f = s[h2]) && e10.call(f, f.__data__, h2, s) && l.push(f);
  return new qt(r, this._parents);
}
function ap(e10) {
  return new Array(e10.length);
}
function sy() {
  return new qt(this._enter || this._groups.map(ap), this._parents);
}
function S0(e10, t) {
  this.ownerDocument = e10.ownerDocument, this.namespaceURI = e10.namespaceURI, this._next = null, this._parent = e10, this.__data__ = t;
}
S0.prototype = {
  constructor: S0,
  appendChild: function(e10) {
    return this._parent.insertBefore(e10, this._next);
  },
  insertBefore: function(e10, t) {
    return this._parent.insertBefore(e10, t);
  },
  querySelector: function(e10) {
    return this._parent.querySelector(e10);
  },
  querySelectorAll: function(e10) {
    return this._parent.querySelectorAll(e10);
  }
};
function uy(e10) {
  return function() {
    return e10;
  };
}
function oy(e10, t, n, r, i, s) {
  for (var o = 0, l, f = t.length, h2 = s.length; o < h2; ++o)
    (l = t[o]) ? (l.__data__ = s[o], r[o] = l) : n[o] = new S0(e10, s[o]);
  for (; o < f; ++o)
    (l = t[o]) && (i[o] = l);
}
function ay(e10, t, n, r, i, s, o) {
  var l, f, h2 = /* @__PURE__ */ new Map(), p = t.length, b = s.length, v = new Array(p), k;
  for (l = 0; l < p; ++l)
    (f = t[l]) && (v[l] = k = o.call(f, f.__data__, l, t) + "", h2.has(k) ? i[l] = f : h2.set(k, f));
  for (l = 0; l < b; ++l)
    k = o.call(e10, s[l], l, s) + "", (f = h2.get(k)) ? (r[l] = f, f.__data__ = s[l], h2.delete(k)) : n[l] = new S0(e10, s[l]);
  for (l = 0; l < p; ++l)
    (f = t[l]) && h2.get(v[l]) === f && (i[l] = f);
}
function ly(e10) {
  return e10.__data__;
}
function cy(e10, t) {
  if (!arguments.length) return Array.from(this, ly);
  var n = t ? ay : oy, r = this._parents, i = this._groups;
  typeof e10 != "function" && (e10 = uy(e10));
  for (var s = i.length, o = new Array(s), l = new Array(s), f = new Array(s), h2 = 0; h2 < s; ++h2) {
    var p = r[h2], b = i[h2], v = b.length, k = fy(e10.call(p, p && p.__data__, h2, r)), w = k.length, A = l[h2] = new Array(w), T = o[h2] = new Array(w), D = f[h2] = new Array(v);
    n(p, b, A, T, D, k, t);
    for (var N = 0, O = 0, q, z; N < w; ++N)
      if (q = A[N]) {
        for (N >= O && (O = N + 1); !(z = T[O]) && ++O < w; ) ;
        q._next = z || null;
      }
  }
  return o = new qt(o, r), o._enter = l, o._exit = f, o;
}
function fy(e10) {
  return typeof e10 == "object" && "length" in e10 ? e10 : Array.from(e10);
}
function hy() {
  return new qt(this._exit || this._groups.map(ap), this._parents);
}
function dy(e10, t, n) {
  var r = this.enter(), i = this, s = this.exit();
  return typeof e10 == "function" ? (r = e10(r), r && (r = r.selection())) : r = r.append(e10 + ""), t != null && (i = t(i), i && (i = i.selection())), n == null ? s.remove() : n(s), r && i ? r.merge(i).order() : i;
}
function py(e10) {
  for (var t = e10.selection ? e10.selection() : e10, n = this._groups, r = t._groups, i = n.length, s = r.length, o = Math.min(i, s), l = new Array(i), f = 0; f < o; ++f)
    for (var h2 = n[f], p = r[f], b = h2.length, v = l[f] = new Array(b), k, w = 0; w < b; ++w)
      (k = h2[w] || p[w]) && (v[w] = k);
  for (; f < i; ++f)
    l[f] = n[f];
  return new qt(l, this._parents);
}
function my() {
  for (var e10 = this._groups, t = -1, n = e10.length; ++t < n; )
    for (var r = e10[t], i = r.length - 1, s = r[i], o; --i >= 0; )
      (o = r[i]) && (s && o.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(o, s), s = o);
  return this;
}
function gy(e10) {
  e10 || (e10 = by);
  function t(b, v) {
    return b && v ? e10(b.__data__, v.__data__) : !b - !v;
  }
  for (var n = this._groups, r = n.length, i = new Array(r), s = 0; s < r; ++s) {
    for (var o = n[s], l = o.length, f = i[s] = new Array(l), h2, p = 0; p < l; ++p)
      (h2 = o[p]) && (f[p] = h2);
    f.sort(t);
  }
  return new qt(i, this._parents).order();
}
function by(e10, t) {
  return e10 < t ? -1 : e10 > t ? 1 : e10 >= t ? 0 : NaN;
}
function yy() {
  var e10 = arguments[0];
  return arguments[0] = this, e10.apply(null, arguments), this;
}
function xy() {
  return Array.from(this);
}
function wy() {
  for (var e10 = this._groups, t = 0, n = e10.length; t < n; ++t)
    for (var r = e10[t], i = 0, s = r.length; i < s; ++i) {
      var o = r[i];
      if (o) return o;
    }
  return null;
}
function vy() {
  let e10 = 0;
  for (const t of this) ++e10;
  return e10;
}
function ky() {
  return !this.node();
}
function _y(e10) {
  for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
    for (var i = t[n], s = 0, o = i.length, l; s < o; ++s)
      (l = i[s]) && e10.call(l, l.__data__, s, i);
  return this;
}
function Sy(e10) {
  return function() {
    this.removeAttribute(e10);
  };
}
function Ay(e10) {
  return function() {
    this.removeAttributeNS(e10.space, e10.local);
  };
}
function Ey(e10, t) {
  return function() {
    this.setAttribute(e10, t);
  };
}
function Cy(e10, t) {
  return function() {
    this.setAttributeNS(e10.space, e10.local, t);
  };
}
function Ty(e10, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e10) : this.setAttribute(e10, n);
  };
}
function Dy(e10, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e10.space, e10.local) : this.setAttributeNS(e10.space, e10.local, n);
  };
}
function My(e10, t) {
  var n = J0(e10);
  if (arguments.length < 2) {
    var r = this.node();
    return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
  }
  return this.each((t == null ? n.local ? Ay : Sy : typeof t == "function" ? n.local ? Dy : Ty : n.local ? Cy : Ey)(n, t));
}
function lp(e10) {
  return e10.ownerDocument && e10.ownerDocument.defaultView || e10.document && e10 || e10.defaultView;
}
function Ny(e10) {
  return function() {
    this.style.removeProperty(e10);
  };
}
function Iy(e10, t, n) {
  return function() {
    this.style.setProperty(e10, t, n);
  };
}
function Fy(e10, t, n) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? this.style.removeProperty(e10) : this.style.setProperty(e10, r, n);
  };
}
function By(e10, t, n) {
  return arguments.length > 1 ? this.each((t == null ? Ny : typeof t == "function" ? Fy : Iy)(e10, t, n ?? "")) : Qr(this.node(), e10);
}
function Qr(e10, t) {
  return e10.style.getPropertyValue(t) || lp(e10).getComputedStyle(e10, null).getPropertyValue(t);
}
function Oy(e10) {
  return function() {
    delete this[e10];
  };
}
function zy(e10, t) {
  return function() {
    this[e10] = t;
  };
}
function $y(e10, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e10] : this[e10] = n;
  };
}
function Ly(e10, t) {
  return arguments.length > 1 ? this.each((t == null ? Oy : typeof t == "function" ? $y : zy)(e10, t)) : this.node()[e10];
}
function cp(e10) {
  return e10.trim().split(/^|\s+/);
}
function ol(e10) {
  return e10.classList || new fp(e10);
}
function fp(e10) {
  this._node = e10, this._names = cp(e10.getAttribute("class") || "");
}
fp.prototype = {
  add: function(e10) {
    var t = this._names.indexOf(e10);
    t < 0 && (this._names.push(e10), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e10) {
    var t = this._names.indexOf(e10);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e10) {
    return this._names.indexOf(e10) >= 0;
  }
};
function hp(e10, t) {
  for (var n = ol(e10), r = -1, i = t.length; ++r < i; ) n.add(t[r]);
}
function dp(e10, t) {
  for (var n = ol(e10), r = -1, i = t.length; ++r < i; ) n.remove(t[r]);
}
function qy(e10) {
  return function() {
    hp(this, e10);
  };
}
function Ry(e10) {
  return function() {
    dp(this, e10);
  };
}
function Py(e10, t) {
  return function() {
    (t.apply(this, arguments) ? hp : dp)(this, e10);
  };
}
function Hy(e10, t) {
  var n = cp(e10 + "");
  if (arguments.length < 2) {
    for (var r = ol(this.node()), i = -1, s = n.length; ++i < s; ) if (!r.contains(n[i])) return false;
    return true;
  }
  return this.each((typeof t == "function" ? Py : t ? qy : Ry)(n, t));
}
function jy() {
  this.textContent = "";
}
function Uy(e10) {
  return function() {
    this.textContent = e10;
  };
}
function Vy(e10) {
  return function() {
    var t = e10.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function Gy(e10) {
  return arguments.length ? this.each(e10 == null ? jy : (typeof e10 == "function" ? Vy : Uy)(e10)) : this.node().textContent;
}
function Wy() {
  this.innerHTML = "";
}
function Ky(e10) {
  return function() {
    this.innerHTML = e10;
  };
}
function Xy(e10) {
  return function() {
    var t = e10.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function Yy(e10) {
  return arguments.length ? this.each(e10 == null ? Wy : (typeof e10 == "function" ? Xy : Ky)(e10)) : this.node().innerHTML;
}
function Zy() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function Jy() {
  return this.each(Zy);
}
function Qy() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function ex() {
  return this.each(Qy);
}
function tx(e10) {
  var t = typeof e10 == "function" ? e10 : ip(e10);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function nx() {
  return null;
}
function rx(e10, t) {
  var n = typeof e10 == "function" ? e10 : ip(e10), r = t == null ? nx : typeof t == "function" ? t : ul(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
  });
}
function ix() {
  var e10 = this.parentNode;
  e10 && e10.removeChild(this);
}
function sx() {
  return this.each(ix);
}
function ux() {
  var e10 = this.cloneNode(false), t = this.parentNode;
  return t ? t.insertBefore(e10, this.nextSibling) : e10;
}
function ox() {
  var e10 = this.cloneNode(true), t = this.parentNode;
  return t ? t.insertBefore(e10, this.nextSibling) : e10;
}
function ax(e10) {
  return this.select(e10 ? ox : ux);
}
function lx(e10) {
  return arguments.length ? this.property("__data__", e10) : this.node().__data__;
}
function cx(e10) {
  return function(t) {
    e10.call(this, t, this.__data__);
  };
}
function fx(e10) {
  return e10.trim().split(/^|\s+/).map(function(t) {
    var n = "", r = t.indexOf(".");
    return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), { type: t, name: n };
  });
}
function hx(e10) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, r = -1, i = t.length, s; n < i; ++n)
        s = t[n], (!e10.type || s.type === e10.type) && s.name === e10.name ? this.removeEventListener(s.type, s.listener, s.options) : t[++r] = s;
      ++r ? t.length = r : delete this.__on;
    }
  };
}
function dx(e10, t, n) {
  return function() {
    var r = this.__on, i, s = cx(t);
    if (r) {
      for (var o = 0, l = r.length; o < l; ++o)
        if ((i = r[o]).type === e10.type && i.name === e10.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = s, i.options = n), i.value = t;
          return;
        }
    }
    this.addEventListener(e10.type, s, n), i = { type: e10.type, name: e10.name, value: t, listener: s, options: n }, r ? r.push(i) : this.__on = [i];
  };
}
function px(e10, t, n) {
  var r = fx(e10 + ""), i, s = r.length, o;
  if (arguments.length < 2) {
    var l = this.node().__on;
    if (l) {
      for (var f = 0, h2 = l.length, p; f < h2; ++f)
        for (i = 0, p = l[f]; i < s; ++i)
          if ((o = r[i]).type === p.type && o.name === p.name)
            return p.value;
    }
    return;
  }
  for (l = t ? dx : hx, i = 0; i < s; ++i) this.each(l(r[i], t, n));
  return this;
}
function pp(e10, t, n) {
  var r = lp(e10), i = r.CustomEvent;
  typeof i == "function" ? i = new i(t, n) : (i = r.document.createEvent("Event"), n ? (i.initEvent(t, n.bubbles, n.cancelable), i.detail = n.detail) : i.initEvent(t, false, false)), e10.dispatchEvent(i);
}
function mx(e10, t) {
  return function() {
    return pp(this, e10, t);
  };
}
function gx(e10, t) {
  return function() {
    return pp(this, e10, t.apply(this, arguments));
  };
}
function bx(e10, t) {
  return this.each((typeof t == "function" ? gx : mx)(e10, t));
}
function* yx() {
  for (var e10 = this._groups, t = 0, n = e10.length; t < n; ++t)
    for (var r = e10[t], i = 0, s = r.length, o; i < s; ++i)
      (o = r[i]) && (yield o);
}
var mp = [null];
function qt(e10, t) {
  this._groups = e10, this._parents = t;
}
function ls() {
  return new qt([[document.documentElement]], mp);
}
function xx() {
  return this;
}
qt.prototype = ls.prototype = {
  constructor: qt,
  select: V9,
  selectAll: X9,
  selectChild: Q9,
  selectChildren: ry,
  filter: iy,
  data: cy,
  enter: sy,
  exit: hy,
  join: dy,
  merge: py,
  selection: xx,
  order: my,
  sort: gy,
  call: yy,
  nodes: xy,
  node: wy,
  size: vy,
  empty: ky,
  each: _y,
  attr: My,
  style: By,
  property: Ly,
  classed: Hy,
  text: Gy,
  html: Yy,
  raise: Jy,
  lower: ex,
  append: tx,
  insert: rx,
  remove: sx,
  clone: ax,
  datum: lx,
  on: px,
  dispatch: bx,
  [Symbol.iterator]: yx
};
function Yn(e10) {
  return typeof e10 == "string" ? new qt([[document.querySelector(e10)]], [document.documentElement]) : new qt([[e10]], mp);
}
function wx(e10) {
  let t;
  for (; t = e10.sourceEvent; ) e10 = t;
  return e10;
}
function ur(e10, t) {
  if (e10 = wx(e10), t === void 0 && (t = e10.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var r = n.createSVGPoint();
      return r.x = e10.clientX, r.y = e10.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y];
    }
    if (t.getBoundingClientRect) {
      var i = t.getBoundingClientRect();
      return [e10.clientX - i.left - t.clientLeft, e10.clientY - i.top - t.clientTop];
    }
  }
  return [e10.pageX, e10.pageY];
}
var ea = { capture: true, passive: false };
function ta(e10) {
  e10.preventDefault(), e10.stopImmediatePropagation();
}
function vx(e10) {
  var t = e10.document.documentElement, n = Yn(e10).on("dragstart.drag", ta, ea);
  "onselectstart" in t ? n.on("selectstart.drag", ta, ea) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function kx(e10, t) {
  var n = e10.document.documentElement, r = Yn(e10).on("dragstart.drag", null);
  t && (r.on("click.drag", ta, ea), setTimeout(function() {
    r.on("click.drag", null);
  }, 0)), "onselectstart" in n ? r.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
function al(e10, t, n) {
  e10.prototype = t.prototype = n, n.constructor = e10;
}
function gp(e10, t) {
  var n = Object.create(e10.prototype);
  for (var r in t) n[r] = t[r];
  return n;
}
function cs() {
}
var Ki = 0.7;
var A0 = 1 / Ki;
var Vr = "\\s*([+-]?\\d+)\\s*";
var Xi = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var pn = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var _x = /^#([0-9a-f]{3,8})$/;
var Sx = new RegExp(`^rgb\\(${Vr},${Vr},${Vr}\\)$`);
var Ax = new RegExp(`^rgb\\(${pn},${pn},${pn}\\)$`);
var Ex = new RegExp(`^rgba\\(${Vr},${Vr},${Vr},${Xi}\\)$`);
var Cx = new RegExp(`^rgba\\(${pn},${pn},${pn},${Xi}\\)$`);
var Tx = new RegExp(`^hsl\\(${Xi},${pn},${pn}\\)$`);
var Dx = new RegExp(`^hsla\\(${Xi},${pn},${pn},${Xi}\\)$`);
var ah = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
al(cs, Yi, {
  copy(e10) {
    return Object.assign(new this.constructor(), this, e10);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: lh,
  // Deprecated! Use color.formatHex.
  formatHex: lh,
  formatHex8: Mx,
  formatHsl: Nx,
  formatRgb: ch,
  toString: ch
});
function lh() {
  return this.rgb().formatHex();
}
function Mx() {
  return this.rgb().formatHex8();
}
function Nx() {
  return bp(this).formatHsl();
}
function ch() {
  return this.rgb().formatRgb();
}
function Yi(e10) {
  var t, n;
  return e10 = (e10 + "").trim().toLowerCase(), (t = _x.exec(e10)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? fh(t) : n === 3 ? new Nt(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? js(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? js(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = Sx.exec(e10)) ? new Nt(t[1], t[2], t[3], 1) : (t = Ax.exec(e10)) ? new Nt(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = Ex.exec(e10)) ? js(t[1], t[2], t[3], t[4]) : (t = Cx.exec(e10)) ? js(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = Tx.exec(e10)) ? ph(t[1], t[2] / 100, t[3] / 100, 1) : (t = Dx.exec(e10)) ? ph(t[1], t[2] / 100, t[3] / 100, t[4]) : ah.hasOwnProperty(e10) ? fh(ah[e10]) : e10 === "transparent" ? new Nt(NaN, NaN, NaN, 0) : null;
}
function fh(e10) {
  return new Nt(e10 >> 16 & 255, e10 >> 8 & 255, e10 & 255, 1);
}
function js(e10, t, n, r) {
  return r <= 0 && (e10 = t = n = NaN), new Nt(e10, t, n, r);
}
function Ix(e10) {
  return e10 instanceof cs || (e10 = Yi(e10)), e10 ? (e10 = e10.rgb(), new Nt(e10.r, e10.g, e10.b, e10.opacity)) : new Nt();
}
function na(e10, t, n, r) {
  return arguments.length === 1 ? Ix(e10) : new Nt(e10, t, n, r ?? 1);
}
function Nt(e10, t, n, r) {
  this.r = +e10, this.g = +t, this.b = +n, this.opacity = +r;
}
al(Nt, na, gp(cs, {
  brighter(e10) {
    return e10 = e10 == null ? A0 : Math.pow(A0, e10), new Nt(this.r * e10, this.g * e10, this.b * e10, this.opacity);
  },
  darker(e10) {
    return e10 = e10 == null ? Ki : Math.pow(Ki, e10), new Nt(this.r * e10, this.g * e10, this.b * e10, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Nt(gr(this.r), gr(this.g), gr(this.b), E0(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: hh,
  // Deprecated! Use color.formatHex.
  formatHex: hh,
  formatHex8: Fx,
  formatRgb: dh,
  toString: dh
}));
function hh() {
  return `#${mr(this.r)}${mr(this.g)}${mr(this.b)}`;
}
function Fx() {
  return `#${mr(this.r)}${mr(this.g)}${mr(this.b)}${mr((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function dh() {
  const e10 = E0(this.opacity);
  return `${e10 === 1 ? "rgb(" : "rgba("}${gr(this.r)}, ${gr(this.g)}, ${gr(this.b)}${e10 === 1 ? ")" : `, ${e10})`}`;
}
function E0(e10) {
  return isNaN(e10) ? 1 : Math.max(0, Math.min(1, e10));
}
function gr(e10) {
  return Math.max(0, Math.min(255, Math.round(e10) || 0));
}
function mr(e10) {
  return e10 = gr(e10), (e10 < 16 ? "0" : "") + e10.toString(16);
}
function ph(e10, t, n, r) {
  return r <= 0 ? e10 = t = n = NaN : n <= 0 || n >= 1 ? e10 = t = NaN : t <= 0 && (e10 = NaN), new Qt(e10, t, n, r);
}
function bp(e10) {
  if (e10 instanceof Qt) return new Qt(e10.h, e10.s, e10.l, e10.opacity);
  if (e10 instanceof cs || (e10 = Yi(e10)), !e10) return new Qt();
  if (e10 instanceof Qt) return e10;
  e10 = e10.rgb();
  var t = e10.r / 255, n = e10.g / 255, r = e10.b / 255, i = Math.min(t, n, r), s = Math.max(t, n, r), o = NaN, l = s - i, f = (s + i) / 2;
  return l ? (t === s ? o = (n - r) / l + (n < r) * 6 : n === s ? o = (r - t) / l + 2 : o = (t - n) / l + 4, l /= f < 0.5 ? s + i : 2 - s - i, o *= 60) : l = f > 0 && f < 1 ? 0 : o, new Qt(o, l, f, e10.opacity);
}
function Bx(e10, t, n, r) {
  return arguments.length === 1 ? bp(e10) : new Qt(e10, t, n, r ?? 1);
}
function Qt(e10, t, n, r) {
  this.h = +e10, this.s = +t, this.l = +n, this.opacity = +r;
}
al(Qt, Bx, gp(cs, {
  brighter(e10) {
    return e10 = e10 == null ? A0 : Math.pow(A0, e10), new Qt(this.h, this.s, this.l * e10, this.opacity);
  },
  darker(e10) {
    return e10 = e10 == null ? Ki : Math.pow(Ki, e10), new Qt(this.h, this.s, this.l * e10, this.opacity);
  },
  rgb() {
    var e10 = this.h % 360 + (this.h < 0) * 360, t = isNaN(e10) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, i = 2 * n - r;
    return new Nt(
      go(e10 >= 240 ? e10 - 240 : e10 + 120, i, r),
      go(e10, i, r),
      go(e10 < 120 ? e10 + 240 : e10 - 120, i, r),
      this.opacity
    );
  },
  clamp() {
    return new Qt(mh(this.h), Us(this.s), Us(this.l), E0(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e10 = E0(this.opacity);
    return `${e10 === 1 ? "hsl(" : "hsla("}${mh(this.h)}, ${Us(this.s) * 100}%, ${Us(this.l) * 100}%${e10 === 1 ? ")" : `, ${e10})`}`;
  }
}));
function mh(e10) {
  return e10 = (e10 || 0) % 360, e10 < 0 ? e10 + 360 : e10;
}
function Us(e10) {
  return Math.max(0, Math.min(1, e10 || 0));
}
function go(e10, t, n) {
  return (e10 < 60 ? t + (n - t) * e10 / 60 : e10 < 180 ? n : e10 < 240 ? t + (n - t) * (240 - e10) / 60 : t) * 255;
}
var yp = (e10) => () => e10;
function Ox(e10, t) {
  return function(n) {
    return e10 + n * t;
  };
}
function zx(e10, t, n) {
  return e10 = Math.pow(e10, n), t = Math.pow(t, n) - e10, n = 1 / n, function(r) {
    return Math.pow(e10 + r * t, n);
  };
}
function $x(e10) {
  return (e10 = +e10) == 1 ? xp : function(t, n) {
    return n - t ? zx(t, n, e10) : yp(isNaN(t) ? n : t);
  };
}
function xp(e10, t) {
  var n = t - e10;
  return n ? Ox(e10, n) : yp(isNaN(e10) ? t : e10);
}
var gh = function e(t) {
  var n = $x(t);
  function r(i, s) {
    var o = n((i = na(i)).r, (s = na(s)).r), l = n(i.g, s.g), f = n(i.b, s.b), h2 = xp(i.opacity, s.opacity);
    return function(p) {
      return i.r = o(p), i.g = l(p), i.b = f(p), i.opacity = h2(p), i + "";
    };
  }
  return r.gamma = e, r;
}(1);
function Wn(e10, t) {
  return e10 = +e10, t = +t, function(n) {
    return e10 * (1 - n) + t * n;
  };
}
var ra = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var bo = new RegExp(ra.source, "g");
function Lx(e10) {
  return function() {
    return e10;
  };
}
function qx(e10) {
  return function(t) {
    return e10(t) + "";
  };
}
function Rx(e10, t) {
  var n = ra.lastIndex = bo.lastIndex = 0, r, i, s, o = -1, l = [], f = [];
  for (e10 = e10 + "", t = t + ""; (r = ra.exec(e10)) && (i = bo.exec(t)); )
    (s = i.index) > n && (s = t.slice(n, s), l[o] ? l[o] += s : l[++o] = s), (r = r[0]) === (i = i[0]) ? l[o] ? l[o] += i : l[++o] = i : (l[++o] = null, f.push({ i: o, x: Wn(r, i) })), n = bo.lastIndex;
  return n < t.length && (s = t.slice(n), l[o] ? l[o] += s : l[++o] = s), l.length < 2 ? f[0] ? qx(f[0].x) : Lx(t) : (t = f.length, function(h2) {
    for (var p = 0, b; p < t; ++p) l[(b = f[p]).i] = b.x(h2);
    return l.join("");
  });
}
var bh = 180 / Math.PI;
var ia = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function wp(e10, t, n, r, i, s) {
  var o, l, f;
  return (o = Math.sqrt(e10 * e10 + t * t)) && (e10 /= o, t /= o), (f = e10 * n + t * r) && (n -= e10 * f, r -= t * f), (l = Math.sqrt(n * n + r * r)) && (n /= l, r /= l, f /= l), e10 * r < t * n && (e10 = -e10, t = -t, f = -f, o = -o), {
    translateX: i,
    translateY: s,
    rotate: Math.atan2(t, e10) * bh,
    skewX: Math.atan(f) * bh,
    scaleX: o,
    scaleY: l
  };
}
var Vs;
function Px(e10) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e10 + "");
  return t.isIdentity ? ia : wp(t.a, t.b, t.c, t.d, t.e, t.f);
}
function Hx(e10) {
  return e10 == null || (Vs || (Vs = document.createElementNS("http://www.w3.org/2000/svg", "g")), Vs.setAttribute("transform", e10), !(e10 = Vs.transform.baseVal.consolidate())) ? ia : (e10 = e10.matrix, wp(e10.a, e10.b, e10.c, e10.d, e10.e, e10.f));
}
function vp(e10, t, n, r) {
  function i(h2) {
    return h2.length ? h2.pop() + " " : "";
  }
  function s(h2, p, b, v, k, w) {
    if (h2 !== b || p !== v) {
      var A = k.push("translate(", null, t, null, n);
      w.push({ i: A - 4, x: Wn(h2, b) }, { i: A - 2, x: Wn(p, v) });
    } else (b || v) && k.push("translate(" + b + t + v + n);
  }
  function o(h2, p, b, v) {
    h2 !== p ? (h2 - p > 180 ? p += 360 : p - h2 > 180 && (h2 += 360), v.push({ i: b.push(i(b) + "rotate(", null, r) - 2, x: Wn(h2, p) })) : p && b.push(i(b) + "rotate(" + p + r);
  }
  function l(h2, p, b, v) {
    h2 !== p ? v.push({ i: b.push(i(b) + "skewX(", null, r) - 2, x: Wn(h2, p) }) : p && b.push(i(b) + "skewX(" + p + r);
  }
  function f(h2, p, b, v, k, w) {
    if (h2 !== b || p !== v) {
      var A = k.push(i(k) + "scale(", null, ",", null, ")");
      w.push({ i: A - 4, x: Wn(h2, b) }, { i: A - 2, x: Wn(p, v) });
    } else (b !== 1 || v !== 1) && k.push(i(k) + "scale(" + b + "," + v + ")");
  }
  return function(h2, p) {
    var b = [], v = [];
    return h2 = e10(h2), p = e10(p), s(h2.translateX, h2.translateY, p.translateX, p.translateY, b, v), o(h2.rotate, p.rotate, b, v), l(h2.skewX, p.skewX, b, v), f(h2.scaleX, h2.scaleY, p.scaleX, p.scaleY, b, v), h2 = p = null, function(k) {
      for (var w = -1, A = v.length, T; ++w < A; ) b[(T = v[w]).i] = T.x(k);
      return b.join("");
    };
  };
}
var jx = vp(Px, "px, ", "px)", "deg)");
var Ux = vp(Hx, ", ", ")", ")");
var Vx = 1e-12;
function yh(e10) {
  return ((e10 = Math.exp(e10)) + 1 / e10) / 2;
}
function Gx(e10) {
  return ((e10 = Math.exp(e10)) - 1 / e10) / 2;
}
function Wx(e10) {
  return ((e10 = Math.exp(2 * e10)) - 1) / (e10 + 1);
}
var Kx = function e2(t, n, r) {
  function i(s, o) {
    var l = s[0], f = s[1], h2 = s[2], p = o[0], b = o[1], v = o[2], k = p - l, w = b - f, A = k * k + w * w, T, D;
    if (A < Vx)
      D = Math.log(v / h2) / t, T = function(J) {
        return [
          l + J * k,
          f + J * w,
          h2 * Math.exp(t * J * D)
        ];
      };
    else {
      var N = Math.sqrt(A), O = (v * v - h2 * h2 + r * A) / (2 * h2 * n * N), q = (v * v - h2 * h2 - r * A) / (2 * v * n * N), z = Math.log(Math.sqrt(O * O + 1) - O), R = Math.log(Math.sqrt(q * q + 1) - q);
      D = (R - z) / t, T = function(J) {
        var K = J * D, V = yh(z), te = h2 / (n * N) * (V * Wx(t * K + z) - Gx(z));
        return [
          l + te * k,
          f + te * w,
          h2 * V / yh(t * K + z)
        ];
      };
    }
    return T.duration = D * 1e3 * t / Math.SQRT2, T;
  }
  return i.rho = function(s) {
    var o = Math.max(1e-3, +s), l = o * o, f = l * l;
    return e2(o, l, f);
  }, i;
}(Math.SQRT2, 2, 4);
var ei = 0;
var Ni = 0;
var vi = 0;
var kp = 1e3;
var C0;
var Ii;
var T0 = 0;
var vr = 0;
var Q0 = 0;
var Zi = typeof performance == "object" && performance.now ? performance : Date;
var _p = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e10) {
  setTimeout(e10, 17);
};
function ll() {
  return vr || (_p(Xx), vr = Zi.now() + Q0);
}
function Xx() {
  vr = 0;
}
function D0() {
  this._call = this._time = this._next = null;
}
D0.prototype = Sp.prototype = {
  constructor: D0,
  restart: function(e10, t, n) {
    if (typeof e10 != "function") throw new TypeError("callback is not a function");
    n = (n == null ? ll() : +n) + (t == null ? 0 : +t), !this._next && Ii !== this && (Ii ? Ii._next = this : C0 = this, Ii = this), this._call = e10, this._time = n, sa();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, sa());
  }
};
function Sp(e10, t, n) {
  var r = new D0();
  return r.restart(e10, t, n), r;
}
function Yx() {
  ll(), ++ei;
  for (var e10 = C0, t; e10; )
    (t = vr - e10._time) >= 0 && e10._call.call(void 0, t), e10 = e10._next;
  --ei;
}
function xh() {
  vr = (T0 = Zi.now()) + Q0, ei = Ni = 0;
  try {
    Yx();
  } finally {
    ei = 0, Jx(), vr = 0;
  }
}
function Zx() {
  var e10 = Zi.now(), t = e10 - T0;
  t > kp && (Q0 -= t, T0 = e10);
}
function Jx() {
  for (var e10, t = C0, n, r = 1 / 0; t; )
    t._call ? (r > t._time && (r = t._time), e10 = t, t = t._next) : (n = t._next, t._next = null, t = e10 ? e10._next = n : C0 = n);
  Ii = e10, sa(r);
}
function sa(e10) {
  if (!ei) {
    Ni && (Ni = clearTimeout(Ni));
    var t = e10 - vr;
    t > 24 ? (e10 < 1 / 0 && (Ni = setTimeout(xh, e10 - Zi.now() - Q0)), vi && (vi = clearInterval(vi))) : (vi || (T0 = Zi.now(), vi = setInterval(Zx, kp)), ei = 1, _p(xh));
  }
}
function wh(e10, t, n) {
  var r = new D0();
  return t = t == null ? 0 : +t, r.restart((i) => {
    r.stop(), e10(i + t);
  }, t, n), r;
}
var Qx = sl("start", "end", "cancel", "interrupt");
var ew = [];
var Ap = 0;
var vh = 1;
var ua = 2;
var n0 = 3;
var kh = 4;
var oa = 5;
var r0 = 6;
function eu(e10, t, n, r, i, s) {
  var o = e10.__transition;
  if (!o) e10.__transition = {};
  else if (n in o) return;
  tw(e10, n, {
    name: t,
    index: r,
    // For context during callback.
    group: i,
    // For context during callback.
    on: Qx,
    tween: ew,
    time: s.time,
    delay: s.delay,
    duration: s.duration,
    ease: s.ease,
    timer: null,
    state: Ap
  });
}
function cl(e10, t) {
  var n = rn(e10, t);
  if (n.state > Ap) throw new Error("too late; already scheduled");
  return n;
}
function yn(e10, t) {
  var n = rn(e10, t);
  if (n.state > n0) throw new Error("too late; already running");
  return n;
}
function rn(e10, t) {
  var n = e10.__transition;
  if (!n || !(n = n[t])) throw new Error("transition not found");
  return n;
}
function tw(e10, t, n) {
  var r = e10.__transition, i;
  r[t] = n, n.timer = Sp(s, 0, n.time);
  function s(h2) {
    n.state = vh, n.timer.restart(o, n.delay, n.time), n.delay <= h2 && o(h2 - n.delay);
  }
  function o(h2) {
    var p, b, v, k;
    if (n.state !== vh) return f();
    for (p in r)
      if (k = r[p], k.name === n.name) {
        if (k.state === n0) return wh(o);
        k.state === kh ? (k.state = r0, k.timer.stop(), k.on.call("interrupt", e10, e10.__data__, k.index, k.group), delete r[p]) : +p < t && (k.state = r0, k.timer.stop(), k.on.call("cancel", e10, e10.__data__, k.index, k.group), delete r[p]);
      }
    if (wh(function() {
      n.state === n0 && (n.state = kh, n.timer.restart(l, n.delay, n.time), l(h2));
    }), n.state = ua, n.on.call("start", e10, e10.__data__, n.index, n.group), n.state === ua) {
      for (n.state = n0, i = new Array(v = n.tween.length), p = 0, b = -1; p < v; ++p)
        (k = n.tween[p].value.call(e10, e10.__data__, n.index, n.group)) && (i[++b] = k);
      i.length = b + 1;
    }
  }
  function l(h2) {
    for (var p = h2 < n.duration ? n.ease.call(null, h2 / n.duration) : (n.timer.restart(f), n.state = oa, 1), b = -1, v = i.length; ++b < v; )
      i[b].call(e10, p);
    n.state === oa && (n.on.call("end", e10, e10.__data__, n.index, n.group), f());
  }
  function f() {
    n.state = r0, n.timer.stop(), delete r[t];
    for (var h2 in r) return;
    delete e10.__transition;
  }
}
function i0(e10, t) {
  var n = e10.__transition, r, i, s = true, o;
  if (n) {
    t = t == null ? null : t + "";
    for (o in n) {
      if ((r = n[o]).name !== t) {
        s = false;
        continue;
      }
      i = r.state > ua && r.state < oa, r.state = r0, r.timer.stop(), r.on.call(i ? "interrupt" : "cancel", e10, e10.__data__, r.index, r.group), delete n[o];
    }
    s && delete e10.__transition;
  }
}
function nw(e10) {
  return this.each(function() {
    i0(this, e10);
  });
}
function rw(e10, t) {
  var n, r;
  return function() {
    var i = yn(this, e10), s = i.tween;
    if (s !== n) {
      r = n = s;
      for (var o = 0, l = r.length; o < l; ++o)
        if (r[o].name === t) {
          r = r.slice(), r.splice(o, 1);
          break;
        }
    }
    i.tween = r;
  };
}
function iw(e10, t, n) {
  var r, i;
  if (typeof n != "function") throw new Error();
  return function() {
    var s = yn(this, e10), o = s.tween;
    if (o !== r) {
      i = (r = o).slice();
      for (var l = { name: t, value: n }, f = 0, h2 = i.length; f < h2; ++f)
        if (i[f].name === t) {
          i[f] = l;
          break;
        }
      f === h2 && i.push(l);
    }
    s.tween = i;
  };
}
function sw(e10, t) {
  var n = this._id;
  if (e10 += "", arguments.length < 2) {
    for (var r = rn(this.node(), n).tween, i = 0, s = r.length, o; i < s; ++i)
      if ((o = r[i]).name === e10)
        return o.value;
    return null;
  }
  return this.each((t == null ? rw : iw)(n, e10, t));
}
function fl(e10, t, n) {
  var r = e10._id;
  return e10.each(function() {
    var i = yn(this, r);
    (i.value || (i.value = {}))[t] = n.apply(this, arguments);
  }), function(i) {
    return rn(i, r).value[t];
  };
}
function Ep(e10, t) {
  var n;
  return (typeof t == "number" ? Wn : t instanceof Yi ? gh : (n = Yi(t)) ? (t = n, gh) : Rx)(e10, t);
}
function uw(e10) {
  return function() {
    this.removeAttribute(e10);
  };
}
function ow(e10) {
  return function() {
    this.removeAttributeNS(e10.space, e10.local);
  };
}
function aw(e10, t, n) {
  var r, i = n + "", s;
  return function() {
    var o = this.getAttribute(e10);
    return o === i ? null : o === r ? s : s = t(r = o, n);
  };
}
function lw(e10, t, n) {
  var r, i = n + "", s;
  return function() {
    var o = this.getAttributeNS(e10.space, e10.local);
    return o === i ? null : o === r ? s : s = t(r = o, n);
  };
}
function cw(e10, t, n) {
  var r, i, s;
  return function() {
    var o, l = n(this), f;
    return l == null ? void this.removeAttribute(e10) : (o = this.getAttribute(e10), f = l + "", o === f ? null : o === r && f === i ? s : (i = f, s = t(r = o, l)));
  };
}
function fw(e10, t, n) {
  var r, i, s;
  return function() {
    var o, l = n(this), f;
    return l == null ? void this.removeAttributeNS(e10.space, e10.local) : (o = this.getAttributeNS(e10.space, e10.local), f = l + "", o === f ? null : o === r && f === i ? s : (i = f, s = t(r = o, l)));
  };
}
function hw(e10, t) {
  var n = J0(e10), r = n === "transform" ? Ux : Ep;
  return this.attrTween(e10, typeof t == "function" ? (n.local ? fw : cw)(n, r, fl(this, "attr." + e10, t)) : t == null ? (n.local ? ow : uw)(n) : (n.local ? lw : aw)(n, r, t));
}
function dw(e10, t) {
  return function(n) {
    this.setAttribute(e10, t.call(this, n));
  };
}
function pw(e10, t) {
  return function(n) {
    this.setAttributeNS(e10.space, e10.local, t.call(this, n));
  };
}
function mw(e10, t) {
  var n, r;
  function i() {
    var s = t.apply(this, arguments);
    return s !== r && (n = (r = s) && pw(e10, s)), n;
  }
  return i._value = t, i;
}
function gw(e10, t) {
  var n, r;
  function i() {
    var s = t.apply(this, arguments);
    return s !== r && (n = (r = s) && dw(e10, s)), n;
  }
  return i._value = t, i;
}
function bw(e10, t) {
  var n = "attr." + e10;
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (t == null) return this.tween(n, null);
  if (typeof t != "function") throw new Error();
  var r = J0(e10);
  return this.tween(n, (r.local ? mw : gw)(r, t));
}
function yw(e10, t) {
  return function() {
    cl(this, e10).delay = +t.apply(this, arguments);
  };
}
function xw(e10, t) {
  return t = +t, function() {
    cl(this, e10).delay = t;
  };
}
function ww(e10) {
  var t = this._id;
  return arguments.length ? this.each((typeof e10 == "function" ? yw : xw)(t, e10)) : rn(this.node(), t).delay;
}
function vw(e10, t) {
  return function() {
    yn(this, e10).duration = +t.apply(this, arguments);
  };
}
function kw(e10, t) {
  return t = +t, function() {
    yn(this, e10).duration = t;
  };
}
function _w(e10) {
  var t = this._id;
  return arguments.length ? this.each((typeof e10 == "function" ? vw : kw)(t, e10)) : rn(this.node(), t).duration;
}
function Sw(e10, t) {
  if (typeof t != "function") throw new Error();
  return function() {
    yn(this, e10).ease = t;
  };
}
function Aw(e10) {
  var t = this._id;
  return arguments.length ? this.each(Sw(t, e10)) : rn(this.node(), t).ease;
}
function Ew(e10, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function") throw new Error();
    yn(this, e10).ease = n;
  };
}
function Cw(e10) {
  if (typeof e10 != "function") throw new Error();
  return this.each(Ew(this._id, e10));
}
function Tw(e10) {
  typeof e10 != "function" && (e10 = up(e10));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var s = t[i], o = s.length, l = r[i] = [], f, h2 = 0; h2 < o; ++h2)
      (f = s[h2]) && e10.call(f, f.__data__, h2, s) && l.push(f);
  return new $n(r, this._parents, this._name, this._id);
}
function Dw(e10) {
  if (e10._id !== this._id) throw new Error();
  for (var t = this._groups, n = e10._groups, r = t.length, i = n.length, s = Math.min(r, i), o = new Array(r), l = 0; l < s; ++l)
    for (var f = t[l], h2 = n[l], p = f.length, b = o[l] = new Array(p), v, k = 0; k < p; ++k)
      (v = f[k] || h2[k]) && (b[k] = v);
  for (; l < r; ++l)
    o[l] = t[l];
  return new $n(o, this._parents, this._name, this._id);
}
function Mw(e10) {
  return (e10 + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function Nw(e10, t, n) {
  var r, i, s = Mw(t) ? cl : yn;
  return function() {
    var o = s(this, e10), l = o.on;
    l !== r && (i = (r = l).copy()).on(t, n), o.on = i;
  };
}
function Iw(e10, t) {
  var n = this._id;
  return arguments.length < 2 ? rn(this.node(), n).on.on(e10) : this.each(Nw(n, e10, t));
}
function Fw(e10) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition) if (+n !== e10) return;
    t && t.removeChild(this);
  };
}
function Bw() {
  return this.on("end.remove", Fw(this._id));
}
function Ow(e10) {
  var t = this._name, n = this._id;
  typeof e10 != "function" && (e10 = ul(e10));
  for (var r = this._groups, i = r.length, s = new Array(i), o = 0; o < i; ++o)
    for (var l = r[o], f = l.length, h2 = s[o] = new Array(f), p, b, v = 0; v < f; ++v)
      (p = l[v]) && (b = e10.call(p, p.__data__, v, l)) && ("__data__" in p && (b.__data__ = p.__data__), h2[v] = b, eu(h2[v], t, n, v, h2, rn(p, n)));
  return new $n(s, this._parents, t, n);
}
function zw(e10) {
  var t = this._name, n = this._id;
  typeof e10 != "function" && (e10 = sp(e10));
  for (var r = this._groups, i = r.length, s = [], o = [], l = 0; l < i; ++l)
    for (var f = r[l], h2 = f.length, p, b = 0; b < h2; ++b)
      if (p = f[b]) {
        for (var v = e10.call(p, p.__data__, b, f), k, w = rn(p, n), A = 0, T = v.length; A < T; ++A)
          (k = v[A]) && eu(k, t, n, A, v, w);
        s.push(v), o.push(p);
      }
  return new $n(s, o, t, n);
}
var $w = ls.prototype.constructor;
function Lw() {
  return new $w(this._groups, this._parents);
}
function qw(e10, t) {
  var n, r, i;
  return function() {
    var s = Qr(this, e10), o = (this.style.removeProperty(e10), Qr(this, e10));
    return s === o ? null : s === n && o === r ? i : i = t(n = s, r = o);
  };
}
function Cp(e10) {
  return function() {
    this.style.removeProperty(e10);
  };
}
function Rw(e10, t, n) {
  var r, i = n + "", s;
  return function() {
    var o = Qr(this, e10);
    return o === i ? null : o === r ? s : s = t(r = o, n);
  };
}
function Pw(e10, t, n) {
  var r, i, s;
  return function() {
    var o = Qr(this, e10), l = n(this), f = l + "";
    return l == null && (f = l = (this.style.removeProperty(e10), Qr(this, e10))), o === f ? null : o === r && f === i ? s : (i = f, s = t(r = o, l));
  };
}
function Hw(e10, t) {
  var n, r, i, s = "style." + t, o = "end." + s, l;
  return function() {
    var f = yn(this, e10), h2 = f.on, p = f.value[s] == null ? l || (l = Cp(t)) : void 0;
    (h2 !== n || i !== p) && (r = (n = h2).copy()).on(o, i = p), f.on = r;
  };
}
function jw(e10, t, n) {
  var r = (e10 += "") == "transform" ? jx : Ep;
  return t == null ? this.styleTween(e10, qw(e10, r)).on("end.style." + e10, Cp(e10)) : typeof t == "function" ? this.styleTween(e10, Pw(e10, r, fl(this, "style." + e10, t))).each(Hw(this._id, e10)) : this.styleTween(e10, Rw(e10, r, t), n).on("end.style." + e10, null);
}
function Uw(e10, t, n) {
  return function(r) {
    this.style.setProperty(e10, t.call(this, r), n);
  };
}
function Vw(e10, t, n) {
  var r, i;
  function s() {
    var o = t.apply(this, arguments);
    return o !== i && (r = (i = o) && Uw(e10, o, n)), r;
  }
  return s._value = t, s;
}
function Gw(e10, t, n) {
  var r = "style." + (e10 += "");
  if (arguments.length < 2) return (r = this.tween(r)) && r._value;
  if (t == null) return this.tween(r, null);
  if (typeof t != "function") throw new Error();
  return this.tween(r, Vw(e10, t, n ?? ""));
}
function Ww(e10) {
  return function() {
    this.textContent = e10;
  };
}
function Kw(e10) {
  return function() {
    var t = e10(this);
    this.textContent = t ?? "";
  };
}
function Xw(e10) {
  return this.tween("text", typeof e10 == "function" ? Kw(fl(this, "text", e10)) : Ww(e10 == null ? "" : e10 + ""));
}
function Yw(e10) {
  return function(t) {
    this.textContent = e10.call(this, t);
  };
}
function Zw(e10) {
  var t, n;
  function r() {
    var i = e10.apply(this, arguments);
    return i !== n && (t = (n = i) && Yw(i)), t;
  }
  return r._value = e10, r;
}
function Jw(e10) {
  var t = "text";
  if (arguments.length < 1) return (t = this.tween(t)) && t._value;
  if (e10 == null) return this.tween(t, null);
  if (typeof e10 != "function") throw new Error();
  return this.tween(t, Zw(e10));
}
function Qw() {
  for (var e10 = this._name, t = this._id, n = Tp(), r = this._groups, i = r.length, s = 0; s < i; ++s)
    for (var o = r[s], l = o.length, f, h2 = 0; h2 < l; ++h2)
      if (f = o[h2]) {
        var p = rn(f, t);
        eu(f, e10, n, h2, o, {
          time: p.time + p.delay + p.duration,
          delay: 0,
          duration: p.duration,
          ease: p.ease
        });
      }
  return new $n(r, this._parents, e10, n);
}
function ev() {
  var e10, t, n = this, r = n._id, i = n.size();
  return new Promise(function(s, o) {
    var l = { value: o }, f = { value: function() {
      --i === 0 && s();
    } };
    n.each(function() {
      var h2 = yn(this, r), p = h2.on;
      p !== e10 && (t = (e10 = p).copy(), t._.cancel.push(l), t._.interrupt.push(l), t._.end.push(f)), h2.on = t;
    }), i === 0 && s();
  });
}
var tv = 0;
function $n(e10, t, n, r) {
  this._groups = e10, this._parents = t, this._name = n, this._id = r;
}
function Tp() {
  return ++tv;
}
var Tn = ls.prototype;
$n.prototype = {
  constructor: $n,
  select: Ow,
  selectAll: zw,
  selectChild: Tn.selectChild,
  selectChildren: Tn.selectChildren,
  filter: Tw,
  merge: Dw,
  selection: Lw,
  transition: Qw,
  call: Tn.call,
  nodes: Tn.nodes,
  node: Tn.node,
  size: Tn.size,
  empty: Tn.empty,
  each: Tn.each,
  on: Iw,
  attr: hw,
  attrTween: bw,
  style: jw,
  styleTween: Gw,
  text: Xw,
  textTween: Jw,
  remove: Bw,
  tween: sw,
  delay: ww,
  duration: _w,
  ease: Aw,
  easeVarying: Cw,
  end: ev,
  [Symbol.iterator]: Tn[Symbol.iterator]
};
function nv(e10) {
  return ((e10 *= 2) <= 1 ? e10 * e10 * e10 : (e10 -= 2) * e10 * e10 + 2) / 2;
}
var rv = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: nv
};
function iv(e10, t) {
  for (var n; !(n = e10.__transition) || !(n = n[t]); )
    if (!(e10 = e10.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function sv(e10) {
  var t, n;
  e10 instanceof $n ? (t = e10._id, e10 = e10._name) : (t = Tp(), (n = rv).time = ll(), e10 = e10 == null ? null : e10 + "");
  for (var r = this._groups, i = r.length, s = 0; s < i; ++s)
    for (var o = r[s], l = o.length, f, h2 = 0; h2 < l; ++h2)
      (f = o[h2]) && eu(f, e10, t, h2, o, n || iv(f, t));
  return new $n(r, this._parents, e10, t);
}
ls.prototype.interrupt = nw;
ls.prototype.transition = sv;
var aa = Math.PI;
var la = 2 * aa;
var fr = 1e-6;
var uv = la - fr;
function Dp(e10) {
  this._ += e10[0];
  for (let t = 1, n = e10.length; t < n; ++t)
    this._ += arguments[t] + e10[t];
}
function ov(e10) {
  let t = Math.floor(e10);
  if (!(t >= 0)) throw new Error(`invalid digits: ${e10}`);
  if (t > 15) return Dp;
  const n = 10 ** t;
  return function(r) {
    this._ += r[0];
    for (let i = 1, s = r.length; i < s; ++i)
      this._ += Math.round(arguments[i] * n) / n + r[i];
  };
}
var av = class {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? Dp : ov(t);
  }
  moveTo(t, n) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, n) {
    this._append`L${this._x1 = +t},${this._y1 = +n}`;
  }
  quadraticCurveTo(t, n, r, i) {
    this._append`Q${+t},${+n},${this._x1 = +r},${this._y1 = +i}`;
  }
  bezierCurveTo(t, n, r, i, s, o) {
    this._append`C${+t},${+n},${+r},${+i},${this._x1 = +s},${this._y1 = +o}`;
  }
  arcTo(t, n, r, i, s) {
    if (t = +t, n = +n, r = +r, i = +i, s = +s, s < 0) throw new Error(`negative radius: ${s}`);
    let o = this._x1, l = this._y1, f = r - t, h2 = i - n, p = o - t, b = l - n, v = p * p + b * b;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = n}`;
    else if (v > fr) if (!(Math.abs(b * f - h2 * p) > fr) || !s)
      this._append`L${this._x1 = t},${this._y1 = n}`;
    else {
      let k = r - o, w = i - l, A = f * f + h2 * h2, T = k * k + w * w, D = Math.sqrt(A), N = Math.sqrt(v), O = s * Math.tan((aa - Math.acos((A + v - T) / (2 * D * N))) / 2), q = O / N, z = O / D;
      Math.abs(q - 1) > fr && this._append`L${t + q * p},${n + q * b}`, this._append`A${s},${s},0,0,${+(b * k > p * w)},${this._x1 = t + z * f},${this._y1 = n + z * h2}`;
    }
  }
  arc(t, n, r, i, s, o) {
    if (t = +t, n = +n, r = +r, o = !!o, r < 0) throw new Error(`negative radius: ${r}`);
    let l = r * Math.cos(i), f = r * Math.sin(i), h2 = t + l, p = n + f, b = 1 ^ o, v = o ? i - s : s - i;
    this._x1 === null ? this._append`M${h2},${p}` : (Math.abs(this._x1 - h2) > fr || Math.abs(this._y1 - p) > fr) && this._append`L${h2},${p}`, r && (v < 0 && (v = v % la + la), v > uv ? this._append`A${r},${r},0,1,${b},${t - l},${n - f}A${r},${r},0,1,${b},${this._x1 = h2},${this._y1 = p}` : v > fr && this._append`A${r},${r},0,${+(v >= aa)},${b},${this._x1 = t + r * Math.cos(s)},${this._y1 = n + r * Math.sin(s)}`);
  }
  rect(t, n, r, i) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${r = +r}v${+i}h${-r}Z`;
  }
  toString() {
    return this._;
  }
};
function lv(e10, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(e10);
      break;
    default:
      this.range(t).domain(e10);
      break;
  }
  return this;
}
var _h = Symbol("implicit");
function hl() {
  var e10 = new nh(), t = [], n = [], r = _h;
  function i(s) {
    let o = e10.get(s);
    if (o === void 0) {
      if (r !== _h) return r;
      e10.set(s, o = t.push(s) - 1);
    }
    return n[o % n.length];
  }
  return i.domain = function(s) {
    if (!arguments.length) return t.slice();
    t = [], e10 = new nh();
    for (const o of s)
      e10.has(o) || e10.set(o, t.push(o) - 1);
    return i;
  }, i.range = function(s) {
    return arguments.length ? (n = Array.from(s), i) : n.slice();
  }, i.unknown = function(s) {
    return arguments.length ? (r = s, i) : r;
  }, i.copy = function() {
    return hl(t, n).unknown(r);
  }, lv.apply(i, arguments), i;
}
function cv(e10) {
  for (var t = e10.length / 6 | 0, n = new Array(t), r = 0; r < t; ) n[r] = "#" + e10.slice(r * 6, ++r * 6);
  return n;
}
var fv = cv("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");
function Sh(e10) {
  return function() {
    return e10;
  };
}
function hv(e10) {
  let t = 3;
  return e10.digits = function(n) {
    if (!arguments.length) return t;
    if (n == null)
      t = null;
    else {
      const r = Math.floor(n);
      if (!(r >= 0)) throw new RangeError(`invalid digits: ${n}`);
      t = r;
    }
    return e10;
  }, () => new av(t);
}
var dv = Array.prototype.slice;
function pv(e10) {
  return e10[0];
}
function mv(e10) {
  return e10[1];
}
var gv = class {
  constructor(t, n) {
    this._context = t, this._x = n;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(t, n) {
    switch (t = +t, n = +n, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, n, t, n) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + n) / 2, t, this._y0, t, n);
        break;
      }
    }
    this._x0 = t, this._y0 = n;
  }
};
function bv(e10) {
  return new gv(e10, true);
}
function yv(e10) {
  return e10.source;
}
function xv(e10) {
  return e10.target;
}
function wv(e10) {
  let t = yv, n = xv, r = pv, i = mv, s = null, o = null, l = hv(f);
  function f() {
    let h2;
    const p = dv.call(arguments), b = t.apply(this, p), v = n.apply(this, p);
    if (s == null && (o = e10(h2 = l())), o.lineStart(), p[0] = b, o.point(+r.apply(this, p), +i.apply(this, p)), p[0] = v, o.point(+r.apply(this, p), +i.apply(this, p)), o.lineEnd(), h2) return o = null, h2 + "" || null;
  }
  return f.source = function(h2) {
    return arguments.length ? (t = h2, f) : t;
  }, f.target = function(h2) {
    return arguments.length ? (n = h2, f) : n;
  }, f.x = function(h2) {
    return arguments.length ? (r = typeof h2 == "function" ? h2 : Sh(+h2), f) : r;
  }, f.y = function(h2) {
    return arguments.length ? (i = typeof h2 == "function" ? h2 : Sh(+h2), f) : i;
  }, f.context = function(h2) {
    return arguments.length ? (h2 == null ? s = o = null : o = e10(s = h2), f) : s;
  }, f;
}
function vv() {
  return wv(bv);
}
var Gs = (e10) => () => e10;
function kv(e10, {
  sourceEvent: t,
  target: n,
  transform: r,
  dispatch: i
}) {
  Object.defineProperties(this, {
    type: { value: e10, enumerable: true, configurable: true },
    sourceEvent: { value: t, enumerable: true, configurable: true },
    target: { value: n, enumerable: true, configurable: true },
    transform: { value: r, enumerable: true, configurable: true },
    _: { value: i }
  });
}
function Bn(e10, t, n) {
  this.k = e10, this.x = t, this.y = n;
}
Bn.prototype = {
  constructor: Bn,
  scale: function(e10) {
    return e10 === 1 ? this : new Bn(this.k * e10, this.x, this.y);
  },
  translate: function(e10, t) {
    return e10 === 0 & t === 0 ? this : new Bn(this.k, this.x + this.k * e10, this.y + this.k * t);
  },
  apply: function(e10) {
    return [e10[0] * this.k + this.x, e10[1] * this.k + this.y];
  },
  applyX: function(e10) {
    return e10 * this.k + this.x;
  },
  applyY: function(e10) {
    return e10 * this.k + this.y;
  },
  invert: function(e10) {
    return [(e10[0] - this.x) / this.k, (e10[1] - this.y) / this.k];
  },
  invertX: function(e10) {
    return (e10 - this.x) / this.k;
  },
  invertY: function(e10) {
    return (e10 - this.y) / this.k;
  },
  rescaleX: function(e10) {
    return e10.copy().domain(e10.range().map(this.invertX, this).map(e10.invert, e10));
  },
  rescaleY: function(e10) {
    return e10.copy().domain(e10.range().map(this.invertY, this).map(e10.invert, e10));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var tu = new Bn(1, 0, 0);
zr.prototype = Bn.prototype;
function zr(e10) {
  for (; !e10.__zoom; ) if (!(e10 = e10.parentNode)) return tu;
  return e10.__zoom;
}
function yo(e10) {
  e10.stopImmediatePropagation();
}
function ki(e10) {
  e10.preventDefault(), e10.stopImmediatePropagation();
}
function _v(e10) {
  return (!e10.ctrlKey || e10.type === "wheel") && !e10.button;
}
function Sv() {
  var e10 = this;
  return e10 instanceof SVGElement ? (e10 = e10.ownerSVGElement || e10, e10.hasAttribute("viewBox") ? (e10 = e10.viewBox.baseVal, [[e10.x, e10.y], [e10.x + e10.width, e10.y + e10.height]]) : [[0, 0], [e10.width.baseVal.value, e10.height.baseVal.value]]) : [[0, 0], [e10.clientWidth, e10.clientHeight]];
}
function Ah() {
  return this.__zoom || tu;
}
function Av(e10) {
  return -e10.deltaY * (e10.deltaMode === 1 ? 0.05 : e10.deltaMode ? 1 : 2e-3) * (e10.ctrlKey ? 10 : 1);
}
function Ev() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Cv(e10, t, n) {
  var r = e10.invertX(t[0][0]) - n[0][0], i = e10.invertX(t[1][0]) - n[1][0], s = e10.invertY(t[0][1]) - n[0][1], o = e10.invertY(t[1][1]) - n[1][1];
  return e10.translate(
    i > r ? (r + i) / 2 : Math.min(0, r) || Math.max(0, i),
    o > s ? (s + o) / 2 : Math.min(0, s) || Math.max(0, o)
  );
}
function Tv() {
  var e10 = _v, t = Sv, n = Cv, r = Av, i = Ev, s = [0, 1 / 0], o = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], l = 250, f = Kx, h2 = sl("start", "zoom", "end"), p, b, v, k = 500, w = 150, A = 0, T = 10;
  function D($) {
    $.property("__zoom", Ah).on("wheel.zoom", K, { passive: false }).on("mousedown.zoom", V).on("dblclick.zoom", te).filter(i).on("touchstart.zoom", Z).on("touchmove.zoom", se).on("touchend.zoom touchcancel.zoom", fe).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  D.transform = function($, X, j, Q) {
    var ee = $.selection ? $.selection() : $;
    ee.property("__zoom", Ah), $ !== ee ? z($, X, j, Q) : ee.interrupt().each(function() {
      R(this, arguments).event(Q).start().zoom(null, typeof X == "function" ? X.apply(this, arguments) : X).end();
    });
  }, D.scaleBy = function($, X, j, Q) {
    D.scaleTo($, function() {
      var ee = this.__zoom.k, le = typeof X == "function" ? X.apply(this, arguments) : X;
      return ee * le;
    }, j, Q);
  }, D.scaleTo = function($, X, j, Q) {
    D.transform($, function() {
      var ee = t.apply(this, arguments), le = this.__zoom, ae = j == null ? q(ee) : typeof j == "function" ? j.apply(this, arguments) : j, ne = le.invert(ae), P = typeof X == "function" ? X.apply(this, arguments) : X;
      return n(O(N(le, P), ae, ne), ee, o);
    }, j, Q);
  }, D.translateBy = function($, X, j, Q) {
    D.transform($, function() {
      return n(this.__zoom.translate(
        typeof X == "function" ? X.apply(this, arguments) : X,
        typeof j == "function" ? j.apply(this, arguments) : j
      ), t.apply(this, arguments), o);
    }, null, Q);
  }, D.translateTo = function($, X, j, Q, ee) {
    D.transform($, function() {
      var le = t.apply(this, arguments), ae = this.__zoom, ne = Q == null ? q(le) : typeof Q == "function" ? Q.apply(this, arguments) : Q;
      return n(tu.translate(ne[0], ne[1]).scale(ae.k).translate(
        typeof X == "function" ? -X.apply(this, arguments) : -X,
        typeof j == "function" ? -j.apply(this, arguments) : -j
      ), le, o);
    }, Q, ee);
  };
  function N($, X) {
    return X = Math.max(s[0], Math.min(s[1], X)), X === $.k ? $ : new Bn(X, $.x, $.y);
  }
  function O($, X, j) {
    var Q = X[0] - j[0] * $.k, ee = X[1] - j[1] * $.k;
    return Q === $.x && ee === $.y ? $ : new Bn($.k, Q, ee);
  }
  function q($) {
    return [(+$[0][0] + +$[1][0]) / 2, (+$[0][1] + +$[1][1]) / 2];
  }
  function z($, X, j, Q) {
    $.on("start.zoom", function() {
      R(this, arguments).event(Q).start();
    }).on("interrupt.zoom end.zoom", function() {
      R(this, arguments).event(Q).end();
    }).tween("zoom", function() {
      var ee = this, le = arguments, ae = R(ee, le).event(Q), ne = t.apply(ee, le), P = j == null ? q(ne) : typeof j == "function" ? j.apply(ee, le) : j, he = Math.max(ne[1][0] - ne[0][0], ne[1][1] - ne[0][1]), ge = ee.__zoom, De = typeof X == "function" ? X.apply(ee, le) : X, He = f(ge.invert(P).concat(he / ge.k), De.invert(P).concat(he / De.k));
      return function(Y) {
        if (Y === 1) Y = De;
        else {
          var Me = He(Y), _e = he / Me[2];
          Y = new Bn(_e, P[0] - Me[0] * _e, P[1] - Me[1] * _e);
        }
        ae.zoom(null, Y);
      };
    });
  }
  function R($, X, j) {
    return !j && $.__zooming || new J($, X);
  }
  function J($, X) {
    this.that = $, this.args = X, this.active = 0, this.sourceEvent = null, this.extent = t.apply($, X), this.taps = 0;
  }
  J.prototype = {
    event: function($) {
      return $ && (this.sourceEvent = $), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function($, X) {
      return this.mouse && $ !== "mouse" && (this.mouse[1] = X.invert(this.mouse[0])), this.touch0 && $ !== "touch" && (this.touch0[1] = X.invert(this.touch0[0])), this.touch1 && $ !== "touch" && (this.touch1[1] = X.invert(this.touch1[0])), this.that.__zoom = X, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function($) {
      var X = Yn(this.that).datum();
      h2.call(
        $,
        this.that,
        new kv($, {
          sourceEvent: this.sourceEvent,
          target: D,
          transform: this.that.__zoom,
          dispatch: h2
        }),
        X
      );
    }
  };
  function K($, ...X) {
    if (!e10.apply(this, arguments)) return;
    var j = R(this, X).event($), Q = this.__zoom, ee = Math.max(s[0], Math.min(s[1], Q.k * Math.pow(2, r.apply(this, arguments)))), le = ur($);
    if (j.wheel)
      (j.mouse[0][0] !== le[0] || j.mouse[0][1] !== le[1]) && (j.mouse[1] = Q.invert(j.mouse[0] = le)), clearTimeout(j.wheel);
    else {
      if (Q.k === ee) return;
      j.mouse = [le, Q.invert(le)], i0(this), j.start();
    }
    ki($), j.wheel = setTimeout(ae, w), j.zoom("mouse", n(O(N(Q, ee), j.mouse[0], j.mouse[1]), j.extent, o));
    function ae() {
      j.wheel = null, j.end();
    }
  }
  function V($, ...X) {
    if (v || !e10.apply(this, arguments)) return;
    var j = $.currentTarget, Q = R(this, X, true).event($), ee = Yn($.view).on("mousemove.zoom", P, true).on("mouseup.zoom", he, true), le = ur($, j), ae = $.clientX, ne = $.clientY;
    vx($.view), yo($), Q.mouse = [le, this.__zoom.invert(le)], i0(this), Q.start();
    function P(ge) {
      if (ki(ge), !Q.moved) {
        var De = ge.clientX - ae, He = ge.clientY - ne;
        Q.moved = De * De + He * He > A;
      }
      Q.event(ge).zoom("mouse", n(O(Q.that.__zoom, Q.mouse[0] = ur(ge, j), Q.mouse[1]), Q.extent, o));
    }
    function he(ge) {
      ee.on("mousemove.zoom mouseup.zoom", null), kx(ge.view, Q.moved), ki(ge), Q.event(ge).end();
    }
  }
  function te($, ...X) {
    if (e10.apply(this, arguments)) {
      var j = this.__zoom, Q = ur($.changedTouches ? $.changedTouches[0] : $, this), ee = j.invert(Q), le = j.k * ($.shiftKey ? 0.5 : 2), ae = n(O(N(j, le), Q, ee), t.apply(this, X), o);
      ki($), l > 0 ? Yn(this).transition().duration(l).call(z, ae, Q, $) : Yn(this).call(D.transform, ae, Q, $);
    }
  }
  function Z($, ...X) {
    if (e10.apply(this, arguments)) {
      var j = $.touches, Q = j.length, ee = R(this, X, $.changedTouches.length === Q).event($), le, ae, ne, P;
      for (yo($), ae = 0; ae < Q; ++ae)
        ne = j[ae], P = ur(ne, this), P = [P, this.__zoom.invert(P), ne.identifier], ee.touch0 ? !ee.touch1 && ee.touch0[2] !== P[2] && (ee.touch1 = P, ee.taps = 0) : (ee.touch0 = P, le = true, ee.taps = 1 + !!p);
      p && (p = clearTimeout(p)), le && (ee.taps < 2 && (b = P[0], p = setTimeout(function() {
        p = null;
      }, k)), i0(this), ee.start());
    }
  }
  function se($, ...X) {
    if (this.__zooming) {
      var j = R(this, X).event($), Q = $.changedTouches, ee = Q.length, le, ae, ne, P;
      for (ki($), le = 0; le < ee; ++le)
        ae = Q[le], ne = ur(ae, this), j.touch0 && j.touch0[2] === ae.identifier ? j.touch0[0] = ne : j.touch1 && j.touch1[2] === ae.identifier && (j.touch1[0] = ne);
      if (ae = j.that.__zoom, j.touch1) {
        var he = j.touch0[0], ge = j.touch0[1], De = j.touch1[0], He = j.touch1[1], Y = (Y = De[0] - he[0]) * Y + (Y = De[1] - he[1]) * Y, Me = (Me = He[0] - ge[0]) * Me + (Me = He[1] - ge[1]) * Me;
        ae = N(ae, Math.sqrt(Y / Me)), ne = [(he[0] + De[0]) / 2, (he[1] + De[1]) / 2], P = [(ge[0] + He[0]) / 2, (ge[1] + He[1]) / 2];
      } else if (j.touch0) ne = j.touch0[0], P = j.touch0[1];
      else return;
      j.zoom("touch", n(O(ae, ne, P), j.extent, o));
    }
  }
  function fe($, ...X) {
    if (this.__zooming) {
      var j = R(this, X).event($), Q = $.changedTouches, ee = Q.length, le, ae;
      for (yo($), v && clearTimeout(v), v = setTimeout(function() {
        v = null;
      }, k), le = 0; le < ee; ++le)
        ae = Q[le], j.touch0 && j.touch0[2] === ae.identifier ? delete j.touch0 : j.touch1 && j.touch1[2] === ae.identifier && delete j.touch1;
      if (j.touch1 && !j.touch0 && (j.touch0 = j.touch1, delete j.touch1), j.touch0) j.touch0[1] = this.__zoom.invert(j.touch0[0]);
      else if (j.end(), j.taps === 2 && (ae = ur(ae, this), Math.hypot(b[0] - ae[0], b[1] - ae[1]) < T)) {
        var ne = Yn(this).on("dblclick.zoom");
        ne && ne.apply(this, arguments);
      }
    }
  }
  return D.wheelDelta = function($) {
    return arguments.length ? (r = typeof $ == "function" ? $ : Gs(+$), D) : r;
  }, D.filter = function($) {
    return arguments.length ? (e10 = typeof $ == "function" ? $ : Gs(!!$), D) : e10;
  }, D.touchable = function($) {
    return arguments.length ? (i = typeof $ == "function" ? $ : Gs(!!$), D) : i;
  }, D.extent = function($) {
    return arguments.length ? (t = typeof $ == "function" ? $ : Gs([[+$[0][0], +$[0][1]], [+$[1][0], +$[1][1]]]), D) : t;
  }, D.scaleExtent = function($) {
    return arguments.length ? (s[0] = +$[0], s[1] = +$[1], D) : [s[0], s[1]];
  }, D.translateExtent = function($) {
    return arguments.length ? (o[0][0] = +$[0][0], o[1][0] = +$[1][0], o[0][1] = +$[0][1], o[1][1] = +$[1][1], D) : [[o[0][0], o[0][1]], [o[1][0], o[1][1]]];
  }, D.constrain = function($) {
    return arguments.length ? (n = $, D) : n;
  }, D.duration = function($) {
    return arguments.length ? (l = +$, D) : l;
  }, D.interpolate = function($) {
    return arguments.length ? (f = $, D) : f;
  }, D.on = function() {
    var $ = h2.on.apply(h2, arguments);
    return $ === h2 ? D : $;
  }, D.clickDistance = function($) {
    return arguments.length ? (A = ($ = +$) * $, D) : Math.sqrt(A);
  }, D.tapDistance = function($) {
    return arguments.length ? (T = +$, D) : T;
  }, D;
}
var Mp = typeof navigator < "u" && navigator.userAgent.includes("Macintosh");
var Dv = hl(fv);
var Np = (e10 = 1, t = 3, n = 2) => (r) => e10 + t / n ** r.state.depth;
var Ip = {
  autoFit: false,
  duration: 500,
  embedGlobalCSS: true,
  fitRatio: 0.95,
  maxInitialScale: 2,
  scrollForPan: Mp,
  initialExpandLevel: -1,
  zoom: true,
  pan: true,
  toggleRecursively: false,
  color: (e10) => {
    var t;
    return Dv(`${((t = e10.state) == null ? void 0 : t.path) || ""}`);
  },
  lineWidth: Np(),
  maxWidth: 0,
  nodeMinHeight: 16,
  paddingX: 8,
  spacingHorizontal: 80,
  spacingVertical: 5
};
function Mv(e10) {
  const t = {}, n = { ...e10 }, { color: r, colorFreezeLevel: i, lineWidth: s } = n;
  if ((r == null ? void 0 : r.length) === 1) {
    const o = r[0];
    t.color = () => o;
  } else if (r != null && r.length) {
    const o = hl(r);
    t.color = (l) => o(`${l.state.path}`);
  }
  if (i) {
    const o = t.color || Ip.color;
    t.color = (l) => (l = {
      ...l,
      state: {
        ...l.state,
        path: l.state.path.split(".").slice(0, i).join(".")
      }
    }, o(l));
  }
  if (s) {
    const o = Array.isArray(s) ? s : [s, 0, 1];
    t.lineWidth = Np(
      ...o
    );
  }
  return [
    "duration",
    "fitRatio",
    "initialExpandLevel",
    "maxInitialScale",
    "maxWidth",
    "nodeMinHeight",
    "paddingX",
    "spacingHorizontal",
    "spacingVertical"
  ].forEach((o) => {
    const l = n[o];
    typeof l == "number" && (t[o] = l);
  }), ["zoom", "pan"].forEach((o) => {
    const l = n[o];
    l != null && (t[o] = !!l);
  }), t;
}
function Nv(e10) {
  let t = 0;
  for (let n = 0; n < e10.length; n++)
    t = (t << 5) - t + e10.charCodeAt(n) | 0;
  return (t >>> 0).toString(36);
}
function zt(e10) {
  if (typeof e10 == "string") {
    const n = e10;
    e10 = (r) => r.matches(n);
  }
  const t = e10;
  return function() {
    let n = Array.from(this.childNodes);
    return t && (n = n.filter((r) => t(r))), n;
  };
}
function Iv(e10) {
  var t = 0, n = e10.children, r = n && n.length;
  if (!r) t = 1;
  else for (; --r >= 0; ) t += n[r].value;
  e10.value = t;
}
function Fv() {
  return this.eachAfter(Iv);
}
function Bv(e10) {
  var t = this, n, r = [t], i, s, o;
  do
    for (n = r.reverse(), r = []; t = n.pop(); )
      if (e10(t), i = t.children, i) for (s = 0, o = i.length; s < o; ++s)
        r.push(i[s]);
  while (r.length);
  return this;
}
function Ov(e10) {
  for (var t = this, n = [t], r, i; t = n.pop(); )
    if (e10(t), r = t.children, r) for (i = r.length - 1; i >= 0; --i)
      n.push(r[i]);
  return this;
}
function zv(e10) {
  for (var t = this, n = [t], r = [], i, s, o; t = n.pop(); )
    if (r.push(t), i = t.children, i) for (s = 0, o = i.length; s < o; ++s)
      n.push(i[s]);
  for (; t = r.pop(); )
    e10(t);
  return this;
}
function $v(e10) {
  return this.eachAfter(function(t) {
    for (var n = +e10(t.data) || 0, r = t.children, i = r && r.length; --i >= 0; ) n += r[i].value;
    t.value = n;
  });
}
function Lv(e10) {
  return this.eachBefore(function(t) {
    t.children && t.children.sort(e10);
  });
}
function qv(e10) {
  for (var t = this, n = Rv(t, e10), r = [t]; t !== n; )
    t = t.parent, r.push(t);
  for (var i = r.length; e10 !== n; )
    r.splice(i, 0, e10), e10 = e10.parent;
  return r;
}
function Rv(e10, t) {
  if (e10 === t) return e10;
  var n = e10.ancestors(), r = t.ancestors(), i = null;
  for (e10 = n.pop(), t = r.pop(); e10 === t; )
    i = e10, e10 = n.pop(), t = r.pop();
  return i;
}
function Pv() {
  for (var e10 = this, t = [e10]; e10 = e10.parent; )
    t.push(e10);
  return t;
}
function Hv() {
  var e10 = [];
  return this.each(function(t) {
    e10.push(t);
  }), e10;
}
function jv() {
  var e10 = [];
  return this.eachBefore(function(t) {
    t.children || e10.push(t);
  }), e10;
}
function Uv() {
  var e10 = this, t = [];
  return e10.each(function(n) {
    n !== e10 && t.push({ source: n.parent, target: n });
  }), t;
}
function dl(e10, t) {
  var n = new M0(e10), r = +e10.value && (n.value = e10.value), i, s = [n], o, l, f, h2;
  for (t == null && (t = Gv); i = s.pop(); )
    if (r && (i.value = +i.data.value), (l = t(i.data)) && (h2 = l.length))
      for (i.children = new Array(h2), f = h2 - 1; f >= 0; --f)
        s.push(o = i.children[f] = new M0(l[f])), o.parent = i, o.depth = i.depth + 1;
  return n.eachBefore(Kv);
}
function Vv() {
  return dl(this).eachBefore(Wv);
}
function Gv(e10) {
  return e10.children;
}
function Wv(e10) {
  e10.data = e10.data.data;
}
function Kv(e10) {
  var t = 0;
  do
    e10.height = t;
  while ((e10 = e10.parent) && e10.height < ++t);
}
function M0(e10) {
  this.data = e10, this.depth = this.height = 0, this.parent = null;
}
M0.prototype = dl.prototype = {
  constructor: M0,
  count: Fv,
  each: Bv,
  eachAfter: zv,
  eachBefore: Ov,
  sum: $v,
  sort: Lv,
  path: qv,
  ancestors: Pv,
  descendants: Hv,
  leaves: jv,
  links: Uv,
  copy: Vv
};
var Xv = "2.1.2";
var Yv = {
  version: Xv
};
var { version: Zv } = Yv;
var Jv = Object.freeze({
  children: (e10) => e10.children,
  nodeSize: (e10) => e10.data.size,
  spacing: 0
});
function Bp(e10) {
  const t = Object.assign({}, Jv, e10);
  function n(l) {
    const f = t[l];
    return typeof f == "function" ? f : () => f;
  }
  function r(l) {
    const f = o(s(), l, (h2) => h2.children);
    return f.update(), f.data;
  }
  function i() {
    const l = n("nodeSize"), f = n("spacing");
    return class Fp extends dl.prototype.constructor {
      constructor(p) {
        super(p);
      }
      copy() {
        const p = o(this.constructor, this, (b) => b.children);
        return p.each((b) => b.data = b.data.data), p;
      }
      get size() {
        return l(this);
      }
      spacing(p) {
        return f(this, p);
      }
      get nodes() {
        return this.descendants();
      }
      get xSize() {
        return this.size[0];
      }
      get ySize() {
        return this.size[1];
      }
      get top() {
        return this.y;
      }
      get bottom() {
        return this.y + this.ySize;
      }
      get left() {
        return this.x - this.xSize / 2;
      }
      get right() {
        return this.x + this.xSize / 2;
      }
      get root() {
        const p = this.ancestors();
        return p[p.length - 1];
      }
      get numChildren() {
        return this.hasChildren ? this.children.length : 0;
      }
      get hasChildren() {
        return !this.noChildren;
      }
      get noChildren() {
        return this.children === null;
      }
      get firstChild() {
        return this.hasChildren ? this.children[0] : null;
      }
      get lastChild() {
        return this.hasChildren ? this.children[this.numChildren - 1] : null;
      }
      get extents() {
        return (this.children || []).reduce(
          (p, b) => Fp.maxExtents(p, b.extents),
          this.nodeExtents
        );
      }
      get nodeExtents() {
        return {
          top: this.top,
          bottom: this.bottom,
          left: this.left,
          right: this.right
        };
      }
      static maxExtents(p, b) {
        return {
          top: Math.min(p.top, b.top),
          bottom: Math.max(p.bottom, b.bottom),
          left: Math.min(p.left, b.left),
          right: Math.max(p.right, b.right)
        };
      }
    };
  }
  function s() {
    const l = i(), f = n("nodeSize"), h2 = n("spacing");
    return class extends l {
      constructor(p) {
        super(p), Object.assign(this, {
          x: 0,
          y: 0,
          relX: 0,
          prelim: 0,
          shift: 0,
          change: 0,
          lExt: this,
          lExtRelX: 0,
          lThr: null,
          rExt: this,
          rExtRelX: 0,
          rThr: null
        });
      }
      get size() {
        return f(this.data);
      }
      spacing(p) {
        return h2(this.data, p.data);
      }
      get x() {
        return this.data.x;
      }
      set x(p) {
        this.data.x = p;
      }
      get y() {
        return this.data.y;
      }
      set y(p) {
        this.data.y = p;
      }
      update() {
        return Op(this), zp(this), this;
      }
    };
  }
  function o(l, f, h2) {
    const p = (b, v) => {
      const k = new l(b);
      Object.assign(k, {
        parent: v,
        depth: v === null ? 0 : v.depth + 1,
        height: 0,
        length: 1
      });
      const w = h2(b) || [];
      return k.children = w.length === 0 ? null : w.map((A) => p(A, k)), k.children && Object.assign(k, k.children.reduce(
        (A, T) => ({
          height: Math.max(A.height, T.height + 1),
          length: A.length + T.length
        }),
        k
      )), k;
    };
    return p(f, null);
  }
  return Object.assign(r, {
    nodeSize(l) {
      return arguments.length ? (t.nodeSize = l, r) : t.nodeSize;
    },
    spacing(l) {
      return arguments.length ? (t.spacing = l, r) : t.spacing;
    },
    children(l) {
      return arguments.length ? (t.children = l, r) : t.children;
    },
    hierarchy(l, f) {
      const h2 = typeof f > "u" ? t.children : f;
      return o(i(), l, h2);
    },
    dump(l) {
      const f = n("nodeSize"), h2 = (p) => (b) => {
        const v = p + "  ", k = p + "    ", { x: w, y: A } = b, T = f(b), D = b.children || [], N = D.length === 0 ? " " : `,${v}children: [${k}${D.map(h2(k)).join(k)}${v}],${p}`;
        return `{ size: [${T.join(", ")}],${v}x: ${w}, y: ${A}${N}},`;
      };
      return h2(`
`)(l);
    }
  }), r;
}
Bp.version = Zv;
var Op = (e10, t = 0) => (e10.y = t, (e10.children || []).reduce((n, r) => {
  const [i, s] = n;
  Op(r, e10.y + e10.ySize);
  const o = (i === 0 ? r.lExt : r.rExt).bottom;
  i !== 0 && ek(e10, i, s);
  const l = ak(o, i, s);
  return [i + 1, l];
}, [0, null]), Qv(e10), ok(e10), e10);
var zp = (e10, t, n) => {
  typeof t > "u" && (t = -e10.relX - e10.prelim, n = 0);
  const r = t + e10.relX;
  return e10.relX = r + e10.prelim - n, e10.prelim = 0, e10.x = n + e10.relX, (e10.children || []).forEach((i) => zp(i, r, e10.x)), e10;
};
var Qv = (e10) => {
  (e10.children || []).reduce((t, n) => {
    const [r, i] = t, s = r + n.shift, o = i + s + n.change;
    return n.relX += o, [s, o];
  }, [0, 0]);
};
var ek = (e10, t, n) => {
  const r = e10.children[t - 1], i = e10.children[t];
  let s = r, o = r.relX, l = i, f = i.relX, h2 = true;
  for (; s && l; ) {
    s.bottom > n.lowY && (n = n.next);
    const p = o + s.prelim - (f + l.prelim) + s.xSize / 2 + l.xSize / 2 + s.spacing(l);
    (p > 0 || p < 0 && h2) && (f += p, tk(i, p), nk(e10, t, n.index, p)), h2 = false;
    const b = s.bottom, v = l.bottom;
    b <= v && (s = ik(s), s && (o += s.relX)), b >= v && (l = rk(l), l && (f += l.relX));
  }
  !s && l ? sk(e10, t, l, f) : s && !l && uk(e10, t, s, o);
};
var tk = (e10, t) => {
  e10.relX += t, e10.lExtRelX += t, e10.rExtRelX += t;
};
var nk = (e10, t, n, r) => {
  const i = e10.children[t], s = t - n;
  if (s > 1) {
    const o = r / s;
    e10.children[n + 1].shift += o, i.shift -= o, i.change -= r - o;
  }
};
var rk = (e10) => e10.hasChildren ? e10.firstChild : e10.lThr;
var ik = (e10) => e10.hasChildren ? e10.lastChild : e10.rThr;
var sk = (e10, t, n, r) => {
  const i = e10.firstChild, s = i.lExt, o = e10.children[t];
  s.lThr = n;
  const l = r - n.relX - i.lExtRelX;
  s.relX += l, s.prelim -= l, i.lExt = o.lExt, i.lExtRelX = o.lExtRelX;
};
var uk = (e10, t, n, r) => {
  const i = e10.children[t], s = i.rExt, o = e10.children[t - 1];
  s.rThr = n;
  const l = r - n.relX - i.rExtRelX;
  s.relX += l, s.prelim -= l, i.rExt = o.rExt, i.rExtRelX = o.rExtRelX;
};
var ok = (e10) => {
  if (e10.hasChildren) {
    const t = e10.firstChild, n = e10.lastChild, r = (t.prelim + t.relX - t.xSize / 2 + n.relX + n.prelim + n.xSize / 2) / 2;
    Object.assign(e10, {
      prelim: r,
      lExt: t.lExt,
      lExtRelX: t.lExtRelX,
      rExt: n.rExt,
      rExtRelX: n.rExtRelX
    });
  }
};
var ak = (e10, t, n) => {
  for (; n !== null && e10 >= n.lowY; )
    n = n.next;
  return {
    lowY: e10,
    index: t,
    next: n
  };
};
var lk = ".markmap{--markmap-max-width: 9999px;--markmap-a-color: #0097e6;--markmap-a-hover-color: #00a8ff;--markmap-code-bg: #f0f0f0;--markmap-code-color: #555;--markmap-highlight-bg: #ffeaa7;--markmap-table-border: 1px solid currentColor;--markmap-font: 300 16px/20px sans-serif;--markmap-circle-open-bg: #fff;--markmap-text-color: #333;--markmap-highlight-node-bg: #ff02;font:var(--markmap-font);color:var(--markmap-text-color)}.markmap-link{fill:none}.markmap-node>circle{cursor:pointer}.markmap-foreign{display:inline-block}.markmap-foreign p{margin:0}.markmap-foreign a{color:var(--markmap-a-color)}.markmap-foreign a:hover{color:var(--markmap-a-hover-color)}.markmap-foreign code{padding:.25em;font-size:calc(1em - 2px);color:var(--markmap-code-color);background-color:var(--markmap-code-bg);border-radius:2px}.markmap-foreign pre{margin:0}.markmap-foreign pre>code{display:block}.markmap-foreign del{text-decoration:line-through}.markmap-foreign em{font-style:italic}.markmap-foreign strong{font-weight:700}.markmap-foreign mark{background:var(--markmap-highlight-bg)}.markmap-foreign table,.markmap-foreign th,.markmap-foreign td{border-collapse:collapse;border:var(--markmap-table-border)}.markmap-foreign img{display:inline-block}.markmap-foreign svg{fill:currentColor}.markmap-foreign>div{width:var(--markmap-max-width);text-align:left}.markmap-foreign>div>div{display:inline-block}.markmap-highlight rect{fill:var(--markmap-highlight-node-bg)}.markmap-dark .markmap{--markmap-code-bg: #1a1b26;--markmap-code-color: #ddd;--markmap-circle-open-bg: #444;--markmap-text-color: #eee}";
var xo = "g.markmap-node";
var ck = "path.markmap-link";
var fk = "g.markmap-highlight";
var wo = vv();
function Eh(e10, t) {
  const n = L9(e10, t);
  return e10[n];
}
function vo(e10) {
  e10.stopPropagation();
}
var hk = new Ei();
var pl = class _pl {
  constructor(t, n) {
    this.options = { ...Ip }, this._disposeList = [], this.handleZoom = (r) => {
      const { transform: i } = r;
      this.g.attr("transform", i);
    }, this.handlePan = (r) => {
      r.preventDefault();
      const i = zr(this.svg.node()), s = i.translate(
        -r.deltaX / i.k,
        -r.deltaY / i.k
      );
      this.svg.call(this.zoom.transform, s);
    }, this.handleClick = (r, i) => {
      let s = this.options.toggleRecursively;
      (Mp ? r.metaKey : r.ctrlKey) && (s = !s), this.toggleNode(i, s);
    }, this.ensureView = this.ensureVisible, this.svg = t.datum ? t : Yn(t), this.styleNode = this.svg.append("style"), this.zoom = Tv().filter((r) => this.options.scrollForPan && r.type === "wheel" ? r.ctrlKey && !r.button : (!r.ctrlKey || r.type === "wheel") && !r.button).on("zoom", this.handleZoom), this.setOptions(n), this.state = {
      id: this.options.id || this.svg.attr("id") || Um(),
      rect: { x1: 0, y1: 0, x2: 0, y2: 0 }
    }, this.g = this.svg.append("g"), this.g.append("g").attr("class", "markmap-highlight"), this._observer = new ResizeObserver(
      Km(() => {
        this.renderData();
      }, 100)
    ), this._disposeList.push(
      hk.tap(() => {
        this.setData();
      }),
      () => this._observer.disconnect()
    );
  }
  getStyleContent() {
    const { style: t } = this.options, { id: n } = this.state, r = typeof t == "function" ? t(n) : "";
    return [this.options.embedGlobalCSS && lk, r].filter(Boolean).join(`
`);
  }
  updateStyle() {
    this.svg.attr(
      "class",
      Vm(this.svg.attr("class"), "markmap", this.state.id)
    );
    const t = this.getStyleContent();
    this.styleNode.text(t);
  }
  async toggleNode(t, n = false) {
    var r, i;
    const s = (r = t.payload) != null && r.fold ? 0 : 1;
    n ? Ci(t, (o, l) => {
      o.payload = {
        ...o.payload,
        fold: s
      }, l();
    }) : t.payload = {
      ...t.payload,
      fold: (i = t.payload) != null && i.fold ? 0 : 1
    }, await this.renderData(t);
  }
  _initializeData(t) {
    let n = 0;
    const { color: r, initialExpandLevel: i } = this.options;
    let s = 0, o = 0;
    return Ci(t, (l, f, h2) => {
      var p, b, v, k;
      o += 1, l.children = (p = l.children) == null ? void 0 : p.map((A) => ({ ...A })), n += 1, l.state = {
        ...l.state,
        depth: o,
        id: n,
        rect: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        },
        size: [0, 0]
      }, l.state.key = [(b = h2 == null ? void 0 : h2.state) == null ? void 0 : b.id, l.state.id].filter(Boolean).join(".") + Nv(l.content), l.state.path = [(v = h2 == null ? void 0 : h2.state) == null ? void 0 : v.path, l.state.id].filter(Boolean).join("."), r(l);
      const w = ((k = l.payload) == null ? void 0 : k.fold) === 2;
      w ? s += 1 : (s || i >= 0 && l.state.depth >= i) && (l.payload = { ...l.payload, fold: 1 }), f(), w && (s -= 1), o -= 1;
    }), t;
  }
  _relayout() {
    if (!this.state.data) return;
    this.g.selectAll(zt(xo)).selectAll(
      zt("foreignObject")
    ).each(function(f) {
      var h2;
      const p = (h2 = this.firstChild) == null ? void 0 : h2.firstChild, b = [p.scrollWidth, p.scrollHeight];
      f.state.size = b;
    });
    const { lineWidth: t, paddingX: n, spacingHorizontal: r, spacingVertical: i } = this.options, s = Bp({}).children((f) => {
      var h2;
      if (!((h2 = f.payload) != null && h2.fold)) return f.children;
    }).nodeSize((f) => {
      const [h2, p] = f.data.state.size;
      return [p, h2 + (h2 ? n * 2 : 0) + r];
    }).spacing((f, h2) => (f.parent === h2.parent ? i : i * 2) + t(f.data)), o = s.hierarchy(this.state.data);
    s(o);
    const l = o.descendants();
    l.forEach((f) => {
      const h2 = f.data;
      h2.state.rect = {
        x: f.y,
        y: f.x - f.xSize / 2,
        width: f.ySize - r,
        height: f.xSize
      };
    }), this.state.rect = {
      x1: sh(l, (f) => f.data.state.rect.x) || 0,
      y1: sh(l, (f) => f.data.state.rect.y) || 0,
      x2: ih(
        l,
        (f) => f.data.state.rect.x + f.data.state.rect.width
      ) || 0,
      y2: ih(
        l,
        (f) => f.data.state.rect.y + f.data.state.rect.height
      ) || 0
    };
  }
  setOptions(t) {
    this.options = {
      ...this.options,
      ...t
    }, this.options.zoom ? this.svg.call(this.zoom) : this.svg.on(".zoom", null), this.options.pan ? this.svg.on("wheel", this.handlePan) : this.svg.on("wheel", null);
  }
  async setData(t, n) {
    n && this.setOptions(n), t && (this.state.data = this._initializeData(t)), this.state.data && (this.updateStyle(), await this.renderData());
  }
  async setHighlight(t) {
    this.state.highlight = t || void 0, await this.renderData();
  }
  _getHighlightRect(t) {
    const n = this.svg.node(), r = 4 / zr(n).k, i = {
      ...t.state.rect
    };
    return i.x -= r, i.y -= r, i.width += 2 * r, i.height += 2 * r, i;
  }
  async renderData(t) {
    const { paddingX: n, autoFit: r, color: i, maxWidth: s, lineWidth: o } = this.options, l = this.state.data;
    if (!l) return;
    const f = {}, h2 = {}, p = [];
    Ci(l, (P, he, ge) => {
      var De;
      (De = P.payload) != null && De.fold || he(), f[P.state.id] = P, ge && (h2[P.state.id] = ge.state.id), p.push(P);
    });
    const b = {}, v = {}, k = (P) => {
      !P || b[P.state.id] || Ci(P, (he, ge) => {
        b[he.state.id] = P.state.id, ge();
      });
    }, w = (P) => v[b[P.state.id]] || l.state.rect, A = (P) => (f[b[P.state.id]] || l).state.rect;
    v[l.state.id] = l.state.rect, t && k(t);
    let { highlight: T } = this.state;
    T && !f[T.state.id] && (T = void 0);
    let D = this.g.selectAll(zt(fk)).selectAll(zt("rect")).data(T ? [this._getHighlightRect(T)] : []).join("rect").attr("x", (P) => P.x).attr("y", (P) => P.y).attr("width", (P) => P.width).attr("height", (P) => P.height);
    const N = this.g.selectAll(zt(xo)).each((P) => {
      v[P.state.id] = P.state.rect;
    }).data(p, (P) => P.state.key), O = N.enter().append("g").attr("data-depth", (P) => P.state.depth).attr("data-path", (P) => P.state.path).each((P) => {
      k(f[h2[P.state.id]]);
    }), q = N.exit().each((P) => {
      k(f[h2[P.state.id]]);
    }), z = N.merge(O).attr(
      "class",
      (P) => {
        var he;
        return ["markmap-node", ((he = P.payload) == null ? void 0 : he.fold) && "markmap-fold"].filter(Boolean).join(" ");
      }
    ), R = z.selectAll(zt("line")).data(
      (P) => [P],
      (P) => P.state.key
    ), J = R.enter().append("line").attr("stroke", (P) => i(P)).attr("stroke-width", 0), K = R.merge(J), V = z.selectAll(zt("circle")).data(
      (P) => {
        var he;
        return (he = P.children) != null && he.length ? [P] : [];
      },
      (P) => P.state.key
    ), te = V.enter().append("circle").attr("stroke-width", 0).attr("r", 0).on("click", (P, he) => this.handleClick(P, he)).on("mousedown", vo).merge(V).attr("stroke", (P) => i(P)).attr(
      "fill",
      (P) => {
        var he;
        return (he = P.payload) != null && he.fold && P.children ? i(P) : "var(--markmap-circle-open-bg)";
      }
    ), Z = this._observer, se = z.selectAll(zt("foreignObject")).data(
      (P) => [P],
      (P) => P.state.key
    ), fe = se.enter().append("foreignObject").attr("class", "markmap-foreign").attr("x", n).attr("y", 0).style("opacity", 0).on("mousedown", vo).on("dblclick", vo);
    fe.append("xhtml:div").append("xhtml:div").html((P) => P.content).attr("xmlns", "http://www.w3.org/1999/xhtml"), fe.each(function() {
      var P;
      const he = (P = this.firstChild) == null ? void 0 : P.firstChild;
      Z.observe(he);
    });
    const $ = q.selectAll(
      zt("foreignObject")
    );
    $.each(function() {
      var P;
      const he = (P = this.firstChild) == null ? void 0 : P.firstChild;
      Z.unobserve(he);
    });
    const X = fe.merge(se), j = p.flatMap(
      (P) => {
        var he;
        return (he = P.payload) != null && he.fold ? [] : P.children.map((ge) => ({ source: P, target: ge }));
      }
    ), Q = this.g.selectAll(zt(ck)).data(j, (P) => P.target.state.key), ee = Q.exit(), le = Q.enter().insert("path", "g").attr("class", "markmap-link").attr("data-depth", (P) => P.target.state.depth).attr("data-path", (P) => P.target.state.path).attr("d", (P) => {
      const he = w(P.target), ge = [
        he.x + he.width,
        he.y + he.height
      ];
      return wo({ source: ge, target: ge });
    }).attr("stroke-width", 0).merge(Q);
    this.svg.style(
      "--markmap-max-width",
      s ? `${s}px` : null
    ), await new Promise(requestAnimationFrame), this._relayout(), D = D.data(T ? [this._getHighlightRect(T)] : []).join("rect"), this.transition(D).attr("x", (P) => P.x).attr("y", (P) => P.y).attr("width", (P) => P.width).attr("height", (P) => P.height), O.attr("transform", (P) => {
      const he = w(P);
      return `translate(${he.x + he.width - P.state.rect.width},${he.y + he.height - P.state.rect.height})`;
    }), this.transition(q).attr("transform", (P) => {
      const he = A(P), ge = he.x + he.width - P.state.rect.width, De = he.y + he.height - P.state.rect.height;
      return `translate(${ge},${De})`;
    }).remove(), this.transition(z).attr(
      "transform",
      (P) => `translate(${P.state.rect.x},${P.state.rect.y})`
    );
    const ae = q.selectAll(
      zt("line")
    );
    this.transition(ae).attr("x1", (P) => P.state.rect.width).attr("stroke-width", 0), J.attr("x1", (P) => P.state.rect.width).attr("x2", (P) => P.state.rect.width), K.attr("y1", (P) => P.state.rect.height + o(P) / 2).attr("y2", (P) => P.state.rect.height + o(P) / 2), this.transition(K).attr("x1", -1).attr("x2", (P) => P.state.rect.width + 2).attr("stroke", (P) => i(P)).attr("stroke-width", o);
    const ne = q.selectAll(
      zt("circle")
    );
    this.transition(ne).attr("r", 0).attr("stroke-width", 0), te.attr("cx", (P) => P.state.rect.width).attr("cy", (P) => P.state.rect.height + o(P) / 2), this.transition(te).attr("r", 6).attr("stroke-width", "1.5"), this.transition($).style("opacity", 0), X.attr("width", (P) => Math.max(0, P.state.rect.width - n * 2)).attr("height", (P) => P.state.rect.height), this.transition(X).style("opacity", 1), this.transition(ee).attr("d", (P) => {
      const he = A(P.target), ge = [
        he.x + he.width,
        he.y + he.height + o(P.target) / 2
      ];
      return wo({ source: ge, target: ge });
    }).attr("stroke-width", 0).remove(), this.transition(le).attr("stroke", (P) => i(P.target)).attr("stroke-width", (P) => o(P.target)).attr("d", (P) => {
      const he = P.source, ge = P.target, De = [
        he.state.rect.x + he.state.rect.width,
        he.state.rect.y + he.state.rect.height + o(he) / 2
      ], He = [
        ge.state.rect.x,
        ge.state.rect.y + ge.state.rect.height + o(ge) / 2
      ];
      return wo({ source: De, target: He });
    }), r && this.fit();
  }
  transition(t) {
    const { duration: n } = this.options;
    return t.transition().duration(n);
  }
  /**
   * Fit the content to the viewport.
   */
  async fit(t = this.options.maxInitialScale) {
    const n = this.svg.node(), { width: r, height: i } = n.getBoundingClientRect(), { fitRatio: s } = this.options, { x1: o, y1: l, x2: f, y2: h2 } = this.state.rect, p = f - o, b = h2 - l, v = Math.min(
      r / p * s,
      i / b * s,
      t
    ), k = tu.translate(
      (r - p * v) / 2 - o * v,
      (i - b * v) / 2 - l * v
    ).scale(v);
    return this.transition(this.svg).call(this.zoom.transform, k).end().catch($r);
  }
  findElement(t) {
    let n;
    return this.g.selectAll(zt(xo)).each(function(r) {
      r === t && (n = {
        data: r,
        g: this
      });
    }), n;
  }
  /**
   * Pan the content to make the provided node visible in the viewport.
   */
  async ensureVisible(t, n) {
    var r;
    const i = (r = this.findElement(t)) == null ? void 0 : r.data;
    if (!i) return;
    const s = this.svg.node(), o = s.getBoundingClientRect(), l = zr(s), [f, h2] = [
      i.state.rect.x,
      i.state.rect.x + i.state.rect.width + 2
    ].map((D) => D * l.k + l.x), [p, b] = [
      i.state.rect.y,
      i.state.rect.y + i.state.rect.height
    ].map((D) => D * l.k + l.y), v = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      ...n
    }, k = [v.left - f, o.width - v.right - h2], w = [v.top - p, o.height - v.bottom - b], A = k[0] * k[1] > 0 ? Eh(k, Math.abs) / l.k : 0, T = w[0] * w[1] > 0 ? Eh(w, Math.abs) / l.k : 0;
    if (A || T) {
      const D = l.translate(A, T);
      return this.transition(this.svg).call(this.zoom.transform, D).end().catch($r);
    }
  }
  async centerNode(t, n) {
    var r;
    const i = (r = this.findElement(t)) == null ? void 0 : r.data;
    if (!i) return;
    const s = this.svg.node(), o = s.getBoundingClientRect(), l = zr(s), f = (i.state.rect.x + i.state.rect.width / 2) * l.k + l.x, h2 = (i.state.rect.y + i.state.rect.height / 2) * l.k + l.y, p = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      ...n
    }, b = (p.left + o.width - p.right) / 2, v = (p.top + o.height - p.bottom) / 2, k = (b - f) / l.k, w = (v - h2) / l.k;
    if (k || w) {
      const A = l.translate(k, w);
      return this.transition(this.svg).call(this.zoom.transform, A).end().catch($r);
    }
  }
  /**
   * Scale content with it pinned at the center of the viewport.
   */
  async rescale(t) {
    const n = this.svg.node(), { width: r, height: i } = n.getBoundingClientRect(), s = r / 2, o = i / 2, l = zr(n), f = l.translate(
      (s - l.x) * (1 - t) / l.k,
      (o - l.y) * (1 - t) / l.k
    ).scale(t);
    return this.transition(this.svg).call(this.zoom.transform, f).end().catch($r);
  }
  destroy() {
    this.svg.on(".zoom", null), this.svg.html(null), this._disposeList.forEach((t) => {
      t();
    });
  }
  static create(t, n, r = null) {
    const i = new _pl(t, n);
    return r && i.setData(r).then(() => {
      i.fit();
    }), i;
  }
};
var or = /* @__PURE__ */ new Map();
var ko = /* @__PURE__ */ new Map();
var $t = /* @__PURE__ */ new Map();
var Fi = /* @__PURE__ */ new Map();
var _o = /* @__PURE__ */ new Map();
var Ch = /* @__PURE__ */ new WeakMap();
var Dn = /* @__PURE__ */ new Set();
function dk(e10) {
  if (Fi.has(e10))
    return Fi.get(e10);
  if ((/* @__PURE__ */ new Set(["script", "style", "meta", "link", "noscript", "template"])).has(e10)) {
    const o = {};
    return Fi.set(e10, o), o;
  }
  let n = document.getElementById("snapdom-sandbox");
  n || (n = document.createElement("div"), n.id = "snapdom-sandbox", n.style.position = "absolute", n.style.left = "-9999px", n.style.top = "-9999px", n.style.width = "0", n.style.height = "0", n.style.overflow = "hidden", document.body.appendChild(n));
  const r = document.createElement(e10);
  r.style.all = "initial", n.appendChild(r);
  const i = getComputedStyle(r), s = {};
  for (let o of i)
    s[o] = i.getPropertyValue(o);
  return n.removeChild(r), Fi.set(e10, s), s;
}
function ca(e10, t, n = false) {
  const r = [], i = dk(t);
  for (let [s, o] of Object.entries(e10))
    if (!n)
      o && r.push(`${s}:${o}`);
    else {
      const l = i[s];
      o && o !== l && r.push(`${s}:${o}`);
    }
  return r.sort().join(";");
}
function pk(e10) {
  const t = /* @__PURE__ */ new Set();
  return e10.nodeType !== Node.ELEMENT_NODE && e10.nodeType !== Node.DOCUMENT_FRAGMENT_NODE ? [] : (e10.tagName && t.add(e10.tagName.toLowerCase()), typeof e10.querySelectorAll == "function" && e10.querySelectorAll("*").forEach((n) => t.add(n.tagName.toLowerCase())), Array.from(t));
}
function mk(e10) {
  const t = /* @__PURE__ */ new Map();
  for (let r of e10) {
    const i = Fi.get(r);
    if (!i) continue;
    const s = Object.entries(i).map(([o, l]) => `${o}:${l};`).sort().join("");
    t.has(s) || t.set(s, []), t.get(s).push(r);
  }
  let n = "";
  for (let [r, i] of t.entries())
    n += `${i.join(",")} { ${r} }
`;
  return n;
}
function gk(e10) {
  const t = new Set(e10.values()), n = /* @__PURE__ */ new Map();
  let r = 1;
  for (const i of t)
    n.set(i, `c${r++}`);
  return n;
}
async function $p(e10, t = {}) {
  var _a2;
  const r = (_a2 = e10.match(/url\(["']?(.*?)["']?\)/)) == null ? void 0 : _a2[1], i = /^((repeating-)?(linear|radial|conic)-gradient)\(/i.test(e10);
  if (r) {
    const s = bl(r);
    if (ko.has(s))
      return t.skipInline ? void 0 : `url(${ko.get(s)})`;
    {
      const o = await gl(s, { useProxy: t.useProxy });
      return ko.set(s, o), t.skipInline ? void 0 : `url("${o}")`;
    }
  }
  return e10;
}
function _i(e10, { fast: t = false } = {}) {
  if (t) return e10();
  "requestIdleCallback" in window ? requestIdleCallback(e10, { timeout: 50 }) : setTimeout(e10, 1);
}
function ml(e10, t = null) {
  if (!(e10 instanceof Element))
    return window.getComputedStyle(e10, t);
  let n = Ch.get(e10);
  if (n || (n = /* @__PURE__ */ new Map(), Ch.set(e10, n)), !n.has(t)) {
    const r = window.getComputedStyle(e10, t);
    n.set(t, r);
  }
  return n.get(t);
}
function bk(e10) {
  let t = e10.replace(/^['"]|['"]$/g, "");
  if (t.startsWith("\\"))
    try {
      return String.fromCharCode(parseInt(t.replace("\\", ""), 16));
    } catch {
      return t;
    }
  return t;
}
function Lp(e10) {
  const t = e10.indexOf("url(");
  if (t === -1) return null;
  let n = e10.slice(t + 4).trim();
  return n.endsWith(")") && (n = n.slice(0, -1).trim()), (n.startsWith('"') && n.endsWith('"') || n.startsWith("'") && n.endsWith("'")) && (n = n.slice(1, -1)), n;
}
function gl(e10, { timeout: t = 3e3, useProxy: n = "" } = {}) {
  function r(f) {
    try {
      return new URL(f, window.location.href).origin === window.location.origin ? "use-credentials" : "anonymous";
    } catch {
      return "anonymous";
    }
  }
  async function i(f) {
    const h2 = (p) => fetch(p, {
      mode: "cors",
      credentials: r(p) === "use-credentials" ? "include" : "omit"
    }).then((b) => b.blob()).then((b) => new Promise((v, k) => {
      const w = new FileReader();
      w.onloadend = () => {
        const A = w.result;
        if (typeof A != "string" || !A.startsWith("data:image/")) {
          k(new Error("Invalid image data URL"));
          return;
        }
        v(A);
      }, w.onerror = () => k(new Error("FileReader error")), w.readAsDataURL(b);
    }));
    try {
      return await h2(f);
    } catch {
      if (n && typeof n == "string") {
        const b = n.replace(/\/$/, "") + bl(f);
        try {
          return await h2(b);
        } catch {
          throw console.error(`[SnapDOM - fetchImage] Proxy fallback failed for: ${f}`), new Error("CORS restrictions prevented image capture (even via proxy)");
        }
      } else
        throw console.error(`[SnapDOM - fetchImage] No valid proxy URL provided for fallback: ${f}`), new Error("Fetch fallback failed and no proxy provided");
    }
  }
  const s = r(e10);
  return console.log(`[SnapDOM - fetchImage] Start loading image: ${e10} with crossOrigin=${s}`), or.has(e10) ? (console.log(`[SnapDOM - fetchImage] Cache hit for: ${e10}`), Promise.resolve(or.get(e10))) : e10.startsWith("data:image/") ? (or.set(e10, e10), Promise.resolve(e10)) : /\.svg(\?.*)?$/i.test(e10) ? (async () => {
    try {
      const h2 = await (await fetch(e10, {
        mode: "cors",
        credentials: s === "use-credentials" ? "include" : "omit"
      })).text(), p = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(h2)}`;
      return or.set(e10, p), p;
    } catch {
      return i(e10);
    }
  })() : new Promise((f, h2) => {
    const p = setTimeout(() => {
      console.log(`[SnapDOM - fetchImage] Timeout after ${t}ms for image: ${e10}`), h2(new Error("Image load timed out"));
    }, t), b = new Image();
    b.crossOrigin = s, b.onload = async () => {
      clearTimeout(p);
      try {
        await b.decode();
        const v = document.createElement("canvas");
        v.width = b.width, v.height = b.height, v.getContext("2d").drawImage(b, 0, 0, v.width, v.height);
        const w = v.toDataURL("image/png");
        or.set(e10, w), f(w);
      } catch {
        try {
          const v = await i(e10);
          or.set(e10, v), f(v);
        } catch (v) {
          h2(v);
        }
      }
    }, b.onerror = async () => {
      clearTimeout(p), console.error(`[SnapDOM - fetchImage] Image failed to load: ${e10}`);
      try {
        const v = await i(e10);
        or.set(e10, v), f(v);
      } catch (v) {
        h2(v);
      }
    }, b.src = e10;
  });
}
function Th(e10) {
  const t = {};
  for (let n of e10)
    t[n] = e10.getPropertyValue(n);
  return t;
}
function qp() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
function yk(e10) {
  if (!e10 || e10 === "none") return "";
  let t = e10.replace(/translate[XY]?\([^)]*\)/g, "");
  return t = t.replace(/matrix\(([^)]+)\)/g, (n, r) => {
    const i = r.split(",").map((s) => s.trim());
    return i.length !== 6 ? `matrix(${r})` : (i[4] = "0", i[5] = "0", `matrix(${i.join(", ")})`);
  }), t = t.replace(/matrix3d\(([^)]+)\)/g, (n, r) => {
    const i = r.split(",").map((s) => s.trim());
    return i.length !== 16 ? `matrix3d(${r})` : (i[12] = "0", i[13] = "0", `matrix3d(${i.join(", ")})`);
  }), t.trim().replace(/\s{2,}/g, " ");
}
function bl(e10) {
  if (/%[0-9A-Fa-f]{2}/.test(e10)) return e10;
  try {
    return encodeURI(e10);
  } catch {
    return e10;
  }
}
function Rp(e10) {
  const t = [];
  let n = 0, r = 0;
  for (let i = 0; i < e10.length; i++) {
    const s = e10[i];
    s === "(" && n++, s === ")" && n--, s === "," && n === 0 && (t.push(e10.slice(r, i).trim()), r = i + 1);
  }
  return t.push(e10.slice(r).trim()), t;
}
var So = /* @__PURE__ */ new WeakMap();
var Ao = /* @__PURE__ */ new Map();
function xk(e10) {
  const t = {};
  for (let n = 0; n < e10.length; n++) {
    const r = e10[n];
    let i = e10.getPropertyValue(r);
    (r === "background-image" || r === "content") && i.includes("url(") && !i.includes("data:") && (i = "none"), t[r] = i;
  }
  return t;
}
function Dh(e10, t, n, r, i) {
  var _a2;
  if (e10.tagName === "STYLE") return;
  r.has(e10) || r.set(e10, ml(e10));
  const s = r.get(e10);
  if (!So.has(e10)) {
    const p = xk(s);
    So.set(e10, p);
  }
  const o = So.get(e10), l = Object.entries(o).sort(([p], [b]) => p.localeCompare(b)).map(([p, b]) => `${p}:${b}`).join(";");
  if (Ao.has(l)) {
    n.set(t, Ao.get(l));
    return;
  }
  const f = ((_a2 = e10.tagName) == null ? void 0 : _a2.toLowerCase()) || "div", h2 = ca(o, f, i);
  Ao.set(l, h2), n.set(t, h2);
}
function wk(e10) {
  return e10.nodeType === Node.ELEMENT_NODE && e10.tagName === "SLOT";
}
function s0(e10, t, n, r, i, s = {}, o) {
  var _a2, _b2;
  if (e10.nodeType === Node.TEXT_NODE || e10.nodeType !== Node.ELEMENT_NODE) return e10.cloneNode(true);
  if (e10.getAttribute("data-capture") === "exclude") {
    const f = document.createElement("div"), h2 = e10.getBoundingClientRect();
    return f.style.cssText = `display: inline-block; width: ${h2.width}px; height: ${h2.height}px; visibility: hidden;`, f;
  }
  if (s.exclude && Array.isArray(s.exclude))
    for (const f of s.exclude)
      try {
        if ((_a2 = e10.matches) == null ? void 0 : _a2.call(e10, f)) {
          const h2 = document.createElement("div"), p = e10.getBoundingClientRect();
          return h2.style.cssText = `display: inline-block; width: ${p.width}px; height: ${p.height}px; visibility: hidden;`, h2;
        }
      } catch (h2) {
        console.warn(`Invalid selector in exclude option: ${f}`, h2);
      }
  if (typeof s.filter == "function")
    try {
      if (!s.filter(e10, o || e10)) {
        const f = document.createElement("div"), h2 = e10.getBoundingClientRect();
        return f.style.cssText = `display: inline-block; width: ${h2.width}px; height: ${h2.height}px; visibility: hidden;`, f;
      }
    } catch (f) {
      console.warn("Error in filter function:", f);
    }
  if (e10.tagName === "IFRAME") {
    const f = document.createElement("div");
    return f.textContent = "", f.style.cssText = `width: ${e10.offsetWidth}px; height: ${e10.offsetHeight}px; background-image: repeating-linear-gradient(45deg, #ddd, #ddd 5px, #f9f9f9 5px, #f9f9f9 10px);display: flex;align-items: center;justify-content: center;font-size: 12px;color: #555; border: 1px solid #aaa;`, f;
  }
  if (e10.getAttribute("data-capture") === "placeholder") {
    const f = e10.cloneNode(false);
    r.set(f, e10), Dh(e10, f, t, n, i);
    const h2 = document.createElement("div");
    return h2.textContent = e10.getAttribute("data-placeholder-text") || "", h2.style.cssText = "color: #666;font-size: 12px;text-align: center;line-height: 1.4;padding: 0.5em;box-sizing: border-box;", f.appendChild(h2), f;
  }
  if (e10.tagName === "CANVAS") {
    const f = e10.toDataURL(), h2 = document.createElement("img");
    return h2.src = f, h2.width = e10.width, h2.height = e10.height, h2.style.display = "inline-block", h2.style.width = e10.style.width || `${e10.width}px`, h2.style.height = e10.style.height || `${e10.height}px`, h2;
  }
  const l = e10.cloneNode(false);
  if (r.set(l, e10), e10 instanceof HTMLInputElement)
    l.value = e10.value, l.setAttribute("value", e10.value), e10.checked !== void 0 && (l.checked = e10.checked, e10.checked && l.setAttribute("checked", ""));
  else if (e10 instanceof HTMLTextAreaElement) {
    const f = e10.getBoundingClientRect();
    l.textContent = e10.value, l.style.width = `${f.width}px`, l.style.height = `${f.height}px`;
  } else e10 instanceof HTMLSelectElement && (l.value = e10.value, Array.from(l.options).forEach((f) => {
    f.value === e10.value ? f.setAttribute("selected", "") : f.removeAttribute("selected");
  }));
  if (Dh(e10, l, t, n, i), wk(e10)) {
    const f = ((_b2 = e10.assignedNodes) == null ? void 0 : _b2.call(e10, { flatten: true })) || [], h2 = f.length > 0 ? f : Array.from(e10.childNodes), p = document.createDocumentFragment();
    for (const b of h2) {
      const v = s0(b, t, n, r, i, s, o || e10);
      v && p.appendChild(v);
    }
    return p;
  } else if (!(e10 instanceof HTMLTextAreaElement)) {
    const f = e10.shadowRoot ? e10.shadowRoot.childNodes : e10.childNodes;
    for (const h2 of f) {
      const p = s0(h2, t, n, r, i, s, o || e10);
      p && l.appendChild(p);
    }
    if (e10.shadowRoot && e10.childNodes.length > 0 && !e10.shadowRoot.querySelector("slot")) {
      const h2 = document.createDocumentFragment();
      for (const p of e10.childNodes) {
        const b = s0(p, t, n, r, i, s, o || e10);
        b && h2.appendChild(b);
      }
      l.appendChild(h2);
    }
  }
  return l;
}
var vk = [
  // /uicons/i,
  /font\s*awesome/i,
  /material\s*icons/i,
  /ionicons/i,
  /glyphicons/i,
  /feather/i,
  /bootstrap\s*icons/i,
  /remix\s*icons/i,
  /heroicons/i,
  /layui/i,
  /lucide/i
];
var fa = [];
function kk(e10) {
  const t = Array.isArray(e10) ? e10 : [e10];
  for (const n of t)
    n instanceof RegExp ? fa.push(n) : typeof n == "string" ? fa.push(new RegExp(n, "i")) : console.warn("[snapdom] Ignored invalid iconFont value:", n);
}
function Un(e10) {
  const t = typeof e10 == "string" ? e10 : "", n = [...vk, ...fa];
  for (const r of n)
    if (r instanceof RegExp && r.test(t)) return true;
  return !!(/icon/i.test(t) || /glyph/i.test(t) || /symbols/i.test(t) || /feather/i.test(t) || /fontawesome/i.test(t));
}
async function _k(e10, t, n, r = 32, i = "#000") {
  t = t.replace(/^['"]+|['"]+$/g, "");
  const s = window.devicePixelRatio || 1, l = document.createElement("canvas").getContext("2d");
  l.font = n ? `${n} ${r}px "${t}"` : `${r}px "${t}"`;
  const f = l.measureText(e10), h2 = f.actualBoundingBoxAscent || r * 0.8, p = f.actualBoundingBoxDescent || r * 0.2, b = h2 + p, v = f.width, k = document.createElement("canvas");
  k.width = Math.ceil(v * s), k.height = Math.ceil(b * s);
  const w = k.getContext("2d");
  return w.scale(s, s), w.font = l.font, w.textAlign = "left", w.textBaseline = "alphabetic", w.fillStyle = i, w.fillText(e10, 0, h2), k.toDataURL();
}
function Pp(e10) {
  return Array.from(document.styleSheets).some((t) => t.href === e10);
}
function Sk(e10) {
  return new Promise((t) => {
    if (Pp(e10)) return t(null);
    const n = document.createElement("link");
    n.rel = "stylesheet", n.href = e10, n.setAttribute("data-snapdom", "injected-import"), n.onload = () => t(n), n.onerror = () => t(null), document.head.appendChild(n);
  });
}
async function Ak({ preCached: e10 = false } = {}) {
  if ($t.has("fonts-embed-css")) {
    if (e10) {
      const s = document.createElement("style");
      s.setAttribute("data-snapdom", "embedFonts"), s.textContent = $t.get("fonts-embed-css"), document.head.appendChild(s);
    }
    return $t.get("fonts-embed-css");
  }
  const t = /@import\s+url\(["']?([^"')]+)["']?\)/g, n = [];
  for (const s of document.querySelectorAll("style")) {
    const o = s.textContent || "", l = Array.from(o.matchAll(t));
    for (const f of l) {
      const h2 = f[1];
      Un(h2) || Pp(h2) || n.push(h2);
    }
  }
  await Promise.all(n.map(Sk));
  const r = Array.from(document.querySelectorAll('link[rel="stylesheet"]')).filter((s) => s.href);
  let i = "";
  for (const s of r)
    try {
      const l = await (await fetch(s.href)).text();
      if (Un(s.href) || Un(l)) continue;
      const f = /url\((["']?)([^"')]+)\1\)/g, h2 = await Promise.all(
        Array.from(l.matchAll(f)).map(async (b) => {
          let v = Lp(b[0]);
          if (!v) return null;
          let k = v;
          if (!k.startsWith("http") && !k.startsWith("data:") && (k = new URL(k, s.href).href), Un(k)) return null;
          if ($t.has(k))
            return Dn.add(k), { original: b[0], inlined: `url(${$t.get(k)})` };
          if (Dn.has(k)) return null;
          try {
            const A = await (await fetch(k)).blob(), T = await new Promise((D) => {
              const N = new FileReader();
              N.onload = () => D(N.result), N.readAsDataURL(A);
            });
            return $t.set(k, T), Dn.add(k), { original: b[0], inlined: `url(${T})` };
          } catch {
            return console.warn("[snapdom] Failed to fetch font resource:", k), null;
          }
        })
      );
      let p = l;
      for (const b of h2)
        b && (p = p.replace(b.original, b.inlined));
      i += p + `
`;
    } catch {
      console.warn("[snapdom] Failed to fetch CSS:", s.href);
    }
  for (const s of document.styleSheets)
    try {
      if (!s.href || r.every((o) => o.href !== s.href)) {
        for (const o of s.cssRules)
          if (o.type === CSSRule.FONT_FACE_RULE) {
            const l = o.style.getPropertyValue("src"), f = o.style.getPropertyValue("font-family");
            if (!l || Un(f)) continue;
            const h2 = /url\((["']?)([^"')]+)\1\)/g;
            let p = l;
            const b = Array.from(l.matchAll(h2));
            for (const v of b) {
              let k = v[2].trim();
              if (!k) continue;
              let w = k;
              if (!w.startsWith("http") && !w.startsWith("data:") && (w = new URL(w, s.href || location.href).href), !Un(w)) {
                if ($t.has(w)) {
                  Dn.add(w), p = p.replace(v[0], `url(${$t.get(w)})`);
                  continue;
                }
                if (!Dn.has(w))
                  try {
                    const T = await (await fetch(w)).blob(), D = await new Promise((N) => {
                      const O = new FileReader();
                      O.onload = () => N(O.result), O.readAsDataURL(T);
                    });
                    $t.set(w, D), Dn.add(w), p = p.replace(v[0], `url(${D})`);
                  } catch {
                    console.warn("[snapdom] Failed to fetch font URL:", w);
                  }
              }
            }
            i += `@font-face {
  font-family: ${f};
  src: ${p};
  font-style: ${o.style.getPropertyValue("font-style") || "normal"};
  font-weight: ${o.style.getPropertyValue("font-weight") || "normal"};
}
`;
          }
      }
    } catch (o) {
      console.warn("[snapdom] Cannot access stylesheet", s.href, o);
    }
  for (const s of document.fonts)
    if (s.family && s.status === "loaded" && s._snapdomSrc) {
      if (Un(s.family)) continue;
      let o = s._snapdomSrc;
      if (!o.startsWith("data:")) {
        if ($t.has(s._snapdomSrc))
          o = $t.get(s._snapdomSrc), Dn.add(s._snapdomSrc);
        else if (!Dn.has(s._snapdomSrc))
          try {
            const f = await (await fetch(s._snapdomSrc)).blob();
            o = await new Promise((h2) => {
              const p = new FileReader();
              p.onload = () => h2(p.result), p.readAsDataURL(f);
            }), $t.set(s._snapdomSrc, o), Dn.add(s._snapdomSrc);
          } catch {
            console.warn("[snapdom] Failed to fetch dynamic font src:", s._snapdomSrc);
            continue;
          }
      }
      i += `@font-face {
  font-family: '${s.family}';
  src: url(${o});
  font-style: ${s.style || "normal"};
  font-weight: ${s.weight || "normal"};
}
`;
    }
  if (i && ($t.set("fonts-embed-css", i), e10)) {
    const s = document.createElement("style");
    s.setAttribute("data-snapdom", "embedFonts"), s.textContent = i, document.head.appendChild(s);
  }
  return i;
}
async function Hp(e10, t, n, r, i, s = false, o) {
  var _a2;
  if (!(e10 instanceof Element) || !(t instanceof Element)) return;
  for (const h2 of ["::before", "::after", "::first-letter"])
    try {
      const p = ml(e10, h2);
      if (!p || typeof p[Symbol.iterator] != "function") continue;
      if (h2 === "::first-letter") {
        const D = getComputedStyle(e10);
        if (!(p.color !== D.color || p.fontSize !== D.fontSize || p.fontWeight !== D.fontWeight)) continue;
        const O = Array.from(t.childNodes).find(
          (se) => se.nodeType === Node.TEXT_NODE && se.textContent && se.textContent.trim().length > 0
        );
        if (!O) continue;
        const q = O.textContent, R = (_a2 = q.match(/^([^\p{L}\p{N}\s]*[\p{L}\p{N}](?:['â€™])?)/u)) == null ? void 0 : _a2[0], J = q.slice((R == null ? void 0 : R.length) || 0);
        if (!R || /[\uD800-\uDFFF]/.test(R)) continue;
        const K = document.createElement("span");
        K.textContent = R, K.dataset.snapdomPseudo = "::first-letter";
        const V = Th(p), te = ca(V, "span", i);
        n.set(K, te);
        const Z = document.createTextNode(J);
        t.replaceChild(Z, O), t.insertBefore(K, Z);
        continue;
      }
      const b = p.getPropertyValue("content"), v = p.getPropertyValue("background-image"), k = p.getPropertyValue("background-color"), w = b !== "none", A = v && v !== "none", T = k && k !== "transparent" && k !== "rgba(0, 0, 0, 0)";
      if (w || A || T) {
        const D = p.getPropertyValue("font-family"), N = parseInt(p.getPropertyValue("font-size")) || 32, O = parseInt(p.getPropertyValue("font-weight")) || false, q = p.getPropertyValue("color") || "#000", z = document.createElement("span");
        z.dataset.snapdomPseudo = h2;
        const R = Th(p), J = ca(R, "span", i);
        n.set(z, J);
        const K = Un(D), V = bk(b);
        if (K && V.length === 1) {
          const se = document.createElement("img");
          se.src = await _k(V, D, O, N, q), se.style = `width:${N}px;height:auto;object-fit:contain;`, z.appendChild(se);
        } else if (V.startsWith("url(")) {
          const se = Lp(V);
          if (se && se.trim() !== "")
            try {
              const fe = document.createElement("img"), $ = await gl(bl(se, { useProxy: o }));
              fe.src = $, fe.style = `width:${N}px;height:auto;object-fit:contain;`, z.appendChild(fe);
            } catch (fe) {
              console.error(`[snapdom] Error in pseudo ${h2} for`, e10, fe);
            }
        } else !K && V && V !== "none" && (z.textContent = V);
        if (A)
          try {
            const se = Rp(v), fe = await Promise.all(
              se.map(($) => $p($))
            );
            z.style.backgroundImage = fe.join(", ");
          } catch (se) {
            console.warn(`[snapdom] Failed to inline background-image for ${h2}`, se);
          }
        if (T && (z.style.backgroundColor = k), !(z.childNodes.length > 0 || z.textContent && z.textContent.trim() !== "" || A || T)) continue;
        h2 === "::before" ? t.insertBefore(z, t.firstChild) : t.appendChild(z);
      }
    } catch (p) {
      console.warn(`[snapdom] Failed to capture ${h2} for`, e10, p);
    }
  const l = Array.from(e10.children), f = Array.from(t.children).filter((h2) => !h2.dataset.snapdomPseudo);
  for (let h2 = 0; h2 < Math.min(l.length, f.length); h2++)
    await Hp(
      l[h2],
      f[h2],
      n,
      r,
      i,
      s,
      o
    );
}
function Ek(e10) {
  if (!e10) return;
  const t = document.querySelectorAll("svg > defs");
  t.length && e10.querySelectorAll("svg").forEach((n) => {
    const r = n.querySelectorAll("use");
    if (!r.length) return;
    const i = /* @__PURE__ */ new Set();
    if (r.forEach((o) => {
      const l = o.getAttribute("xlink:href") || o.getAttribute("href");
      l && l.startsWith("#") && i.add(l.slice(1));
    }), !i.size) return;
    const s = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    for (const o of i)
      for (const l of t) {
        const f = l.querySelector(`#${CSS.escape(o)}`);
        if (f) {
          s.appendChild(f.cloneNode(true));
          break;
        }
      }
    s.childNodes.length && n.insertBefore(s, n.firstChild);
  });
}
async function Ck(e10, t = false, n = false, r = {}) {
  var _a2;
  const i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new WeakMap(), o = /* @__PURE__ */ new Map();
  let l;
  try {
    l = s0(e10, i, s, o, t, r, e10);
  } catch (h2) {
    throw console.warn("deepClone failed:", h2), h2;
  }
  try {
    await Hp(e10, l, i, s, t, n, r.useProxy);
  } catch (h2) {
    console.warn("inlinePseudoElements failed:", h2);
  }
  try {
    Ek(l);
  } catch (h2) {
    console.warn("inlineExternalDef failed:", h2);
  }
  let f = "";
  if (t) {
    const h2 = gk(i);
    f = Array.from(h2.entries()).map(([p, b]) => `.${b}{${p}}`).join("");
    for (const [p, b] of i.entries()) {
      if (p.tagName === "STYLE") continue;
      const v = h2.get(b);
      v && p.classList.add(v);
      const k = (_a2 = p.style) == null ? void 0 : _a2.backgroundImage;
      p.removeAttribute("style"), k && k !== "none" && (p.style.backgroundImage = k);
    }
  } else
    for (const [h2, p] of i.entries())
      h2.tagName !== "STYLE" && h2.setAttribute("style", p.replace(/;/g, "; "));
  for (const [h2, p] of o.entries()) {
    const b = p.scrollLeft, v = p.scrollTop;
    if ((b || v) && h2 instanceof HTMLElement) {
      h2.style.overflow = "hidden", h2.style.scrollbarWidth = "none", h2.style.msOverflowStyle = "none";
      const w = document.createElement("div");
      for (w.style.transform = `translate(${-b}px, ${-v}px)`, w.style.willChange = "transform", w.style.display = "inline-block", w.style.width = "100%"; h2.firstChild; )
        w.appendChild(h2.firstChild);
      h2.appendChild(w);
    }
  }
  if (e10 === o.get(l)) {
    const h2 = s.get(e10) || window.getComputedStyle(e10);
    s.set(e10, h2);
    const p = yk(h2.transform);
    l.style.margin = "0", l.style.position = "static", l.style.top = "auto", l.style.left = "auto", l.style.right = "auto", l.style.bottom = "auto", l.style.zIndex = "auto", l.style.float = "none", l.style.clear = "none", l.style.transform = p || "";
  }
  for (const [h2, p] of o.entries())
    p.tagName === "PRE" && (h2.style.marginTop = "0", h2.style.marginBlockStart = "0");
  return { clone: l, classCSS: f, styleCache: s };
}
async function Tk(e10, t = {}) {
  const n = Array.from(e10.querySelectorAll("img")), r = async (i) => {
    const s = i.src;
    try {
      const o = await gl(s, { useProxy: t.useProxy });
      i.src = o, i.width || (i.width = i.naturalWidth || 100), i.height || (i.height = i.naturalHeight || 100);
    } catch {
      const o = document.createElement("div");
      o.style = `width: ${i.width || 100}px; height: ${i.height || 100}px; background: #ccc; display: inline-block; text-align: center; line-height: ${i.height || 100}px; color: #666; font-size: 12px;`, o.innerText = "img", i.replaceWith(o);
    }
  };
  for (let i = 0; i < n.length; i += 4) {
    const s = n.slice(i, i + 4).map(r);
    await Promise.allSettled(s);
  }
}
async function Dk(e10, t, n, r = {}) {
  const i = [[e10, t]], s = [
    "background-image",
    "mask",
    "mask-image",
    "-webkit-mask-image",
    "mask-source",
    "mask-box-image-source",
    "mask-border-source",
    "-webkit-mask-box-image-source"
  ];
  for (; i.length; ) {
    const [o, l] = i.shift(), f = n.get(o) || ml(o);
    n.has(o) || n.set(o, f);
    for (const v of s) {
      const k = f.getPropertyValue(v);
      if (!k || k === "none") continue;
      const w = Rp(k), A = await Promise.all(
        w.map((T) => $p(T, r))
      );
      A.some((T) => T && T !== "none" && !/^url\(undefined/.test(T)) && l.style.setProperty(v, A.join(", "));
    }
    const h2 = f.getPropertyValue("background-color");
    h2 && h2 !== "transparent" && h2 !== "rgba(0, 0, 0, 0)" && (l.style.backgroundColor = h2);
    const p = Array.from(o.children), b = Array.from(l.children);
    for (let v = 0; v < Math.min(p.length, b.length); v++)
      i.push([p[v], b[v]]);
  }
}
async function Mk(e10, t = {}) {
  if (!e10) throw new Error("Element cannot be null or undefined");
  const { compress: n = true, embedFonts: r = false, fast: i = true, scale: s = 1, useProxy: o = "" } = t;
  let l, f, h2, p = "", b = "", v, k;
  if ({ clone: l, classCSS: f, styleCache: h2 } = await Ck(e10, n, r, t), await new Promise((A) => {
    _i(async () => {
      await Tk(l, t), A();
    }, { fast: i });
  }), await new Promise((A) => {
    _i(async () => {
      await Dk(e10, l, h2, t), A();
    }, { fast: i });
  }), r && await new Promise((A) => {
    _i(async () => {
      p = await Ak(), A();
    }, { fast: i });
  }), n) {
    const A = pk(l).sort(), T = A.join(",");
    _o.has(T) ? b = _o.get(T) : await new Promise((D) => {
      _i(() => {
        b = mk(A), _o.set(T, b), D();
      }, { fast: i });
    });
  }
  await new Promise((A) => {
    _i(() => {
      const T = e10.getBoundingClientRect();
      let D = T.width, N = T.height;
      const O = Number.isFinite(t.width), q = Number.isFinite(t.height), z = typeof s == "number" && s !== 1;
      if (!z) {
        const fe = T.width / T.height;
        O && q ? (D = t.width, N = t.height) : O ? (D = t.width, N = D / fe) : q && (N = t.height, D = N * fe);
      }
      if (D = Math.ceil(D), N = Math.ceil(N), l.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), l.style.transformOrigin = "top left", !z && (O || q)) {
        const fe = T.width, $ = T.height, X = D / fe, j = N / $, Q = l.style.transform || "", ee = `scale(${X}, ${j})`;
        l.style.transform = `${ee} ${Q}`.trim();
      } else z && qp() && (l.style.scale = `${s}`);
      const R = "http://www.w3.org/2000/svg", J = document.createElementNS(R, "foreignObject");
      J.setAttribute("width", "100%"), J.setAttribute("height", "100%");
      const K = document.createElement("style");
      K.textContent = b + p + "svg{overflow:visible;}" + f, J.appendChild(K), J.appendChild(l);
      const te = new XMLSerializer().serializeToString(J);
      k = `<svg xmlns="${R}" width="${D}" height="${N}" viewBox="0 0 ${D} ${N}">` + te + "</svg>", v = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(k)}`, A();
    }, { fast: i });
  });
  const w = document.getElementById("snapdom-sandbox");
  return w && w.style.position === "absolute" && w.remove(), v;
}
async function Nk(e10, { dpr: t = 1, scale: n = 1 }) {
  const r = new Image();
  return r.src = e10, await r.decode(), qp ? (r.width = r.width * n, r.height = r.height * n) : (r.width = r.width / n, r.height = r.height / n), r;
}
async function jp(e10, { dpr: t = 1, scale: n = 1 } = {}) {
  const r = new Image();
  r.src = e10, await r.decode();
  const i = document.createElement("canvas"), s = r.width * n, o = r.height * n;
  i.width = Math.ceil(s * t), i.height = Math.ceil(o * t);
  const l = i.getContext("2d");
  return l.scale(t, t), l.drawImage(r, 0, 0, s, o), i.style.width = `${s}px`, i.style.height = `${o}px`, i;
}
async function Up(e10, {
  type: t = "svg",
  scale: n = 1,
  backgroundColor: r = "#fff",
  quality: i
} = {}) {
  const s = {
    jpg: "image/jpeg",
    jpeg: "image/jpeg",
    png: "image/png",
    webp: "image/webp"
  }[t] || "image/png";
  if (t === "svg") {
    const l = decodeURIComponent(e10.split(",")[1]);
    return new Blob([l], { type: "image/svg+xml" });
  }
  const o = await yl(e10, { dpr: 1, scale: n }, r);
  return new Promise((l) => {
    o.toBlob((f) => l(f), `${s}`, i);
  });
}
async function yl(e10, { dpr: t = 1, scale: n = 1 }, r) {
  const i = await jp(e10, { dpr: t, scale: n });
  if (!r) return i;
  const s = document.createElement("canvas");
  s.width = i.width, s.height = i.height;
  const o = s.getContext("2d");
  return o.fillStyle = r, o.fillRect(0, 0, s.width, s.height), o.drawImage(i, 0, 0), s;
}
async function Eo(e10, { dpr: t = 1, scale: n = 1, backgroundColor: r = "#fff", quality: i }, s = "png") {
  const o = await yl(e10, { dpr: t, scale: n }, r), l = new Image();
  return l.src = o.toDataURL(`image/${s}`, i), await l.decode(), l.style.width = `${o.width / t}px`, l.style.height = `${o.height / t}px`, l;
}
async function Ik(e10, { dpr: t = 1, scale: n = 1, backgroundColor: r = "#fff", format: i = "png", filename: s = "capture" } = {}) {
  if (i === "svg") {
    const v = await Up(e10), k = URL.createObjectURL(v), w = document.createElement("a");
    w.href = k, w.download = `${s}.svg`, w.click(), URL.revokeObjectURL(k);
    return;
  }
  const o = ["jpg", "jpeg", "webp"].includes(i) ? "#fff" : void 0, f = await yl(e10, { dpr: t, scale: n }, r ?? o), h2 = {
    jpg: "image/jpeg",
    jpeg: "image/jpeg",
    png: "image/png",
    webp: "image/webp"
  }[i] || "image/png", p = f.toDataURL(h2), b = document.createElement("a");
  b.href = p, b.download = `${s}.${i}`, b.click();
}
async function dt(e10, t = {}) {
  if (t = { scale: 1, ...t }, !e10) throw new Error("Element cannot be null or undefined");
  return t.iconFonts && kk(t.iconFonts), await dt.capture(e10, t);
}
dt.capture = async (e10, t = {}) => {
  const n = await Mk(e10, t), r = window.devicePixelRatio || 1, i = t.scale || 1;
  return {
    url: n,
    options: t,
    toRaw: () => n,
    toImg: () => Nk(n, { dpr: r, scale: i }),
    toCanvas: () => jp(n, { dpr: r, scale: i }),
    toBlob: (s) => Up(n, { scale: i, ...s }),
    toPng: (s) => Eo(n, { dpr: r, scale: i, ...s }, "png"),
    toJpg: (s) => Eo(n, { dpr: r, scale: i, ...s }, "jpeg"),
    toWebp: (s) => Eo(n, { dpr: r, scale: i, ...s }, "webp"),
    download: ({ format: s = "png", filename: o = "capture", backgroundColor: l } = {}) => Ik(n, { dpr: r, scale: i, backgroundColor: l, format: s, filename: o })
  };
};
dt.toRaw = async (e10, t) => (await dt.capture(e10, t)).toRaw();
dt.toImg = async (e10, t) => (await dt.capture(e10, t)).toImg();
dt.toCanvas = async (e10, t) => (await dt.capture(e10, t)).toCanvas();
dt.toBlob = async (e10, t) => (await dt.capture(e10, t)).toBlob(t);
dt.toPng = async (e10, t) => (await dt.capture(e10, t)).toPng(t);
dt.toJpg = async (e10, t) => (await dt.capture(e10, t)).toJpg(t);
dt.toWebp = async (e10, t) => (await dt.capture(e10, t)).toWebp(t);
dt.download = async (e10, t = {}) => {
  const {
    format: n = "png",
    filename: r = "capture",
    backgroundColor: i,
    ...s
  } = t;
  return await (await dt.capture(e10, s)).download({ format: n, filename: r, backgroundColor: i });
};
var u0 = { exports: {} };
var Fk = u0.exports;
var Mh;
function Bk() {
  return Mh || (Mh = 1, function(e10, t) {
    (function(n, r) {
      e10.exports = r();
    })(Fk, function() {
      var n = 1e3, r = 6e4, i = 36e5, s = "millisecond", o = "second", l = "minute", f = "hour", h2 = "day", p = "week", b = "month", v = "quarter", k = "year", w = "date", A = "Invalid Date", T = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, D = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, N = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function($) {
        var X = ["th", "st", "nd", "rd"], j = $ % 100;
        return "[" + $ + (X[(j - 20) % 10] || X[j] || X[0]) + "]";
      } }, O = function($, X, j) {
        var Q = String($);
        return !Q || Q.length >= X ? $ : "" + Array(X + 1 - Q.length).join(j) + $;
      }, q = { s: O, z: function($) {
        var X = -$.utcOffset(), j = Math.abs(X), Q = Math.floor(j / 60), ee = j % 60;
        return (X <= 0 ? "+" : "-") + O(Q, 2, "0") + ":" + O(ee, 2, "0");
      }, m: function $(X, j) {
        if (X.date() < j.date()) return -$(j, X);
        var Q = 12 * (j.year() - X.year()) + (j.month() - X.month()), ee = X.clone().add(Q, b), le = j - ee < 0, ae = X.clone().add(Q + (le ? -1 : 1), b);
        return +(-(Q + (j - ee) / (le ? ee - ae : ae - ee)) || 0);
      }, a: function($) {
        return $ < 0 ? Math.ceil($) || 0 : Math.floor($);
      }, p: function($) {
        return { M: b, y: k, w: p, d: h2, D: w, h: f, m: l, s: o, ms: s, Q: v }[$] || String($ || "").toLowerCase().replace(/s$/, "");
      }, u: function($) {
        return $ === void 0;
      } }, z = "en", R = {};
      R[z] = N;
      var J = "$isDayjsObject", K = function($) {
        return $ instanceof se || !(!$ || !$[J]);
      }, V = function $(X, j, Q) {
        var ee;
        if (!X) return z;
        if (typeof X == "string") {
          var le = X.toLowerCase();
          R[le] && (ee = le), j && (R[le] = j, ee = le);
          var ae = X.split("-");
          if (!ee && ae.length > 1) return $(ae[0]);
        } else {
          var ne = X.name;
          R[ne] = X, ee = ne;
        }
        return !Q && ee && (z = ee), ee || !Q && z;
      }, te = function($, X) {
        if (K($)) return $.clone();
        var j = typeof X == "object" ? X : {};
        return j.date = $, j.args = arguments, new se(j);
      }, Z = q;
      Z.l = V, Z.i = K, Z.w = function($, X) {
        return te($, { locale: X.$L, utc: X.$u, x: X.$x, $offset: X.$offset });
      };
      var se = function() {
        function $(j) {
          this.$L = V(j.locale, null, true), this.parse(j), this.$x = this.$x || j.x || {}, this[J] = true;
        }
        var X = $.prototype;
        return X.parse = function(j) {
          this.$d = function(Q) {
            var ee = Q.date, le = Q.utc;
            if (ee === null) return /* @__PURE__ */ new Date(NaN);
            if (Z.u(ee)) return /* @__PURE__ */ new Date();
            if (ee instanceof Date) return new Date(ee);
            if (typeof ee == "string" && !/Z$/i.test(ee)) {
              var ae = ee.match(T);
              if (ae) {
                var ne = ae[2] - 1 || 0, P = (ae[7] || "0").substring(0, 3);
                return le ? new Date(Date.UTC(ae[1], ne, ae[3] || 1, ae[4] || 0, ae[5] || 0, ae[6] || 0, P)) : new Date(ae[1], ne, ae[3] || 1, ae[4] || 0, ae[5] || 0, ae[6] || 0, P);
              }
            }
            return new Date(ee);
          }(j), this.init();
        }, X.init = function() {
          var j = this.$d;
          this.$y = j.getFullYear(), this.$M = j.getMonth(), this.$D = j.getDate(), this.$W = j.getDay(), this.$H = j.getHours(), this.$m = j.getMinutes(), this.$s = j.getSeconds(), this.$ms = j.getMilliseconds();
        }, X.$utils = function() {
          return Z;
        }, X.isValid = function() {
          return this.$d.toString() !== A;
        }, X.isSame = function(j, Q) {
          var ee = te(j);
          return this.startOf(Q) <= ee && ee <= this.endOf(Q);
        }, X.isAfter = function(j, Q) {
          return te(j) < this.startOf(Q);
        }, X.isBefore = function(j, Q) {
          return this.endOf(Q) < te(j);
        }, X.$g = function(j, Q, ee) {
          return Z.u(j) ? this[Q] : this.set(ee, j);
        }, X.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, X.valueOf = function() {
          return this.$d.getTime();
        }, X.startOf = function(j, Q) {
          var ee = this, le = !!Z.u(Q) || Q, ae = Z.p(j), ne = function(_e, Te) {
            var Ke = Z.w(ee.$u ? Date.UTC(ee.$y, Te, _e) : new Date(ee.$y, Te, _e), ee);
            return le ? Ke : Ke.endOf(h2);
          }, P = function(_e, Te) {
            return Z.w(ee.toDate()[_e].apply(ee.toDate("s"), (le ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(Te)), ee);
          }, he = this.$W, ge = this.$M, De = this.$D, He = "set" + (this.$u ? "UTC" : "");
          switch (ae) {
            case k:
              return le ? ne(1, 0) : ne(31, 11);
            case b:
              return le ? ne(1, ge) : ne(0, ge + 1);
            case p:
              var Y = this.$locale().weekStart || 0, Me = (he < Y ? he + 7 : he) - Y;
              return ne(le ? De - Me : De + (6 - Me), ge);
            case h2:
            case w:
              return P(He + "Hours", 0);
            case f:
              return P(He + "Minutes", 1);
            case l:
              return P(He + "Seconds", 2);
            case o:
              return P(He + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, X.endOf = function(j) {
          return this.startOf(j, false);
        }, X.$set = function(j, Q) {
          var ee, le = Z.p(j), ae = "set" + (this.$u ? "UTC" : ""), ne = (ee = {}, ee[h2] = ae + "Date", ee[w] = ae + "Date", ee[b] = ae + "Month", ee[k] = ae + "FullYear", ee[f] = ae + "Hours", ee[l] = ae + "Minutes", ee[o] = ae + "Seconds", ee[s] = ae + "Milliseconds", ee)[le], P = le === h2 ? this.$D + (Q - this.$W) : Q;
          if (le === b || le === k) {
            var he = this.clone().set(w, 1);
            he.$d[ne](P), he.init(), this.$d = he.set(w, Math.min(this.$D, he.daysInMonth())).$d;
          } else ne && this.$d[ne](P);
          return this.init(), this;
        }, X.set = function(j, Q) {
          return this.clone().$set(j, Q);
        }, X.get = function(j) {
          return this[Z.p(j)]();
        }, X.add = function(j, Q) {
          var ee, le = this;
          j = Number(j);
          var ae = Z.p(Q), ne = function(ge) {
            var De = te(le);
            return Z.w(De.date(De.date() + Math.round(ge * j)), le);
          };
          if (ae === b) return this.set(b, this.$M + j);
          if (ae === k) return this.set(k, this.$y + j);
          if (ae === h2) return ne(1);
          if (ae === p) return ne(7);
          var P = (ee = {}, ee[l] = r, ee[f] = i, ee[o] = n, ee)[ae] || 1, he = this.$d.getTime() + j * P;
          return Z.w(he, this);
        }, X.subtract = function(j, Q) {
          return this.add(-1 * j, Q);
        }, X.format = function(j) {
          var Q = this, ee = this.$locale();
          if (!this.isValid()) return ee.invalidDate || A;
          var le = j || "YYYY-MM-DDTHH:mm:ssZ", ae = Z.z(this), ne = this.$H, P = this.$m, he = this.$M, ge = ee.weekdays, De = ee.months, He = ee.meridiem, Y = function(Te, Ke, vt, xn) {
            return Te && (Te[Ke] || Te(Q, le)) || vt[Ke].slice(0, xn);
          }, Me = function(Te) {
            return Z.s(ne % 12 || 12, Te, "0");
          }, _e = He || function(Te, Ke, vt) {
            var xn = Te < 12 ? "AM" : "PM";
            return vt ? xn.toLowerCase() : xn;
          };
          return le.replace(D, function(Te, Ke) {
            return Ke || function(vt) {
              switch (vt) {
                case "YY":
                  return String(Q.$y).slice(-2);
                case "YYYY":
                  return Z.s(Q.$y, 4, "0");
                case "M":
                  return he + 1;
                case "MM":
                  return Z.s(he + 1, 2, "0");
                case "MMM":
                  return Y(ee.monthsShort, he, De, 3);
                case "MMMM":
                  return Y(De, he);
                case "D":
                  return Q.$D;
                case "DD":
                  return Z.s(Q.$D, 2, "0");
                case "d":
                  return String(Q.$W);
                case "dd":
                  return Y(ee.weekdaysMin, Q.$W, ge, 2);
                case "ddd":
                  return Y(ee.weekdaysShort, Q.$W, ge, 3);
                case "dddd":
                  return ge[Q.$W];
                case "H":
                  return String(ne);
                case "HH":
                  return Z.s(ne, 2, "0");
                case "h":
                  return Me(1);
                case "hh":
                  return Me(2);
                case "a":
                  return _e(ne, P, true);
                case "A":
                  return _e(ne, P, false);
                case "m":
                  return String(P);
                case "mm":
                  return Z.s(P, 2, "0");
                case "s":
                  return String(Q.$s);
                case "ss":
                  return Z.s(Q.$s, 2, "0");
                case "SSS":
                  return Z.s(Q.$ms, 3, "0");
                case "Z":
                  return ae;
              }
              return null;
            }(Te) || ae.replace(":", "");
          });
        }, X.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, X.diff = function(j, Q, ee) {
          var le, ae = this, ne = Z.p(Q), P = te(j), he = (P.utcOffset() - this.utcOffset()) * r, ge = this - P, De = function() {
            return Z.m(ae, P);
          };
          switch (ne) {
            case k:
              le = De() / 12;
              break;
            case b:
              le = De();
              break;
            case v:
              le = De() / 3;
              break;
            case p:
              le = (ge - he) / 6048e5;
              break;
            case h2:
              le = (ge - he) / 864e5;
              break;
            case f:
              le = ge / i;
              break;
            case l:
              le = ge / r;
              break;
            case o:
              le = ge / n;
              break;
            default:
              le = ge;
          }
          return ee ? le : Z.a(le);
        }, X.daysInMonth = function() {
          return this.endOf(b).$D;
        }, X.$locale = function() {
          return R[this.$L];
        }, X.locale = function(j, Q) {
          if (!j) return this.$L;
          var ee = this.clone(), le = V(j, Q, true);
          return le && (ee.$L = le), ee;
        }, X.clone = function() {
          return Z.w(this.$d, this);
        }, X.toDate = function() {
          return new Date(this.valueOf());
        }, X.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, X.toISOString = function() {
          return this.$d.toISOString();
        }, X.toString = function() {
          return this.$d.toUTCString();
        }, $;
      }(), fe = se.prototype;
      return te.prototype = fe, [["$ms", s], ["$s", o], ["$m", l], ["$H", f], ["$W", h2], ["$M", b], ["$y", k], ["$D", w]].forEach(function($) {
        fe[$[1]] = function(X) {
          return this.$g(X, $[0], $[1]);
        };
      }), te.extend = function($, X) {
        return $.$i || ($(X, se, te), $.$i = true), te;
      }, te.locale = V, te.isDayjs = K, te.unix = function($) {
        return te(1e3 * $);
      }, te.en = R[z], te.Ls = R, te.p = {}, te;
    });
  }(u0)), u0.exports;
}
Bk();
function Ok(e10) {
  navigator.clipboard.writeText(e10);
}
var ha = 1;
var zk = class {
  constructor() {
    __publicField(this, "subscribers");
    __publicField(this, "toasts");
    __publicField(this, "dismissedToasts");
    __publicField(this, "subscribe", (e10) => (this.subscribers.push(e10), () => {
      const t = this.subscribers.indexOf(e10);
      this.subscribers.splice(t, 1);
    }));
    __publicField(this, "publish", (e10) => {
      this.subscribers.forEach((t) => t(e10));
    });
    __publicField(this, "addToast", (e10) => {
      this.publish(e10), this.toasts = [...this.toasts, e10];
    });
    __publicField(this, "create", (e10) => {
      var _a2;
      const { message: t, ...n } = e10, r = typeof e10.id == "number" || e10.id && ((_a2 = e10.id) == null ? void 0 : _a2.length) > 0 ? e10.id : ha++, i = this.toasts.find((o) => o.id === r), s = e10.dismissible === void 0 ? true : e10.dismissible;
      return this.dismissedToasts.has(r) && this.dismissedToasts.delete(r), i ? this.toasts = this.toasts.map((o) => o.id === r ? (this.publish({
        ...o,
        ...e10,
        id: r,
        title: t
      }), {
        ...o,
        ...e10,
        id: r,
        dismissible: s,
        title: t
      }) : o) : this.addToast({
        title: t,
        ...n,
        dismissible: s,
        id: r
      }), r;
    });
    __publicField(this, "dismiss", (e10) => (e10 ? (this.dismissedToasts.add(e10), requestAnimationFrame(() => this.subscribers.forEach((t) => t({
      id: e10,
      dismiss: true
    })))) : this.toasts.forEach((t) => {
      this.subscribers.forEach((n) => n({
        id: t.id,
        dismiss: true
      }));
    }), e10));
    __publicField(this, "message", (e10, t) => this.create({
      ...t,
      message: e10,
      type: "default"
    }));
    __publicField(this, "error", (e10, t) => this.create({
      ...t,
      type: "error",
      message: e10
    }));
    __publicField(this, "success", (e10, t) => this.create({
      ...t,
      type: "success",
      message: e10
    }));
    __publicField(this, "info", (e10, t) => this.create({
      ...t,
      type: "info",
      message: e10
    }));
    __publicField(this, "warning", (e10, t) => this.create({
      ...t,
      type: "warning",
      message: e10
    }));
    __publicField(this, "loading", (e10, t) => this.create({
      ...t,
      type: "loading",
      message: e10
    }));
    __publicField(this, "promise", (e10, t) => {
      if (!t) return;
      let n;
      t.loading !== void 0 && (n = this.create({
        ...t,
        promise: e10,
        type: "loading",
        message: t.loading,
        description: typeof t.description != "function" ? t.description : void 0
      }));
      const r = Promise.resolve(e10 instanceof Function ? e10() : e10);
      let i = n !== void 0, s;
      const o = r.then(async (f) => {
        if (s = ["resolve", f], isVNode(f))
          i = false, this.create({
            id: n,
            type: "default",
            message: f
          });
        else if (Lk(f) && !f.ok) {
          i = false;
          const p = typeof t.error == "function" ? await t.error(`HTTP error! status: ${f.status}`) : t.error, b = typeof t.description == "function" ? await t.description(`HTTP error! status: ${f.status}`) : t.description, k = typeof p == "object" && !isVNode(p) ? p : {
            message: p || "",
            id: n || ""
          };
          this.create({
            id: n,
            type: "error",
            description: b,
            ...k
          });
        } else if (f instanceof Error) {
          i = false;
          const p = typeof t.error == "function" ? await t.error(f) : t.error, b = typeof t.description == "function" ? await t.description(f) : t.description, k = typeof p == "object" && !isVNode(p) ? p : {
            message: p || "",
            id: n || ""
          };
          this.create({
            id: n,
            type: "error",
            description: b,
            ...k
          });
        } else if (t.success !== void 0) {
          i = false;
          const p = typeof t.success == "function" ? await t.success(f) : t.success, b = typeof t.description == "function" ? await t.description(f) : t.description, k = typeof p == "object" && !isVNode(p) ? p : {
            message: p || "",
            id: n || ""
          };
          this.create({
            id: n,
            type: "success",
            description: b,
            ...k
          });
        }
      }).catch(async (f) => {
        if (s = ["reject", f], t.error !== void 0) {
          i = false;
          const h2 = typeof t.error == "function" ? await t.error(f) : t.error, p = typeof t.description == "function" ? await t.description(f) : t.description, v = typeof h2 == "object" && !isVNode(h2) ? h2 : {
            message: h2 || "",
            id: n || ""
          };
          this.create({
            id: n,
            type: "error",
            description: p,
            ...v
          });
        }
      }).finally(() => {
        var _a2;
        i && (this.dismiss(n), n = void 0), (_a2 = t.finally) == null ? void 0 : _a2.call(t);
      }), l = () => new Promise((f, h2) => o.then(() => s[0] === "reject" ? h2(s[1]) : f(s[1])).catch(h2));
      return typeof n != "string" && typeof n != "number" ? { unwrap: l } : Object.assign(n, { unwrap: l });
    });
    __publicField(this, "custom", (e10, t) => {
      const n = (t == null ? void 0 : t.id) || ha++;
      return this.publish({
        component: e10,
        id: n,
        ...t
      }), n;
    });
    __publicField(this, "getActiveToasts", () => this.toasts.filter((e10) => !this.dismissedToasts.has(e10.id)));
    this.subscribers = [], this.toasts = [], this.dismissedToasts = /* @__PURE__ */ new Set();
  }
};
var Tt = new zk();
function $k(e10, t) {
  const n = (t == null ? void 0 : t.id) || ha++;
  return Tt.create({
    message: e10,
    id: n,
    type: "default",
    ...t
  }), n;
}
var Lk = (e10) => e10 && typeof e10 == "object" && "ok" in e10 && typeof e10.ok == "boolean" && "status" in e10 && typeof e10.status == "number";
var qk = $k;
var Rk = () => Tt.toasts;
var Pk = () => Tt.getActiveToasts();
var Nh = Object.assign(qk, {
  success: Tt.success,
  info: Tt.info,
  warning: Tt.warning,
  error: Tt.error,
  custom: Tt.custom,
  message: Tt.message,
  promise: Tt.promise,
  dismiss: Tt.dismiss,
  loading: Tt.loading
}, {
  getHistory: Rk,
  getToasts: Pk
});
function Ws(e10) {
  return e10.label !== void 0;
}
var Hk = 3;
var Vp = "24px";
var Gp = "16px";
var Ih = 4e3;
var jk = 356;
var Uk = 14;
var Vk = 45;
var Wp = 200;
function Gk() {
  const e10 = ref(false);
  return watchEffect(() => {
    const t = () => {
      e10.value = document.hidden;
    };
    return document.addEventListener("visibilitychange", t), () => window.removeEventListener("visibilitychange", t);
  }), { isDocumentHidden: e10 };
}
function jn(...e10) {
  return e10.filter(Boolean).join(" ");
}
function Wk(e10) {
  const [t, n] = e10.split("-"), r = [];
  return t && r.push(t), n && r.push(n), r;
}
function Kk(e10, t) {
  const n = {};
  return [e10, t].forEach((r, i) => {
    const s = i === 1, o = s ? "--mobile-offset" : "--offset", l = s ? Gp : Vp;
    function f(h2) {
      [
        "top",
        "right",
        "bottom",
        "left"
      ].forEach((p) => {
        n[`${o}-${p}`] = typeof h2 == "number" ? `${h2}px` : h2;
      });
    }
    typeof r == "number" || typeof r == "string" ? f(r) : typeof r == "object" ? [
      "top",
      "right",
      "bottom",
      "left"
    ].forEach((h2) => {
      r[h2] === void 0 ? n[`${o}-${h2}`] = l : n[`${o}-${h2}`] = typeof r[h2] == "number" ? `${r[h2]}px` : r[h2];
    }) : f(l);
  }), n;
}
var Xk = [
  "data-rich-colors",
  "data-styled",
  "data-mounted",
  "data-promise",
  "data-swiped",
  "data-removed",
  "data-visible",
  "data-y-position",
  "data-x-position",
  "data-index",
  "data-front",
  "data-swiping",
  "data-dismissible",
  "data-type",
  "data-invert",
  "data-swipe-out",
  "data-swipe-direction",
  "data-expanded"
];
var Yk = ["aria-label", "data-disabled"];
var Zk = defineComponent({
  __name: "Toast",
  props: {
    toast: {},
    toasts: {},
    index: {},
    swipeDirections: {},
    expanded: { type: Boolean },
    invert: { type: Boolean },
    heights: {},
    gap: {},
    position: {},
    visibleToasts: {},
    expandByDefault: { type: Boolean },
    closeButton: { type: Boolean },
    interacting: { type: Boolean },
    style: {},
    cancelButtonStyle: {},
    actionButtonStyle: {},
    duration: {},
    class: {},
    unstyled: { type: Boolean },
    descriptionClass: {},
    loadingIcon: {},
    classes: {},
    icons: {},
    closeButtonAriaLabel: {},
    defaultRichColors: { type: Boolean }
  },
  emits: [
    "update:heights",
    "update:height",
    "removeToast"
  ],
  setup(e10, { emit: t }) {
    const n = e10, r = t, i = ref(null), s = ref(null), o = ref(false), l = ref(false), f = ref(false), h2 = ref(false), p = ref(false), b = ref(0), v = ref(0), k = ref(n.toast.duration || n.duration || Ih), w = ref(null), A = ref(null), T = computed(() => n.index === 0), D = computed(() => n.index + 1 <= n.visibleToasts), N = computed(() => n.toast.type), O = computed(() => n.toast.dismissible !== false), q = computed(() => n.toast.class || ""), z = computed(() => n.descriptionClass || ""), R = computed(() => {
      const Y = n.toast.position || n.position, _e = n.heights.filter((Te) => Te.position === Y).findIndex((Te) => Te.toastId === n.toast.id);
      return _e >= 0 ? _e : 0;
    }), J = computed(() => {
      const Y = n.toast.position || n.position;
      return n.heights.filter((_e) => _e.position === Y).reduce((_e, Te, Ke) => Ke >= R.value ? _e : _e + Te.height, 0);
    }), K = computed(() => R.value * n.gap + J.value || 0), V = computed(() => n.toast.closeButton ?? n.closeButton), te = computed(() => n.toast.duration || n.duration || Ih), Z = ref(0), se = ref(0), fe = ref(null), $ = computed(() => n.position.split("-")), X = computed(() => $.value[0]), j = computed(() => $.value[1]), Q = computed(() => typeof n.toast.title != "string"), ee = computed(() => typeof n.toast.description != "string"), { isDocumentHidden: le } = Gk(), ae = computed(() => N.value && N.value === "loading");
    onMounted(() => {
      o.value = true, k.value = te.value;
    }), watchEffect(async () => {
      if (!o.value || !A.value) return;
      await nextTick();
      const Y = A.value, Me = Y.style.height;
      Y.style.height = "auto";
      const _e = Y.getBoundingClientRect().height;
      Y.style.height = Me, v.value = _e, r("update:height", {
        toastId: n.toast.id,
        height: _e,
        position: n.toast.position || n.position
      });
    });
    function ne() {
      l.value = true, b.value = K.value, setTimeout(() => {
        r("removeToast", n.toast);
      }, Wp);
    }
    function P() {
      var _a2, _b2;
      if (ae.value || !O.value) return {};
      ne(), (_b2 = (_a2 = n.toast).onDismiss) == null ? void 0 : _b2.call(_a2, n.toast);
    }
    function he(Y) {
      ae.value || !O.value || (w.value = /* @__PURE__ */ new Date(), b.value = K.value, Y.target.setPointerCapture(Y.pointerId), Y.target.tagName !== "BUTTON" && (f.value = true, fe.value = {
        x: Y.clientX,
        y: Y.clientY
      }));
    }
    function ge() {
      var _a2, _b2, _c, _d2, _e2, _f2, _g2;
      if (h2.value || !O.value) return;
      fe.value = null;
      const Y = Number(((_a2 = A.value) == null ? void 0 : _a2.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0), Me = Number(((_b2 = A.value) == null ? void 0 : _b2.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0), _e = (/* @__PURE__ */ new Date()).getTime() - (((_c = w.value) == null ? void 0 : _c.getTime()) || 0), Te = i.value === "x" ? Y : Me, Ke = Math.abs(Te) / _e;
      if (Math.abs(Te) >= Vk || Ke > 0.11) {
        b.value = K.value, (_e2 = (_d2 = n.toast).onDismiss) == null ? void 0 : _e2.call(_d2, n.toast), i.value === "x" ? s.value = Y > 0 ? "right" : "left" : s.value = Me > 0 ? "down" : "up", ne(), h2.value = true;
        return;
      } else
        (_f2 = A.value) == null ? void 0 : _f2.style.setProperty("--swipe-amount-x", "0px"), (_g2 = A.value) == null ? void 0 : _g2.style.setProperty("--swipe-amount-y", "0px");
      p.value = false, f.value = false, i.value = null;
    }
    function De(Y) {
      var _a2, _b2, _c, _d2;
      if (!fe.value || !O.value || (((_b2 = (_a2 = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a2.toString()) == null ? void 0 : _b2.length) ?? false)) return;
      const _e = Y.clientY - fe.value.y, Te = Y.clientX - fe.value.x, Ke = n.swipeDirections ?? Wk(n.position);
      !i.value && (Math.abs(Te) > 1 || Math.abs(_e) > 1) && (i.value = Math.abs(Te) > Math.abs(_e) ? "x" : "y");
      let vt = {
        x: 0,
        y: 0
      };
      const xn = (wn) => 1 / (1.5 + Math.abs(wn) / 20);
      if (i.value === "y") {
        if (Ke.includes("top") || Ke.includes("bottom")) if (Ke.includes("top") && _e < 0 || Ke.includes("bottom") && _e > 0) vt.y = _e;
        else {
          const wn = _e * xn(_e);
          vt.y = Math.abs(wn) < Math.abs(_e) ? wn : _e;
        }
      } else if (i.value === "x" && (Ke.includes("left") || Ke.includes("right")))
        if (Ke.includes("left") && Te < 0 || Ke.includes("right") && Te > 0) vt.x = Te;
        else {
          const wn = Te * xn(Te);
          vt.x = Math.abs(wn) < Math.abs(Te) ? wn : Te;
        }
      (Math.abs(vt.x) > 0 || Math.abs(vt.y) > 0) && (p.value = true), (_c = A.value) == null ? void 0 : _c.style.setProperty("--swipe-amount-x", `${vt.x}px`), (_d2 = A.value) == null ? void 0 : _d2.style.setProperty("--swipe-amount-y", `${vt.y}px`);
    }
    onMounted(() => {
      if (o.value = true, !A.value) return;
      const Y = A.value.getBoundingClientRect().height;
      v.value = Y;
      const Me = [{
        toastId: n.toast.id,
        height: Y,
        position: n.toast.position
      }, ...n.heights];
      r("update:heights", Me);
    }), onBeforeUnmount(() => {
      A.value && r("removeToast", n.toast);
    }), watchEffect((Y) => {
      if (n.toast.promise && N.value === "loading" || n.toast.duration === 1 / 0 || n.toast.type === "loading") return;
      let Me;
      const _e = () => {
        if (se.value < Z.value) {
          const Ke = (/* @__PURE__ */ new Date()).getTime() - Z.value;
          k.value = k.value - Ke;
        }
        se.value = (/* @__PURE__ */ new Date()).getTime();
      }, Te = () => {
        k.value !== 1 / 0 && (Z.value = (/* @__PURE__ */ new Date()).getTime(), Me = setTimeout(() => {
          var _a2, _b2;
          (_b2 = (_a2 = n.toast).onAutoClose) == null ? void 0 : _b2.call(_a2, n.toast), ne();
        }, k.value));
      };
      n.expanded || n.interacting || le.value ? _e() : Te(), Y(() => {
        clearTimeout(Me);
      });
    }), watch(() => n.toast.delete, (Y) => {
      Y !== void 0 && Y && ne();
    }, { deep: true });
    function He() {
      f.value = false, i.value = null, fe.value = null;
    }
    return (Y, Me) => {
      var _a2, _b2, _c, _d2, _e, _f2, _g2, _h2, _i2, _j, _k2, _l, _m, _n, _o2, _p2, _q, _r2, _s, _t, _u, _v2, _w2, _x2, _y2, _z, _A;
      return openBlock(), createElementBlock("li", {
        tabindex: "0",
        ref_key: "toastRef",
        ref: A,
        class: normalizeClass(unref(jn)(n.class, q.value, (_a2 = Y.classes) == null ? void 0 : _a2.toast, (_b2 = Y.toast.classes) == null ? void 0 : _b2.toast, (_c = Y.classes) == null ? void 0 : _c[N.value], (_e = (_d2 = Y.toast) == null ? void 0 : _d2.classes) == null ? void 0 : _e[N.value])),
        "data-sonner-toast": "",
        "data-rich-colors": Y.toast.richColors ?? Y.defaultRichColors,
        "data-styled": !(Y.toast.component || ((_f2 = Y.toast) == null ? void 0 : _f2.unstyled) || Y.unstyled),
        "data-mounted": o.value,
        "data-promise": !!Y.toast.promise,
        "data-swiped": p.value,
        "data-removed": l.value,
        "data-visible": D.value,
        "data-y-position": X.value,
        "data-x-position": j.value,
        "data-index": Y.index,
        "data-front": T.value,
        "data-swiping": f.value,
        "data-dismissible": O.value,
        "data-type": N.value,
        "data-invert": Y.toast.invert || Y.invert,
        "data-swipe-out": h2.value,
        "data-swipe-direction": s.value,
        "data-expanded": !!(Y.expanded || Y.expandByDefault && o.value),
        style: normalizeStyle({
          "--index": Y.index,
          "--toasts-before": Y.index,
          "--z-index": Y.toasts.length - Y.index,
          "--offset": `${l.value ? b.value : K.value}px`,
          "--initial-height": Y.expandByDefault ? "auto" : `${v.value}px`,
          ...Y.style,
          ...n.toast.style
        }),
        onDragend: He,
        onPointerdown: he,
        onPointerup: ge,
        onPointermove: De
      }, [V.value && !Y.toast.component && N.value !== "loading" ? (openBlock(), createElementBlock("button", {
        key: 0,
        "aria-label": Y.closeButtonAriaLabel || "Close toast",
        "data-disabled": ae.value,
        "data-close-button": "true",
        class: normalizeClass(unref(jn)((_g2 = Y.classes) == null ? void 0 : _g2.closeButton, (_i2 = (_h2 = Y.toast) == null ? void 0 : _h2.classes) == null ? void 0 : _i2.closeButton)),
        onClick: P
      }, [((_j = Y.icons) == null ? void 0 : _j.close) ? (openBlock(), createBlock(resolveDynamicComponent((_k2 = Y.icons) == null ? void 0 : _k2.close), { key: 0 })) : renderSlot(Y.$slots, "close-icon", { key: 1 })], 10, Yk)) : createCommentVNode("v-if", true), Y.toast.component ? (openBlock(), createBlock(resolveDynamicComponent(Y.toast.component), mergeProps({ key: 1 }, Y.toast.componentProps, { onCloseToast: P }), null, 16)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
        N.value !== "default" || Y.toast.icon || Y.toast.promise ? (openBlock(), createElementBlock("div", {
          key: 0,
          "data-icon": "",
          class: normalizeClass(unref(jn)((_l = Y.classes) == null ? void 0 : _l.icon, (_n = (_m = Y.toast) == null ? void 0 : _m.classes) == null ? void 0 : _n.icon))
        }, [Y.toast.icon ? (openBlock(), createBlock(resolveDynamicComponent(Y.toast.icon), { key: 0 })) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [N.value === "loading" ? renderSlot(Y.$slots, "loading-icon", { key: 0 }) : N.value === "success" ? renderSlot(Y.$slots, "success-icon", { key: 1 }) : N.value === "error" ? renderSlot(Y.$slots, "error-icon", { key: 2 }) : N.value === "warning" ? renderSlot(Y.$slots, "warning-icon", { key: 3 }) : N.value === "info" ? renderSlot(Y.$slots, "info-icon", { key: 4 }) : createCommentVNode("v-if", true)], 64))], 2)) : createCommentVNode("v-if", true),
        createBaseVNode("div", {
          "data-content": "",
          class: normalizeClass(unref(jn)((_o2 = Y.classes) == null ? void 0 : _o2.content, (_q = (_p2 = Y.toast) == null ? void 0 : _p2.classes) == null ? void 0 : _q.content))
        }, [createBaseVNode("div", {
          "data-title": "",
          class: normalizeClass(unref(jn)((_r2 = Y.classes) == null ? void 0 : _r2.title, (_s = Y.toast.classes) == null ? void 0 : _s.title))
        }, [Q.value ? (openBlock(), createBlock(resolveDynamicComponent(Y.toast.title), normalizeProps(mergeProps({ key: 0 }, Y.toast.componentProps)), null, 16)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(Y.toast.title), 1)], 64))], 2), Y.toast.description ? (openBlock(), createElementBlock("div", {
          key: 0,
          "data-description": "",
          class: normalizeClass(unref(jn)(Y.descriptionClass, z.value, (_t = Y.classes) == null ? void 0 : _t.description, (_u = Y.toast.classes) == null ? void 0 : _u.description))
        }, [ee.value ? (openBlock(), createBlock(resolveDynamicComponent(Y.toast.description), normalizeProps(mergeProps({ key: 0 }, Y.toast.componentProps)), null, 16)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [createTextVNode(toDisplayString(Y.toast.description), 1)], 64))], 2)) : createCommentVNode("v-if", true)], 2),
        Y.toast.cancel ? (openBlock(), createElementBlock("button", {
          key: 1,
          style: normalizeStyle(Y.toast.cancelButtonStyle || Y.cancelButtonStyle),
          class: normalizeClass(unref(jn)((_v2 = Y.classes) == null ? void 0 : _v2.cancelButton, (_w2 = Y.toast.classes) == null ? void 0 : _w2.cancelButton)),
          "data-button": "",
          "data-cancel": "",
          onClick: Me[0] || (Me[0] = (_e2) => {
            var _a3, _b3;
            unref(Ws)(Y.toast.cancel) && O.value && ((_b3 = (_a3 = Y.toast.cancel).onClick) == null ? void 0 : _b3.call(_a3, _e2), ne());
          })
        }, toDisplayString(unref(Ws)(Y.toast.cancel) ? (_x2 = Y.toast.cancel) == null ? void 0 : _x2.label : Y.toast.cancel), 7)) : createCommentVNode("v-if", true),
        Y.toast.action ? (openBlock(), createElementBlock("button", {
          key: 2,
          style: normalizeStyle(Y.toast.actionButtonStyle || Y.actionButtonStyle),
          class: normalizeClass(unref(jn)((_y2 = Y.classes) == null ? void 0 : _y2.actionButton, (_z = Y.toast.classes) == null ? void 0 : _z.actionButton)),
          "data-button": "",
          "data-action": "",
          onClick: Me[1] || (Me[1] = (_e2) => {
            var _a3, _b3;
            unref(Ws)(Y.toast.action) && ((_b3 = (_a3 = Y.toast.action).onClick) == null ? void 0 : _b3.call(_a3, _e2), !_e2.defaultPrevented && ne());
          })
        }, toDisplayString(unref(Ws)(Y.toast.action) ? (_A = Y.toast.action) == null ? void 0 : _A.label : Y.toast.action), 7)) : createCommentVNode("v-if", true)
      ], 64))], 46, Xk);
    };
  }
});
var Jk = Zk;
var fs = (e10, t) => {
  const n = e10.__vccOpts || e10;
  for (const [r, i] of t) n[r] = i;
  return n;
};
var Qk = {};
var e_ = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "12",
  height: "12",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stoke-width": "1.5",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
};
function t_(e10, t) {
  return openBlock(), createElementBlock("svg", e_, t[0] || (t[0] = [createBaseVNode("line", {
    x1: "18",
    y1: "6",
    x2: "6",
    y2: "18"
  }, null, -1), createBaseVNode("line", {
    x1: "6",
    y1: "6",
    x2: "18",
    y2: "18"
  }, null, -1)]));
}
var n_ = fs(Qk, [["render", t_]]);
var r_ = ["data-visible"];
var i_ = { class: "sonner-spinner" };
var s_ = defineComponent({
  __name: "Loader",
  props: { visible: { type: Boolean } },
  setup(e10) {
    const t = Array(12).fill(0);
    return (n, r) => (openBlock(), createElementBlock("div", {
      class: "sonner-loading-wrapper",
      "data-visible": n.visible
    }, [createBaseVNode("div", i_, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(t), (i) => (openBlock(), createElementBlock("div", {
      key: `spinner-bar-${i}`,
      class: "sonner-loading-bar"
    }))), 128))])], 8, r_));
  }
});
var u_ = s_;
var o_ = {};
var a_ = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function l_(e10, t) {
  return openBlock(), createElementBlock("svg", a_, t[0] || (t[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var c_ = fs(o_, [["render", l_]]);
var f_ = {};
var h_ = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function d_(e10, t) {
  return openBlock(), createElementBlock("svg", h_, t[0] || (t[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var p_ = fs(f_, [["render", d_]]);
var m_ = {};
var g_ = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function b_(e10, t) {
  return openBlock(), createElementBlock("svg", g_, t[0] || (t[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var y_ = fs(m_, [["render", b_]]);
var x_ = {};
var w_ = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20",
  fill: "currentColor",
  height: "20",
  width: "20"
};
function v_(e10, t) {
  return openBlock(), createElementBlock("svg", w_, t[0] || (t[0] = [createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
    "clip-rule": "evenodd"
  }, null, -1)]));
}
var k_ = fs(x_, [["render", v_]]);
var __ = ["aria-label"];
var S_ = [
  "data-sonner-theme",
  "dir",
  "data-theme",
  "data-rich-colors",
  "data-y-position",
  "data-x-position",
  "data-lifted"
];
var A_ = typeof window < "u" && typeof document < "u";
function E_() {
  if (typeof window > "u" || typeof document > "u") return "ltr";
  const e10 = document.documentElement.getAttribute("dir");
  return e10 === "auto" || !e10 ? window.getComputedStyle(document.documentElement).direction : e10;
}
var C_ = defineComponent({
  name: "Toaster",
  inheritAttrs: false,
  __name: "Toaster",
  props: {
    invert: {
      type: Boolean,
      default: false
    },
    theme: { default: "light" },
    position: { default: "bottom-right" },
    hotkey: { default: () => ["altKey", "KeyT"] },
    richColors: {
      type: Boolean,
      default: false
    },
    expand: {
      type: Boolean,
      default: false
    },
    duration: {},
    gap: { default: Uk },
    visibleToasts: { default: Hk },
    closeButton: {
      type: Boolean,
      default: false
    },
    toastOptions: { default: () => ({}) },
    class: { default: "" },
    style: {},
    offset: { default: Vp },
    mobileOffset: { default: Gp },
    dir: { default: "auto" },
    swipeDirections: {},
    icons: {},
    containerAriaLabel: { default: "Notifications" }
  },
  setup(e10) {
    const t = e10, n = useAttrs(), r = ref([]);
    function i(V, te) {
      return r.value.filter((Z) => !Z.position && te === 0 || Z.position === V);
    }
    const s = computed(() => {
      const V = r.value.filter((te) => te.position).map((te) => te.position);
      return V.length > 0 ? Array.from(new Set([t.position].concat(V))) : [t.position];
    }), o = computed(() => {
      const V = {};
      return s.value.forEach((te) => {
        V[te] = r.value.filter((Z) => Z.position === te);
      }), V;
    }), l = ref([]), f = ref(false), h2 = ref(false), p = ref(t.theme !== "system" ? t.theme : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), b = ref(null), v = ref(null), k = ref(false), w = t.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    function A(V) {
      var _a2;
      ((_a2 = r.value.find((te) => te.id === V.id)) == null ? void 0 : _a2.delete) || Tt.dismiss(V.id), r.value = r.value.filter(({ id: te }) => te !== V.id), setTimeout(() => {
        r.value.find((te) => te.id === V.id) || (l.value = l.value.filter((te) => te.toastId !== V.id));
      }, Wp + 50);
    }
    function T(V) {
      var _a2, _b2;
      k.value && !((_b2 = (_a2 = V.currentTarget) == null ? void 0 : _a2.contains) == null ? void 0 : _b2.call(_a2, V.relatedTarget)) && (k.value = false, v.value && (v.value.focus({ preventScroll: true }), v.value = null));
    }
    function D(V) {
      V.target instanceof HTMLElement && V.target.dataset.dismissible === "false" || k.value || (k.value = true, v.value = V.relatedTarget);
    }
    function N(V) {
      V.target && V.target instanceof HTMLElement && V.target.dataset.dismissible === "false" || (h2.value = true);
    }
    watchEffect((V) => {
      const te = Tt.subscribe((Z) => {
        if (Z.dismiss) {
          requestAnimationFrame(() => {
            r.value = r.value.map((se) => se.id === Z.id ? {
              ...se,
              delete: true
            } : se);
          });
          return;
        }
        nextTick(() => {
          const se = r.value.findIndex((fe) => fe.id === Z.id);
          se !== -1 ? r.value = [
            ...r.value.slice(0, se),
            {
              ...r.value[se],
              ...Z
            },
            ...r.value.slice(se + 1)
          ] : r.value = [Z, ...r.value];
        });
      });
      V(te);
    }), watchEffect((V) => {
      if (typeof window > "u") return;
      if (t.theme !== "system") {
        p.value = t.theme;
        return;
      }
      const te = window.matchMedia("(prefers-color-scheme: dark)"), Z = (fe) => {
        p.value = fe ? "dark" : "light";
      };
      Z(te.matches);
      const se = (fe) => {
        Z(fe.matches);
      };
      try {
        te.addEventListener("change", se);
      } catch {
        te.addListener(se);
      }
      V(() => {
        try {
          te.removeEventListener("change", se);
        } catch {
          te.removeListener(se);
        }
      });
    }), watchEffect(() => {
      b.value && v.value && (v.value.focus({ preventScroll: true }), v.value = null, k.value = false);
    }), watchEffect(() => {
      r.value.length <= 1 && (f.value = false);
    }), watchEffect((V) => {
      function te(Z) {
        const se = t.hotkey.every((X) => Z[X] || Z.code === X), fe = Array.isArray(b.value) ? b.value[0] : b.value;
        se && (f.value = true, fe == null ? void 0 : fe.focus());
        const $ = document.activeElement === b.value || (fe == null ? void 0 : fe.contains(document.activeElement));
        Z.code === "Escape" && $ && (f.value = false);
      }
      A_ && (document.addEventListener("keydown", te), V(() => {
        document.removeEventListener("keydown", te);
      }));
    });
    function O() {
      f.value = true;
    }
    function q() {
      h2.value || (f.value = false);
    }
    function z() {
      f.value = false;
    }
    function R() {
      h2.value = false;
    }
    function J(V) {
      l.value = V;
    }
    function K(V) {
      const te = l.value.findIndex((Z) => Z.toastId === V.toastId);
      if (te !== -1) l.value[te] = V;
      else {
        const Z = l.value.findIndex((se) => se.position === V.position);
        Z !== -1 ? l.value.splice(Z, 0, V) : l.value.unshift(V);
      }
    }
    return (V, te) => (openBlock(), createElementBlock(Fragment, null, [createCommentVNode(" Remove item from normal navigation flow, only available via hotkey "), createBaseVNode("section", {
      "aria-label": `${V.containerAriaLabel} ${unref(w)}`,
      tabIndex: -1,
      "aria-live": "polite",
      "aria-relevant": "additions text",
      "aria-atomic": "false"
    }, [(openBlock(true), createElementBlock(Fragment, null, renderList(s.value, (Z, se) => {
      var _a2;
      return openBlock(), createElementBlock("ol", mergeProps({
        key: Z,
        ref_for: true,
        ref_key: "listRef",
        ref: b,
        "data-sonner-toaster": "",
        "data-sonner-theme": p.value,
        class: t.class,
        dir: V.dir === "auto" ? E_() : V.dir,
        tabIndex: -1,
        "data-theme": V.theme,
        "data-rich-colors": V.richColors,
        "data-y-position": Z.split("-")[0],
        "data-x-position": Z.split("-")[1],
        "data-lifted": f.value && r.value.length > 1 && !V.expand,
        style: {
          "--front-toast-height": `${((_a2 = l.value[0]) == null ? void 0 : _a2.height) || 0}px`,
          "--width": `${unref(jk)}px`,
          "--gap": `${V.gap}px`,
          ...V.style,
          ...unref(n).style,
          ...unref(Kk)(V.offset, V.mobileOffset)
        }
      }, V.$attrs, {
        onBlur: T,
        onFocus: D,
        onMouseenter: O,
        onMousemove: O,
        onMouseleave: q,
        onDragend: z,
        onPointerdown: N,
        onPointerup: R
      }), [(openBlock(true), createElementBlock(Fragment, null, renderList(i(Z, se), (fe, $) => {
        var _a3, _b2, _c, _d2, _e, _f2, _g2, _h2, _i2, _j;
        return openBlock(), createBlock(Jk, {
          key: fe.id,
          heights: l.value,
          icons: V.icons,
          index: $,
          toast: fe,
          defaultRichColors: V.richColors,
          duration: ((_a3 = V.toastOptions) == null ? void 0 : _a3.duration) ?? V.duration,
          class: normalizeClass(((_b2 = V.toastOptions) == null ? void 0 : _b2.class) ?? ""),
          descriptionClass: (_c = V.toastOptions) == null ? void 0 : _c.descriptionClass,
          invert: V.invert,
          visibleToasts: V.visibleToasts,
          closeButton: ((_d2 = V.toastOptions) == null ? void 0 : _d2.closeButton) ?? V.closeButton,
          interacting: h2.value,
          position: Z,
          style: normalizeStyle((_e = V.toastOptions) == null ? void 0 : _e.style),
          unstyled: (_f2 = V.toastOptions) == null ? void 0 : _f2.unstyled,
          classes: (_g2 = V.toastOptions) == null ? void 0 : _g2.classes,
          cancelButtonStyle: (_h2 = V.toastOptions) == null ? void 0 : _h2.cancelButtonStyle,
          actionButtonStyle: (_i2 = V.toastOptions) == null ? void 0 : _i2.actionButtonStyle,
          "close-button-aria-label": (_j = V.toastOptions) == null ? void 0 : _j.closeButtonAriaLabel,
          toasts: o.value[Z],
          expandByDefault: V.expand,
          gap: V.gap,
          expanded: f.value,
          swipeDirections: t.swipeDirections,
          "onUpdate:heights": J,
          "onUpdate:height": K,
          onRemoveToast: A
        }, {
          "close-icon": withCtx(() => [renderSlot(V.$slots, "close-icon", {}, () => [createVNode(n_)])]),
          "loading-icon": withCtx(() => [renderSlot(V.$slots, "loading-icon", {}, () => [createVNode(u_, { visible: fe.type === "loading" }, null, 8, ["visible"])])]),
          "success-icon": withCtx(() => [renderSlot(V.$slots, "success-icon", {}, () => [createVNode(c_)])]),
          "error-icon": withCtx(() => [renderSlot(V.$slots, "error-icon", {}, () => [createVNode(k_)])]),
          "warning-icon": withCtx(() => [renderSlot(V.$slots, "warning-icon", {}, () => [createVNode(y_)])]),
          "info-icon": withCtx(() => [renderSlot(V.$slots, "info-icon", {}, () => [createVNode(p_)])]),
          _: 2
        }, 1032, [
          "heights",
          "icons",
          "index",
          "toast",
          "defaultRichColors",
          "duration",
          "class",
          "descriptionClass",
          "invert",
          "visibleToasts",
          "closeButton",
          "interacting",
          "position",
          "style",
          "unstyled",
          "classes",
          "cancelButtonStyle",
          "actionButtonStyle",
          "close-button-aria-label",
          "toasts",
          "expandByDefault",
          "gap",
          "expanded",
          "swipeDirections"
        ]);
      }), 128))], 16, S_);
    }), 128))], 8, __)], 2112));
  }
});
var T_ = C_;
var Kp = /^[a-z0-9]+(-[a-z0-9]+)*$/;
var nu = (e10, t, n, r = "") => {
  const i = e10.split(":");
  if (e10.slice(0, 1) === "@") {
    if (i.length < 2 || i.length > 3)
      return null;
    r = i.shift().slice(1);
  }
  if (i.length > 3 || !i.length)
    return null;
  if (i.length > 1) {
    const l = i.pop(), f = i.pop(), h2 = {
      // Allow provider without '@': "provider:prefix:name"
      provider: i.length > 0 ? i[0] : r,
      prefix: f,
      name: l
    };
    return t && !o0(h2) ? null : h2;
  }
  const s = i[0], o = s.split("-");
  if (o.length > 1) {
    const l = {
      provider: r,
      prefix: o.shift(),
      name: o.join("-")
    };
    return t && !o0(l) ? null : l;
  }
  if (n && r === "") {
    const l = {
      provider: r,
      prefix: "",
      name: s
    };
    return t && !o0(l, n) ? null : l;
  }
  return null;
};
var o0 = (e10, t) => e10 ? !!// Check prefix: cannot be empty, unless allowSimpleName is enabled
// Check name: cannot be empty
((t && e10.prefix === "" || e10.prefix) && e10.name) : false;
var Xp = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
);
var N0 = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false
});
var ru = Object.freeze({
  ...Xp,
  ...N0
});
var da = Object.freeze({
  ...ru,
  body: "",
  hidden: false
});
function D_(e10, t) {
  const n = {};
  !e10.hFlip != !t.hFlip && (n.hFlip = true), !e10.vFlip != !t.vFlip && (n.vFlip = true);
  const r = ((e10.rotate || 0) + (t.rotate || 0)) % 4;
  return r && (n.rotate = r), n;
}
function Fh(e10, t) {
  const n = D_(e10, t);
  for (const r in da)
    r in N0 ? r in e10 && !(r in n) && (n[r] = N0[r]) : r in t ? n[r] = t[r] : r in e10 && (n[r] = e10[r]);
  return n;
}
function M_(e10, t) {
  const n = e10.icons, r = e10.aliases || /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null);
  function s(o) {
    if (n[o])
      return i[o] = [];
    if (!(o in i)) {
      i[o] = null;
      const l = r[o] && r[o].parent, f = l && s(l);
      f && (i[o] = [l].concat(f));
    }
    return i[o];
  }
  return Object.keys(n).concat(Object.keys(r)).forEach(s), i;
}
function N_(e10, t, n) {
  const r = e10.icons, i = e10.aliases || /* @__PURE__ */ Object.create(null);
  let s = {};
  function o(l) {
    s = Fh(
      r[l] || i[l],
      s
    );
  }
  return o(t), n.forEach(o), Fh(e10, s);
}
function Yp(e10, t) {
  const n = [];
  if (typeof e10 != "object" || typeof e10.icons != "object")
    return n;
  e10.not_found instanceof Array && e10.not_found.forEach((i) => {
    t(i, null), n.push(i);
  });
  const r = M_(e10);
  for (const i in r) {
    const s = r[i];
    s && (t(i, N_(e10, i, s)), n.push(i));
  }
  return n;
}
var I_ = {
  provider: "",
  aliases: {},
  not_found: {},
  ...Xp
};
function Co(e10, t) {
  for (const n in t)
    if (n in e10 && typeof e10[n] != typeof t[n])
      return false;
  return true;
}
function Zp(e10) {
  if (typeof e10 != "object" || e10 === null)
    return null;
  const t = e10;
  if (typeof t.prefix != "string" || !e10.icons || typeof e10.icons != "object" || !Co(e10, I_))
    return null;
  const n = t.icons;
  for (const i in n) {
    const s = n[i];
    if (
      // Name cannot be empty
      !i || // Must have body
      typeof s.body != "string" || // Check other props
      !Co(
        s,
        da
      )
    )
      return null;
  }
  const r = t.aliases || /* @__PURE__ */ Object.create(null);
  for (const i in r) {
    const s = r[i], o = s.parent;
    if (
      // Name cannot be empty
      !i || // Parent must be set and point to existing icon
      typeof o != "string" || !n[o] && !r[o] || // Check other props
      !Co(
        s,
        da
      )
    )
      return null;
  }
  return t;
}
var Bh = /* @__PURE__ */ Object.create(null);
function F_(e10, t) {
  return {
    provider: e10,
    prefix: t,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function ti(e10, t) {
  const n = Bh[e10] || (Bh[e10] = /* @__PURE__ */ Object.create(null));
  return n[t] || (n[t] = F_(e10, t));
}
function Jp(e10, t) {
  return Zp(t) ? Yp(t, (n, r) => {
    r ? e10.icons[n] = r : e10.missing.add(n);
  }) : [];
}
function B_(e10, t, n) {
  try {
    if (typeof n.body == "string")
      return e10.icons[t] = { ...n }, true;
  } catch {
  }
  return false;
}
var Ji = false;
function Qp(e10) {
  return typeof e10 == "boolean" && (Ji = e10), Ji;
}
function O_(e10) {
  const t = typeof e10 == "string" ? nu(e10, true, Ji) : e10;
  if (t) {
    const n = ti(t.provider, t.prefix), r = t.name;
    return n.icons[r] || (n.missing.has(r) ? null : void 0);
  }
}
function z_(e10, t) {
  const n = nu(e10, true, Ji);
  if (!n)
    return false;
  const r = ti(n.provider, n.prefix);
  return t ? B_(r, n.name, t) : (r.missing.add(n.name), true);
}
function $_(e10, t) {
  if (typeof e10 != "object")
    return false;
  if (typeof t != "string" && (t = e10.provider || ""), Ji && !t && !e10.prefix) {
    let i = false;
    return Zp(e10) && (e10.prefix = "", Yp(e10, (s, o) => {
      z_(s, o) && (i = true);
    })), i;
  }
  const n = e10.prefix;
  if (!o0({
    prefix: n,
    name: "a"
  }))
    return false;
  const r = ti(t, n);
  return !!Jp(r, e10);
}
var e22 = Object.freeze({
  width: null,
  height: null
});
var t2 = Object.freeze({
  // Dimensions
  ...e22,
  // Transformations
  ...N0
});
var L_ = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
var q_ = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function Oh(e10, t, n) {
  if (t === 1)
    return e10;
  if (n = n || 100, typeof e10 == "number")
    return Math.ceil(e10 * t * n) / n;
  if (typeof e10 != "string")
    return e10;
  const r = e10.split(L_);
  if (r === null || !r.length)
    return e10;
  const i = [];
  let s = r.shift(), o = q_.test(s);
  for (; ; ) {
    if (o) {
      const l = parseFloat(s);
      isNaN(l) ? i.push(s) : i.push(Math.ceil(l * t * n) / n);
    } else
      i.push(s);
    if (s = r.shift(), s === void 0)
      return i.join("");
    o = !o;
  }
}
function R_(e10, t = "defs") {
  let n = "";
  const r = e10.indexOf("<" + t);
  for (; r >= 0; ) {
    const i = e10.indexOf(">", r), s = e10.indexOf("</" + t);
    if (i === -1 || s === -1)
      break;
    const o = e10.indexOf(">", s);
    if (o === -1)
      break;
    n += e10.slice(i + 1, s).trim(), e10 = e10.slice(0, r).trim() + e10.slice(o + 1);
  }
  return {
    defs: n,
    content: e10
  };
}
function P_(e10, t) {
  return e10 ? "<defs>" + e10 + "</defs>" + t : t;
}
function H_(e10, t, n) {
  const r = R_(e10);
  return P_(r.defs, t + r.content + n);
}
var j_ = (e10) => e10 === "unset" || e10 === "undefined" || e10 === "none";
function U_(e10, t) {
  const n = {
    ...ru,
    ...e10
  }, r = {
    ...t2,
    ...t
  }, i = {
    left: n.left,
    top: n.top,
    width: n.width,
    height: n.height
  };
  let s = n.body;
  [n, r].forEach((A) => {
    const T = [], D = A.hFlip, N = A.vFlip;
    let O = A.rotate;
    D ? N ? O += 2 : (T.push(
      "translate(" + (i.width + i.left).toString() + " " + (0 - i.top).toString() + ")"
    ), T.push("scale(-1 1)"), i.top = i.left = 0) : N && (T.push(
      "translate(" + (0 - i.left).toString() + " " + (i.height + i.top).toString() + ")"
    ), T.push("scale(1 -1)"), i.top = i.left = 0);
    let q;
    switch (O < 0 && (O -= Math.floor(O / 4) * 4), O = O % 4, O) {
      case 1:
        q = i.height / 2 + i.top, T.unshift(
          "rotate(90 " + q.toString() + " " + q.toString() + ")"
        );
        break;
      case 2:
        T.unshift(
          "rotate(180 " + (i.width / 2 + i.left).toString() + " " + (i.height / 2 + i.top).toString() + ")"
        );
        break;
      case 3:
        q = i.width / 2 + i.left, T.unshift(
          "rotate(-90 " + q.toString() + " " + q.toString() + ")"
        );
        break;
    }
    O % 2 === 1 && (i.left !== i.top && (q = i.left, i.left = i.top, i.top = q), i.width !== i.height && (q = i.width, i.width = i.height, i.height = q)), T.length && (s = H_(
      s,
      '<g transform="' + T.join(" ") + '">',
      "</g>"
    ));
  });
  const o = r.width, l = r.height, f = i.width, h2 = i.height;
  let p, b;
  o === null ? (b = l === null ? "1em" : l === "auto" ? h2 : l, p = Oh(b, f / h2)) : (p = o === "auto" ? f : o, b = l === null ? Oh(p, h2 / f) : l === "auto" ? h2 : l);
  const v = {}, k = (A, T) => {
    j_(T) || (v[A] = T.toString());
  };
  k("width", p), k("height", b);
  const w = [i.left, i.top, f, h2];
  return v.viewBox = w.join(" "), {
    attributes: v,
    viewBox: w,
    body: s
  };
}
var V_ = /\sid="(\S+)"/g;
var G_ = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
var W_ = 0;
function K_(e10, t = G_) {
  const n = [];
  let r;
  for (; r = V_.exec(e10); )
    n.push(r[1]);
  if (!n.length)
    return e10;
  const i = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  return n.forEach((s) => {
    const o = typeof t == "function" ? t(s) : t + (W_++).toString(), l = s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    e10 = e10.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + l + ')([")]|\\.[a-z])', "g"),
      "$1" + o + i + "$3"
    );
  }), e10 = e10.replace(new RegExp(i, "g"), ""), e10;
}
var pa = /* @__PURE__ */ Object.create(null);
function X_(e10, t) {
  pa[e10] = t;
}
function ma(e10) {
  return pa[e10] || pa[""];
}
function xl(e10) {
  let t;
  if (typeof e10.resources == "string")
    t = [e10.resources];
  else if (t = e10.resources, !(t instanceof Array) || !t.length)
    return null;
  return {
    // API hosts
    resources: t,
    // Root path
    path: e10.path || "/",
    // URL length limit
    maxURL: e10.maxURL || 500,
    // Timeout before next host is used.
    rotate: e10.rotate || 750,
    // Timeout before failing query.
    timeout: e10.timeout || 5e3,
    // Randomise default API end point.
    random: e10.random === true,
    // Start index
    index: e10.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: e10.dataAfterTimeout !== false
  };
}
var wl = /* @__PURE__ */ Object.create(null);
var Si = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
];
var a0 = [];
for (; Si.length > 0; )
  Si.length === 1 || Math.random() > 0.5 ? a0.push(Si.shift()) : a0.push(Si.pop());
wl[""] = xl({
  resources: ["https://api.iconify.design"].concat(a0)
});
function Y_(e10, t) {
  const n = xl(t);
  return n === null ? false : (wl[e10] = n, true);
}
function vl(e10) {
  return wl[e10];
}
var Z_ = () => {
  let e10;
  try {
    if (e10 = fetch, typeof e10 == "function")
      return e10;
  } catch {
  }
};
var zh = Z_();
function J_(e10, t) {
  const n = vl(e10);
  if (!n)
    return 0;
  let r;
  if (!n.maxURL)
    r = 0;
  else {
    let i = 0;
    n.resources.forEach((o) => {
      i = Math.max(i, o.length);
    });
    const s = t + ".json?icons=";
    r = n.maxURL - i - n.path.length - s.length;
  }
  return r;
}
function Q_(e10) {
  return e10 === 404;
}
var eS = (e10, t, n) => {
  const r = [], i = J_(e10, t), s = "icons";
  let o = {
    type: s,
    provider: e10,
    prefix: t,
    icons: []
  }, l = 0;
  return n.forEach((f, h2) => {
    l += f.length + 1, l >= i && h2 > 0 && (r.push(o), o = {
      type: s,
      provider: e10,
      prefix: t,
      icons: []
    }, l = f.length), o.icons.push(f);
  }), r.push(o), r;
};
function tS(e10) {
  if (typeof e10 == "string") {
    const t = vl(e10);
    if (t)
      return t.path;
  }
  return "/";
}
var nS = (e10, t, n) => {
  if (!zh) {
    n("abort", 424);
    return;
  }
  let r = tS(t.provider);
  switch (t.type) {
    case "icons": {
      const s = t.prefix, l = t.icons.join(","), f = new URLSearchParams({
        icons: l
      });
      r += s + ".json?" + f.toString();
      break;
    }
    case "custom": {
      const s = t.uri;
      r += s.slice(0, 1) === "/" ? s.slice(1) : s;
      break;
    }
    default:
      n("abort", 400);
      return;
  }
  let i = 503;
  zh(e10 + r).then((s) => {
    const o = s.status;
    if (o !== 200) {
      setTimeout(() => {
        n(Q_(o) ? "abort" : "next", o);
      });
      return;
    }
    return i = 501, s.json();
  }).then((s) => {
    if (typeof s != "object" || s === null) {
      setTimeout(() => {
        s === 404 ? n("abort", s) : n("next", i);
      });
      return;
    }
    setTimeout(() => {
      n("success", s);
    });
  }).catch(() => {
    n("next", i);
  });
};
var rS = {
  prepare: eS,
  send: nS
};
function iS(e10) {
  const t = {
    loaded: [],
    missing: [],
    pending: []
  }, n = /* @__PURE__ */ Object.create(null);
  e10.sort((i, s) => i.provider !== s.provider ? i.provider.localeCompare(s.provider) : i.prefix !== s.prefix ? i.prefix.localeCompare(s.prefix) : i.name.localeCompare(s.name));
  let r = {
    provider: "",
    prefix: "",
    name: ""
  };
  return e10.forEach((i) => {
    if (r.name === i.name && r.prefix === i.prefix && r.provider === i.provider)
      return;
    r = i;
    const s = i.provider, o = i.prefix, l = i.name, f = n[s] || (n[s] = /* @__PURE__ */ Object.create(null)), h2 = f[o] || (f[o] = ti(s, o));
    let p;
    l in h2.icons ? p = t.loaded : o === "" || h2.missing.has(l) ? p = t.missing : p = t.pending;
    const b = {
      provider: s,
      prefix: o,
      name: l
    };
    p.push(b);
  }), t;
}
function n2(e10, t) {
  e10.forEach((n) => {
    const r = n.loaderCallbacks;
    r && (n.loaderCallbacks = r.filter((i) => i.id !== t));
  });
}
function sS(e10) {
  e10.pendingCallbacksFlag || (e10.pendingCallbacksFlag = true, setTimeout(() => {
    e10.pendingCallbacksFlag = false;
    const t = e10.loaderCallbacks ? e10.loaderCallbacks.slice(0) : [];
    if (!t.length)
      return;
    let n = false;
    const r = e10.provider, i = e10.prefix;
    t.forEach((s) => {
      const o = s.icons, l = o.pending.length;
      o.pending = o.pending.filter((f) => {
        if (f.prefix !== i)
          return true;
        const h2 = f.name;
        if (e10.icons[h2])
          o.loaded.push({
            provider: r,
            prefix: i,
            name: h2
          });
        else if (e10.missing.has(h2))
          o.missing.push({
            provider: r,
            prefix: i,
            name: h2
          });
        else
          return n = true, true;
        return false;
      }), o.pending.length !== l && (n || n2([e10], s.id), s.callback(
        o.loaded.slice(0),
        o.missing.slice(0),
        o.pending.slice(0),
        s.abort
      ));
    });
  }));
}
var uS = 0;
function oS(e10, t, n) {
  const r = uS++, i = n2.bind(null, n, r);
  if (!t.pending.length)
    return i;
  const s = {
    id: r,
    icons: t,
    callback: e10,
    abort: i
  };
  return n.forEach((o) => {
    (o.loaderCallbacks || (o.loaderCallbacks = [])).push(s);
  }), i;
}
function aS(e10, t = true, n = false) {
  const r = [];
  return e10.forEach((i) => {
    const s = typeof i == "string" ? nu(i, t, n) : i;
    s && r.push(s);
  }), r;
}
var lS = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: false,
  dataAfterTimeout: false
};
function cS(e10, t, n, r) {
  const i = e10.resources.length, s = e10.random ? Math.floor(Math.random() * i) : e10.index;
  let o;
  if (e10.random) {
    let R = e10.resources.slice(0);
    for (o = []; R.length > 1; ) {
      const J = Math.floor(Math.random() * R.length);
      o.push(R[J]), R = R.slice(0, J).concat(R.slice(J + 1));
    }
    o = o.concat(R);
  } else
    o = e10.resources.slice(s).concat(e10.resources.slice(0, s));
  const l = Date.now();
  let f = "pending", h2 = 0, p, b = null, v = [], k = [];
  typeof r == "function" && k.push(r);
  function w() {
    b && (clearTimeout(b), b = null);
  }
  function A() {
    f === "pending" && (f = "aborted"), w(), v.forEach((R) => {
      R.status === "pending" && (R.status = "aborted");
    }), v = [];
  }
  function T(R, J) {
    J && (k = []), typeof R == "function" && k.push(R);
  }
  function D() {
    return {
      startTime: l,
      payload: t,
      status: f,
      queriesSent: h2,
      queriesPending: v.length,
      subscribe: T,
      abort: A
    };
  }
  function N() {
    f = "failed", k.forEach((R) => {
      R(void 0, p);
    });
  }
  function O() {
    v.forEach((R) => {
      R.status === "pending" && (R.status = "aborted");
    }), v = [];
  }
  function q(R, J, K) {
    const V = J !== "success";
    switch (v = v.filter((te) => te !== R), f) {
      case "pending":
        break;
      case "failed":
        if (V || !e10.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (J === "abort") {
      p = K, N();
      return;
    }
    if (V) {
      p = K, v.length || (o.length ? z() : N());
      return;
    }
    if (w(), O(), !e10.random) {
      const te = e10.resources.indexOf(R.resource);
      te !== -1 && te !== e10.index && (e10.index = te);
    }
    f = "completed", k.forEach((te) => {
      te(K);
    });
  }
  function z() {
    if (f !== "pending")
      return;
    w();
    const R = o.shift();
    if (R === void 0) {
      if (v.length) {
        b = setTimeout(() => {
          w(), f === "pending" && (O(), N());
        }, e10.timeout);
        return;
      }
      N();
      return;
    }
    const J = {
      status: "pending",
      resource: R,
      callback: (K, V) => {
        q(J, K, V);
      }
    };
    v.push(J), h2++, b = setTimeout(z, e10.rotate), n(R, t, J.callback);
  }
  return setTimeout(z), D;
}
function r2(e10) {
  const t = {
    ...lS,
    ...e10
  };
  let n = [];
  function r() {
    n = n.filter((l) => l().status === "pending");
  }
  function i(l, f, h2) {
    const p = cS(
      t,
      l,
      f,
      (b, v) => {
        r(), h2 && h2(b, v);
      }
    );
    return n.push(p), p;
  }
  function s(l) {
    return n.find((f) => l(f)) || null;
  }
  return {
    query: i,
    find: s,
    setIndex: (l) => {
      t.index = l;
    },
    getIndex: () => t.index,
    cleanup: r
  };
}
function $h() {
}
var To = /* @__PURE__ */ Object.create(null);
function fS(e10) {
  if (!To[e10]) {
    const t = vl(e10);
    if (!t)
      return;
    const n = r2(t), r = {
      config: t,
      redundancy: n
    };
    To[e10] = r;
  }
  return To[e10];
}
function hS(e10, t, n) {
  let r, i;
  if (typeof e10 == "string") {
    const s = ma(e10);
    if (!s)
      return n(void 0, 424), $h;
    i = s.send;
    const o = fS(e10);
    o && (r = o.redundancy);
  } else {
    const s = xl(e10);
    if (s) {
      r = r2(s);
      const o = e10.resources ? e10.resources[0] : "", l = ma(o);
      l && (i = l.send);
    }
  }
  return !r || !i ? (n(void 0, 424), $h) : r.query(t, i, n)().abort;
}
function Lh() {
}
function dS(e10) {
  e10.iconsLoaderFlag || (e10.iconsLoaderFlag = true, setTimeout(() => {
    e10.iconsLoaderFlag = false, sS(e10);
  }));
}
function pS(e10) {
  const t = [], n = [];
  return e10.forEach((r) => {
    (r.match(Kp) ? t : n).push(r);
  }), {
    valid: t,
    invalid: n
  };
}
function Ai(e10, t, n) {
  function r() {
    const i = e10.pendingIcons;
    t.forEach((s) => {
      i && i.delete(s), e10.icons[s] || e10.missing.add(s);
    });
  }
  if (n && typeof n == "object")
    try {
      if (!Jp(e10, n).length) {
        r();
        return;
      }
    } catch (i) {
      console.error(i);
    }
  r(), dS(e10);
}
function qh(e10, t) {
  e10 instanceof Promise ? e10.then((n) => {
    t(n);
  }).catch(() => {
    t(null);
  }) : t(e10);
}
function mS(e10, t) {
  e10.iconsToLoad ? e10.iconsToLoad = e10.iconsToLoad.concat(t).sort() : e10.iconsToLoad = t, e10.iconsQueueFlag || (e10.iconsQueueFlag = true, setTimeout(() => {
    e10.iconsQueueFlag = false;
    const { provider: n, prefix: r } = e10, i = e10.iconsToLoad;
    if (delete e10.iconsToLoad, !i || !i.length)
      return;
    const s = e10.loadIcon;
    if (e10.loadIcons && (i.length > 1 || !s)) {
      qh(
        e10.loadIcons(i, r, n),
        (p) => {
          Ai(e10, i, p);
        }
      );
      return;
    }
    if (s) {
      i.forEach((p) => {
        const b = s(p, r, n);
        qh(b, (v) => {
          const k = v ? {
            prefix: r,
            icons: {
              [p]: v
            }
          } : null;
          Ai(e10, [p], k);
        });
      });
      return;
    }
    const { valid: o, invalid: l } = pS(i);
    if (l.length && Ai(e10, l, null), !o.length)
      return;
    const f = r.match(Kp) ? ma(n) : null;
    if (!f) {
      Ai(e10, o, null);
      return;
    }
    f.prepare(n, r, o).forEach((p) => {
      hS(n, p, (b) => {
        Ai(e10, p.icons, b);
      });
    });
  }));
}
var gS = (e10, t) => {
  const n = aS(e10, true, Qp()), r = iS(n);
  if (!r.pending.length) {
    let f = true;
    return t && setTimeout(() => {
      f && t(
        r.loaded,
        r.missing,
        r.pending,
        Lh
      );
    }), () => {
      f = false;
    };
  }
  const i = /* @__PURE__ */ Object.create(null), s = [];
  let o, l;
  return r.pending.forEach((f) => {
    const { provider: h2, prefix: p } = f;
    if (p === l && h2 === o)
      return;
    o = h2, l = p, s.push(ti(h2, p));
    const b = i[h2] || (i[h2] = /* @__PURE__ */ Object.create(null));
    b[p] || (b[p] = []);
  }), r.pending.forEach((f) => {
    const { provider: h2, prefix: p, name: b } = f, v = ti(h2, p), k = v.pendingIcons || (v.pendingIcons = /* @__PURE__ */ new Set());
    k.has(b) || (k.add(b), i[h2][p].push(b));
  }), s.forEach((f) => {
    const h2 = i[f.provider][f.prefix];
    h2.length && mS(f, h2);
  }), t ? oS(t, r, s) : Lh;
};
function bS(e10, t) {
  const n = {
    ...e10
  };
  for (const r in t) {
    const i = t[r], s = typeof i;
    r in e22 ? (i === null || i && (s === "string" || s === "number")) && (n[r] = i) : s === typeof n[r] && (n[r] = r === "rotate" ? i % 4 : i);
  }
  return n;
}
var yS = /[\s,]+/;
function xS(e10, t) {
  t.split(yS).forEach((n) => {
    switch (n.trim()) {
      case "horizontal":
        e10.hFlip = true;
        break;
      case "vertical":
        e10.vFlip = true;
        break;
    }
  });
}
function wS(e10, t = 0) {
  const n = e10.replace(/^-?[0-9.]*/, "");
  function r(i) {
    for (; i < 0; )
      i += 4;
    return i % 4;
  }
  if (n === "") {
    const i = parseInt(e10);
    return isNaN(i) ? 0 : r(i);
  } else if (n !== e10) {
    let i = 0;
    switch (n) {
      case "%":
        i = 25;
        break;
      case "deg":
        i = 90;
    }
    if (i) {
      let s = parseFloat(e10.slice(0, e10.length - n.length));
      return isNaN(s) ? 0 : (s = s / i, s % 1 === 0 ? r(s) : 0);
    }
  }
  return t;
}
function vS(e10, t) {
  let n = e10.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const r in t)
    n += " " + r + '="' + t[r] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + n + ">" + e10 + "</svg>";
}
function kS(e10) {
  return e10.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function _S(e10) {
  return "data:image/svg+xml," + kS(e10);
}
function SS(e10) {
  return 'url("' + _S(e10) + '")';
}
var Rh = {
  ...t2,
  inline: false
};
var AS = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "aria-hidden": true,
  role: "img"
};
var ES = {
  display: "inline-block"
};
var ga = {
  backgroundColor: "currentColor"
};
var i2 = {
  backgroundColor: "transparent"
};
var Ph = {
  Image: "var(--svg)",
  Repeat: "no-repeat",
  Size: "100% 100%"
};
var Hh = {
  webkitMask: ga,
  mask: ga,
  background: i2
};
for (const e10 in Hh) {
  const t = Hh[e10];
  for (const n in Ph)
    t[e10 + n] = Ph[n];
}
var l0 = {};
["horizontal", "vertical"].forEach((e10) => {
  const t = e10.slice(0, 1) + "Flip";
  l0[e10 + "-flip"] = t, l0[e10.slice(0, 1) + "-flip"] = t, l0[e10 + "Flip"] = t;
});
function jh(e10) {
  return e10 + (e10.match(/^[-0-9.]+$/) ? "px" : "");
}
var Uh = (e10, t) => {
  const n = bS(Rh, t), r = { ...AS }, i = t.mode || "svg", s = {}, o = t.style, l = typeof o == "object" && !(o instanceof Array) ? o : {};
  for (let A in t) {
    const T = t[A];
    if (T !== void 0)
      switch (A) {
        case "icon":
        case "style":
        case "onLoad":
        case "mode":
        case "ssr":
          break;
        case "inline":
        case "hFlip":
        case "vFlip":
          n[A] = T === true || T === "true" || T === 1;
          break;
        case "flip":
          typeof T == "string" && xS(n, T);
          break;
        case "color":
          s.color = T;
          break;
        case "rotate":
          typeof T == "string" ? n[A] = wS(T) : typeof T == "number" && (n[A] = T);
          break;
        case "ariaHidden":
        case "aria-hidden":
          T !== true && T !== "true" && delete r["aria-hidden"];
          break;
        default: {
          const D = l0[A];
          D ? (T === true || T === "true" || T === 1) && (n[D] = true) : Rh[A] === void 0 && (r[A] = T);
        }
      }
  }
  const f = U_(e10, n), h2 = f.attributes;
  if (n.inline && (s.verticalAlign = "-0.125em"), i === "svg") {
    r.style = {
      ...s,
      ...l
    }, Object.assign(r, h2);
    let A = 0, T = t.id;
    return typeof T == "string" && (T = T.replace(/-/g, "_")), r.innerHTML = K_(f.body, T ? () => T + "ID" + A++ : "iconifyVue"), h("svg", r);
  }
  const { body: p, width: b, height: v } = e10, k = i === "mask" || (i === "bg" ? false : p.indexOf("currentColor") !== -1), w = vS(p, {
    ...h2,
    width: b + "",
    height: v + ""
  });
  return r.style = {
    ...s,
    "--svg": SS(w),
    width: jh(h2.width),
    height: jh(h2.height),
    ...ES,
    ...k ? ga : i2,
    ...l
  }, h("span", r);
};
Qp(true);
X_("", rS);
if (typeof document < "u" && typeof window < "u") {
  const e10 = window;
  if (e10.IconifyPreload !== void 0) {
    const t = e10.IconifyPreload, n = "Invalid IconifyPreload syntax.";
    typeof t == "object" && t !== null && (t instanceof Array ? t : [t]).forEach((r) => {
      try {
        (typeof r != "object" || r === null || r instanceof Array || // Check for 'icons' and 'prefix'
        typeof r.icons != "object" || typeof r.prefix != "string" || // Add icon set
        !$_(r)) && console.error(n);
      } catch {
        console.error(n);
      }
    });
  }
  if (e10.IconifyProviders !== void 0) {
    const t = e10.IconifyProviders;
    if (typeof t == "object" && t !== null)
      for (let n in t) {
        const r = "IconifyProviders[" + n + "] is invalid.";
        try {
          const i = t[n];
          if (typeof i != "object" || !i || i.resources === void 0)
            continue;
          Y_(n, i) || console.error(r);
        } catch {
          console.error(r);
        }
      }
  }
}
var CS = {
  ...ru,
  body: ""
};
var Br = defineComponent((e10, { emit: t }) => {
  const n = ref(null);
  function r() {
    var _a2, _b2;
    n.value && ((_b2 = (_a2 = n.value).abort) == null ? void 0 : _b2.call(_a2), n.value = null);
  }
  const i = ref(!!e10.ssr), s = ref(""), o = shallowRef(null);
  function l() {
    const h2 = e10.icon;
    if (typeof h2 == "object" && h2 !== null && typeof h2.body == "string")
      return s.value = "", {
        data: h2
      };
    let p;
    if (typeof h2 != "string" || (p = nu(h2, false, true)) === null)
      return null;
    let b = O_(p);
    if (!b) {
      const w = n.value;
      return (!w || w.name !== h2) && (b === null ? n.value = {
        name: h2
      } : n.value = {
        name: h2,
        abort: gS([p], f)
      }), null;
    }
    r(), s.value !== h2 && (s.value = h2, nextTick(() => {
      t("load", h2);
    }));
    const v = e10.customise;
    if (v) {
      b = Object.assign({}, b);
      const w = v(b.body, p.name, p.prefix, p.provider);
      typeof w == "string" && (b.body = w);
    }
    const k = ["iconify"];
    return p.prefix !== "" && k.push("iconify--" + p.prefix), p.provider !== "" && k.push("iconify--" + p.provider), { data: b, classes: k };
  }
  function f() {
    var _a2;
    const h2 = l();
    h2 ? h2.data !== ((_a2 = o.value) == null ? void 0 : _a2.data) && (o.value = h2) : o.value = null;
  }
  return i.value ? f() : onMounted(() => {
    i.value = true, f();
  }), watch(() => e10.icon, f), onUnmounted(r), () => {
    const h2 = o.value;
    if (!h2)
      return Uh(CS, e10);
    let p = e10;
    return h2.classes && (p = {
      ...e10,
      class: h2.classes.join(" ")
    }), Uh({
      ...ru,
      ...h2.data
    }, p);
  };
}, {
  props: [
    // Icon and render mode
    "icon",
    "mode",
    "ssr",
    // Layout and style
    "width",
    "height",
    "style",
    "color",
    "inline",
    // Transformations
    "rotate",
    "hFlip",
    "horizontalFlip",
    "vFlip",
    "verticalFlip",
    "flip",
    // Misc
    "id",
    "ariaHidden",
    "customise",
    "title"
  ],
  emits: ["load"]
});
function iu(e10) {
  return getCurrentScope() ? (onScopeDispose(e10), true) : false;
}
var su = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
var TS = Object.prototype.toString;
var s2 = (e10) => TS.call(e10) === "[object Object]";
var DS = () => {
};
var Vh = MS();
function MS() {
  var e10, t;
  return su && ((e10 = window == null ? void 0 : window.navigator) == null ? void 0 : e10.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function NS(...e10) {
  if (e10.length !== 1)
    return toRef(...e10);
  const t = e10[0];
  return typeof t == "function" ? readonly(customRef(() => ({ get: t, set: DS }))) : ref(t);
}
function Gr(e10) {
  return Array.isArray(e10) ? e10 : [e10];
}
function IS(e10) {
  return getCurrentInstance();
}
function FS(e10, t = true, n) {
  IS() ? onMounted(e10, n) : t ? e10() : nextTick(e10);
}
function u2(e10, t, n) {
  return watch(
    e10,
    t,
    {
      ...n,
      immediate: true
    }
  );
}
var BS = su ? window : void 0;
var OS = su ? window.document : void 0;
function ba(e10) {
  var t;
  const n = toValue(e10);
  return (t = n == null ? void 0 : n.$el) != null ? t : n;
}
function Gh(...e10) {
  const t = [], n = () => {
    t.forEach((l) => l()), t.length = 0;
  }, r = (l, f, h2, p) => (l.addEventListener(f, h2, p), () => l.removeEventListener(f, h2, p)), i = computed(() => {
    const l = Gr(toValue(e10[0])).filter((f) => f != null);
    return l.every((f) => typeof f != "string") ? l : void 0;
  }), s = u2(
    () => {
      var l, f;
      return [
        (f = (l = i.value) == null ? void 0 : l.map((h2) => ba(h2))) != null ? f : [BS].filter((h2) => h2 != null),
        Gr(toValue(i.value ? e10[1] : e10[0])),
        Gr(unref(i.value ? e10[2] : e10[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        toValue(i.value ? e10[3] : e10[2])
      ];
    },
    ([l, f, h2, p]) => {
      if (n(), !(l == null ? void 0 : l.length) || !(f == null ? void 0 : f.length) || !(h2 == null ? void 0 : h2.length))
        return;
      const b = s2(p) ? { ...p } : p;
      t.push(
        ...l.flatMap(
          (v) => f.flatMap(
            (k) => h2.map((w) => r(v, k, w, b))
          )
        )
      );
    },
    { flush: "post" }
  ), o = () => {
    s(), n();
  };
  return iu(n), o;
}
function zS() {
  const e10 = shallowRef(false), t = getCurrentInstance();
  return t && onMounted(() => {
    e10.value = true;
  }, t), e10;
}
function $S(e10) {
  const t = zS();
  return computed(() => (t.value, !!e10()));
}
var Wh = [
  "fullscreenchange",
  "webkitfullscreenchange",
  "webkitendfullscreen",
  "mozfullscreenchange",
  "MSFullscreenChange"
];
function LS(e10, t = {}) {
  const {
    document: n = OS,
    autoExit: r = false
  } = t, i = computed(() => {
    var N;
    return (N = ba(e10)) != null ? N : n == null ? void 0 : n.documentElement;
  }), s = shallowRef(false), o = computed(() => [
    "requestFullscreen",
    "webkitRequestFullscreen",
    "webkitEnterFullscreen",
    "webkitEnterFullScreen",
    "webkitRequestFullScreen",
    "mozRequestFullScreen",
    "msRequestFullscreen"
  ].find((N) => n && N in n || i.value && N in i.value)), l = computed(() => [
    "exitFullscreen",
    "webkitExitFullscreen",
    "webkitExitFullScreen",
    "webkitCancelFullScreen",
    "mozCancelFullScreen",
    "msExitFullscreen"
  ].find((N) => n && N in n || i.value && N in i.value)), f = computed(() => [
    "fullScreen",
    "webkitIsFullScreen",
    "webkitDisplayingFullscreen",
    "mozFullScreen",
    "msFullscreenElement"
  ].find((N) => n && N in n || i.value && N in i.value)), h2 = [
    "fullscreenElement",
    "webkitFullscreenElement",
    "mozFullScreenElement",
    "msFullscreenElement"
  ].find((N) => n && N in n), p = $S(() => i.value && n && o.value !== void 0 && l.value !== void 0 && f.value !== void 0), b = () => h2 ? (n == null ? void 0 : n[h2]) === i.value : false, v = () => {
    if (f.value) {
      if (n && n[f.value] != null)
        return n[f.value];
      {
        const N = i.value;
        if ((N == null ? void 0 : N[f.value]) != null)
          return !!N[f.value];
      }
    }
    return false;
  };
  async function k() {
    if (!(!p.value || !s.value)) {
      if (l.value)
        if ((n == null ? void 0 : n[l.value]) != null)
          await n[l.value]();
        else {
          const N = i.value;
          (N == null ? void 0 : N[l.value]) != null && await N[l.value]();
        }
      s.value = false;
    }
  }
  async function w() {
    if (!p.value || s.value)
      return;
    v() && await k();
    const N = i.value;
    o.value && (N == null ? void 0 : N[o.value]) != null && (await N[o.value](), s.value = true);
  }
  async function A() {
    await (s.value ? k() : w());
  }
  const T = () => {
    const N = v();
    (!N || N && b()) && (s.value = N);
  }, D = { capture: false, passive: true };
  return Gh(n, Wh, T, D), Gh(() => ba(i), Wh, T, D), FS(T, false), r && iu(k), {
    isSupported: p,
    isFullscreen: s,
    enter: w,
    exit: k,
    toggle: A
  };
}
var qS = su ? window : void 0;
function RS(e10) {
  var t;
  const n = toValue(e10);
  return (t = n == null ? void 0 : n.$el) != null ? t : n;
}
function PS(...e10) {
  const t = [], n = () => {
    t.forEach((l) => l()), t.length = 0;
  }, r = (l, f, h2, p) => (l.addEventListener(f, h2, p), () => l.removeEventListener(f, h2, p)), i = computed(() => {
    const l = Gr(toValue(e10[0])).filter((f) => f != null);
    return l.every((f) => typeof f != "string") ? l : void 0;
  }), s = u2(
    () => {
      var l, f;
      return [
        (f = (l = i.value) == null ? void 0 : l.map((h2) => RS(h2))) != null ? f : [qS].filter((h2) => h2 != null),
        Gr(toValue(i.value ? e10[1] : e10[0])),
        Gr(unref(i.value ? e10[2] : e10[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        toValue(i.value ? e10[3] : e10[2])
      ];
    },
    ([l, f, h2, p]) => {
      if (n(), !(l == null ? void 0 : l.length) || !(f == null ? void 0 : f.length) || !(h2 == null ? void 0 : h2.length))
        return;
      const b = s2(p) ? { ...p } : p;
      t.push(
        ...l.flatMap(
          (v) => f.flatMap(
            (k) => h2.map((w) => r(v, k, w, b))
          )
        )
      );
    },
    { flush: "post" }
  ), o = () => {
    s(), n();
  };
  return iu(n), o;
}
var HS = defineComponent({
  name: "UseFullscreen",
  props: ["as"],
  setup(e10, { slots: t }) {
    const n = shallowRef(), r = reactive(LS(n));
    return () => {
      if (t.default)
        return h(e10.as || "div", { ref: n }, t.default(r));
    };
  }
});
function Do(e10) {
  return typeof Window < "u" && e10 instanceof Window ? e10.document.documentElement : typeof Document < "u" && e10 instanceof Document ? e10.documentElement : e10;
}
function o2(e10) {
  const t = window.getComputedStyle(e10);
  if (t.overflowX === "scroll" || t.overflowY === "scroll" || t.overflowX === "auto" && e10.clientWidth < e10.scrollWidth || t.overflowY === "auto" && e10.clientHeight < e10.scrollHeight)
    return true;
  {
    const n = e10.parentNode;
    return !n || n.tagName === "BODY" ? false : o2(n);
  }
}
function jS(e10) {
  const t = e10 || window.event, n = t.target;
  return o2(n) ? false : t.touches.length > 1 ? true : (t.preventDefault && t.preventDefault(), false);
}
var Mo = /* @__PURE__ */ new WeakMap();
function US(e10, t = false) {
  const n = shallowRef(t);
  let r = null, i = "";
  watch(NS(e10), (l) => {
    const f = Do(toValue(l));
    if (f) {
      const h2 = f;
      if (Mo.get(h2) || Mo.set(h2, h2.style.overflow), h2.style.overflow !== "hidden" && (i = h2.style.overflow), h2.style.overflow === "hidden")
        return n.value = true;
      if (n.value)
        return h2.style.overflow = "hidden";
    }
  }, {
    immediate: true
  });
  const s = () => {
    const l = Do(toValue(e10));
    !l || n.value || (Vh && (r = PS(
      l,
      "touchmove",
      (f) => {
        jS(f);
      },
      { passive: false }
    )), l.style.overflow = "hidden", n.value = true);
  }, o = () => {
    const l = Do(toValue(e10));
    !l || !n.value || (Vh && (r == null ? void 0 : r()), l.style.overflow = i, Mo.delete(l), n.value = false);
  };
  return iu(o), computed({
    get() {
      return n.value;
    },
    set(l) {
      l ? s() : o();
    }
  });
}
function VS() {
  let e10 = false;
  const t = shallowRef(false);
  return (n, r) => {
    if (t.value = r.value, e10)
      return;
    e10 = true;
    const i = US(n, r.value);
    watch(t, (s) => i.value = s);
  };
}
VS();
var GS = ["id"];
var WS = ["onClick"];
var KS = defineComponent({
  __name: "MarkmapRoot",
  props: {
    markdown: {},
    type: { default: "view" },
    showToolbar: { default: "0" },
    config: { default: "" }
  },
  setup(e10) {
    const t = e10, n = computed(() => typeof document > "u" ? false : !!(document.documentElement.classList.contains("dark") || window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches)), r = ref(), i = ref(), s = shallowRef(), o = ref(), l = ref(
      `markmap-${Math.random().toString(36).substring(2, 15)}`
    ), f = computed(() => {
      if (!t.config) return {};
      try {
        return JSON.parse(decodeURIComponent(t.config));
      } catch (z) {
        return console.warn("è§£æç”¨æˆ·é…ç½®å¤±è´¥:", z), {};
      }
    }), h2 = computed(() => {
      const z = {
        initialExpandLevel: -1
      };
      return Object.assign(z, f.value), Mv(z);
    });
    function p() {
      if (!i.value || !t.markdown) return;
      const z = new B9(), { root: R } = z.transform(decodeURIComponent(t.markdown));
      s.value ? (s.value.setOptions(h2.value), s.value.setData(R), s.value.fit()) : s.value = pl.create(i.value, h2.value, R);
    }
    async function b() {
      if (!s.value || !i.value || !r.value) return;
      const z = r.value.querySelector(
        `#toolbar-${l.value}`
      );
      try {
        z && (z.style.display = "none"), s.value.fit(), await (await dt(r.value, {
          scale: 2,
          quality: 1,
          backgroundColor: getComputedStyle(
            document.documentElement
          ).getPropertyValue("--vp-c-bg-soft")
        })).download({ format: "png", filename: "markmap" });
      } catch (R) {
        console.error("ä¸‹è½½å›¾ç‰‡å¤±è´¥:", R), alert("ä¸‹è½½å›¾ç‰‡å¤±è´¥ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨å®‰å…¨è®¾ç½®æˆ–å°è¯•å…¶ä»–æµè§ˆå™¨");
      } finally {
        z && (z.style.display = "flex");
      }
    }
    function v() {
      s.value && s.value.rescale(1.25);
    }
    function k() {
      s.value && s.value.rescale(0.8);
    }
    function w() {
      s.value && s.value.fit();
    }
    async function A() {
      if (t.markdown)
        try {
          const z = decodeURIComponent(t.markdown);
          Ok(z), Nh.success("å¤åˆ¶æˆåŠŸï¼");
        } catch (z) {
          console.error("å¤åˆ¶å¤±è´¥:", z), Nh.error("å¤åˆ¶å¤±è´¥ï¼Œè¯·é‡è¯•");
        }
    }
    function T() {
      s.value && setTimeout(() => {
        var _a2;
        (_a2 = s.value) == null ? void 0 : _a2.fit();
      }, 100);
    }
    watch(
      () => t.markdown,
      () => {
        p();
      }
    ), watch(
      () => n.value,
      () => {
        s.value && (s.value.setOptions(h2.value), s.value.renderData());
      }
    );
    const D = ref(null);
    function N() {
      s.value && (s.value.setOptions(h2.value), s.value.renderData());
    }
    onMounted(() => {
      p(), window.ResizeObserver && (o.value = new ResizeObserver(T), i.value.parentElement && o.value.observe(i.value.parentElement)), window.addEventListener("resize", T), typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", N), typeof window < "u" && window.MutationObserver && (D.value = new MutationObserver((z) => {
        for (const R of z)
          if (R.attributeName === "class" && R.target === document.documentElement) {
            s.value && (s.value.setOptions(h2.value), s.value.renderData());
            break;
          }
      }), D.value.observe(document.documentElement, {
        attributes: true
      }));
    }), onBeforeUnmount(() => {
      if (o.value && o.value.disconnect(), window.removeEventListener("resize", T), typeof window < "u" && window.matchMedia) {
        const z = window.matchMedia(
          "(prefers-color-scheme: dark)"
        );
        z.removeEventListener("change", N), z.removeListener(() => {
        });
      }
      D.value && D.value.disconnect();
    });
    const O = () => {
      const z = window.document.querySelector(
        `#toolbar-${l.value}`
      );
      z.style.opacity = "1";
    }, q = () => {
      const z = window.document.querySelector(
        `#toolbar-${l.value}`
      );
      z.style.opacity = "0";
    };
    return (z, R) => (openBlock(), createElementBlock(Fragment, null, [
      createVNode(unref(HS), null, {
        default: withCtx(({ toggle: J, isFullscreen: K }) => [
          createBaseVNode("div", {
            ref_key: "markmapContainerRef",
            ref: r,
            class: "markmap-container",
            onMouseenter: O,
            onMouseleave: q
          }, [
            (openBlock(), createElementBlock("svg", {
              ref_key: "svgRef",
              ref: i,
              style: { "min-height": "400px" }
            }, null, 512)),
            withDirectives(createBaseVNode("div", {
              id: `toolbar-${l.value}`,
              class: "toolbar"
            }, [
              createBaseVNode("button", {
                class: "toolbar-btn",
                title: "æ”¾å¤§",
                onClick: v
              }, [
                createVNode(unref(Br), { icon: "lucide:zoom-in" })
              ]),
              createBaseVNode("button", {
                class: "toolbar-btn",
                title: "ç¼©å°",
                onClick: k
              }, [
                createVNode(unref(Br), { icon: "lucide:zoom-out" })
              ]),
              createBaseVNode("button", {
                class: "toolbar-btn",
                title: "é€‚åº”å±å¹•",
                onClick: w
              }, [
                createVNode(unref(Br), { icon: "lucide:maximize-2" })
              ]),
              createBaseVNode("button", {
                class: "toolbar-btn",
                title: "å¤åˆ¶Markdownå†…å®¹",
                onClick: A
              }, [
                createVNode(unref(Br), { icon: "lucide:copy" })
              ]),
              createBaseVNode("button", {
                class: "toolbar-btn",
                title: "ä¸‹è½½ä¸ºPNGå›¾ç‰‡",
                onClick: b
              }, [
                createVNode(unref(Br), { icon: "lucide:download" })
              ]),
              createBaseVNode("button", {
                class: "toolbar-btn",
                title: "å…¨å±",
                onClick: J
              }, [
                createVNode(unref(Br), {
                  icon: K ? "lucide:minimize-2" : "lucide:maximize"
                }, null, 8, ["icon"])
              ], 8, WS)
            ], 8, GS), [
              [vShow, Number(t.showToolbar) === 1]
            ])
          ], 544)
        ]),
        _: 1
      }),
      createVNode(unref(T_), {
        position: "top-right",
        "rich-colors": ""
      })
    ], 64));
  }
});
var XS = (e10, t) => {
  const n = e10.__vccOpts || e10;
  for (const [r, i] of t)
    n[r] = i;
  return n;
};
var YS = XS(KS, [["__scopeId", "data-v-c540f87c"]]);
function bA(e10) {
  e10.component("MarkmapRoot", YS);
}
export {
  bA as initComponent
};
/*! Bundled license information:

vitepress-markmap-preview/dist/component.js:
  (*! @gera2ld/jsx-dom v2.2.2 | ISC License *)
*/
//# sourceMappingURL=vitepress-markmap-preview_component.js.map
